[Script Info]
; Script generated by Aegisub 3.2.1
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None
PlayResX: 1920
PlayResY: 1080

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: Droidcon Montreal - Dave Smith - Mastering Recycler View.mp4
Video Zoom Percent: 0.250000
Active Line: 1

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: en,Monaco,48,&H00FFFFFF,&H00FFFFFF,&H000405FF,&H00101012,-1,0,0,0,100,100,0,0,1,1.5,0,2,15,15,15,1
Style: ch,Heiti SC,70,&H00FFFFFF,&H00FBFBFF,&H00AD9000,&H00000000,0,0,0,0,100,100,0,0,1,1.5,0.45,2,15,15,15,1
Style: Default,Arial,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,3,3,2,15,15,15,1
Style: 城之内,Weibei SC,48,&H00FFFFFF,&H00FEFEFF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1.2,0.45,2,15,15,15,134
Style: 游戏,Hiragino Sans GB,48,&H00FFFFFF,&H00FEFEFF,&H00FF0000,&H00000000,0,0,0,0,100,100,0,0,1,1.05,0.3,2,15,15,18,1
Style: 十代,Songti SC,48,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1.5,0.3,2,15,15,15,1
Style: 海马,Kaiti TC,30,&H00FFFFFF,&H00FEFEFF,&H00060607,&H00000000,0,0,0,0,100,100,0,0,1,1.5,0.3,2,15,15,15,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:09.42,城之内,,0,0,0,,{\an8}中英字幕by:Ocean-藏心(微博)    推荐指数:★★★★☆\N简介: 深入剖析了RecyclerView中最核心的布局管理器部分,\N也捎带讲解了RecyclerView的其他机制,看完之后,你会真正明白为何ListView要被废弃.
Dialogue: 0,0:00:00.00,0:00:04.61,ch,,0,0,0,,精通RecyclerView布局\N{\ren}Mastering RecyclerView Layouts
Dialogue: 0,0:00:04.61,0:00:06.33,ch,,0,0,0,,你好,他好,大家好\N{\ren}hello hello everyone
Dialogue: 0,0:00:06.33,0:00:10.28,ch,,0,0,0,,进来,坐好,我要开始讲了.下午好\N{\ren}come sit stay awhile good afternoon
Dialogue: 0,0:00:10.28,0:00:14.20,ch,,0,0,0,,今天大家过的如何?噢,大家的答案我喜欢听\N{\ren}how's everyone today the that's what I like to hear
Dialogue: 0,0:00:14.20,0:00:19.37,ch,,0,0,0,,我叫大卫-史密斯,我是NewCircle培训中心的Android老大\N{\ren}I hello everyone my name is Dave Smith I am the Android lead for new circle training
Dialogue: 0,0:00:19.37,0:00:23.35,ch,,0,0,0,,我们对很多技术做开源的培训,Android只是其中一项\N{\ren}we do open Source Training a number of technologies and reduce happens to be one of them
Dialogue: 0,0:00:23.35,0:00:26.77,ch,,0,0,0,,不过言归正传,今天我要谈的主题是\N{\ren}I'm gonna be here to you today to talk about
Dialogue: 0,0:00:26.77,0:00:31.26,ch,,0,0,0,,精通RecyclerView的布局.\n我们的关注点不在于如何具体的\N{\ren}mastering recycler view layouts I we're not gonna talk more specifically about
Dialogue: 0,0:00:31.26,0:00:33.19,ch,,0,0,0,,具体的使用RecyclerView\N{\ren}how to use recycler view
Dialogue: 0,0:00:33.19,0:00:38.09,ch,,0,0,0,,而在于如何\N{\ren}in the generals a sense today we're going to be talking mostly about building
Dialogue: 0,0:00:38.09,0:00:40.59,ch,,0,0,0,,自定义RecyclerView的布局管理器\N{\ren}custom layout managers with recyclerView
Dialogue: 0,0:00:40.59,0:00:43.61,ch,,0,0,0,,以及我们在自定义布局管理器过程中\n应该注意的事情\N{\ren}and how we can kind of get through that process so
Dialogue: 0,0:00:43.61,0:00:46.99,ch,,0,0,0,,先给大家说说我站在这儿的原因\N{\ren}a little bit about why I'm here standing in front of you today
Dialogue: 0,0:00:46.99,0:00:50.01,ch,,0,0,0,,正所谓前人栽树,后人乘凉嘛\N{\ren}call it a bit of (Hannah) a humanitarian\Neffort
Dialogue: 0,0:00:50.01,0:00:54.52,ch,,0,0,0,,我会给你介绍你可能需要到的工具(指API的帮助类)\N{\ren}I'm really here to give you the tools\Nhopefully that you will need
Dialogue: 0,0:00:54.52,0:00:58.48,ch,,0,0,0,,当你尝试使用RecyclerView时,当你为了特定的需求\N{\ren}if you are trying to use recycler view\Nyou're trying to customize it for your
Dialogue: 0,0:00:58.48,0:00:59.79,ch,,0,0,0,,而去自定义RecyclerView时将有所帮助\N{\ren}specific purposes
Dialogue: 0,0:00:59.79,0:01:03.60,ch,,0,0,0,,我会尽力带你把这整个过程走通\N{\ren}and trying to get you through that\Nprocess with out losing
Dialogue: 0,0:01:03.60,0:01:07.32,ch,,0,0,0,,来让你少走弯路\N{\ren}you know essentially losing your mind\NI'm so
Dialogue: 0,0:01:07.32,0:01:12.53,ch,,0,0,0,,在我们深入讲解之前,我想确保大家是不是都在一个级别上\N{\ren}before we dive too deep into the details\NI just wanna make sure that everybody's on the same page so
Dialogue: 0,0:01:12.53,0:01:16.18,ch,,0,0,0,,那么大家所看到的这种情况是从哪儿来的呢\N{\ren}where does this all this come from you\Nknow the
Dialogue: 0,0:01:16.18,0:01:20.77,ch,,0,0,0,,众所周知,视图回收的这种主意是一种惯用的技术,\N{\ren}this idea of view recycling is a\Npattern that's used in mobile all over
Dialogue: 0,0:01:20.77,0:01:22.72,ch,,0,0,0,,其被用于所有的移动平台\N{\ren}the place all mobile platforms do this
Dialogue: 0,0:01:22.72,0:01:26.15,ch,,0,0,0,,android恰好是其中一个而已.\N{\ren}android just happens to do it as well\Nit has done this
Dialogue: 0,0:01:26.15,0:01:29.67,ch,,0,0,0,,从android1.0就有了,说具体点,这种机制体现在\N{\ren}since version 1 I  most specifically
Dialogue: 0,0:01:29.67,0:01:33.60,ch,,0,0,0,,LisView这个控件上.想必各位都用过不下百十次吧\N{\ren}in the format ListView most of us have\Nprobably use a number of times
Dialogue: 0,0:01:33.60,0:01:37.45,ch,,0,0,0,,我只是好奇,请举下手.各位都有谁真的尝试着\N{\ren}I am just curious shorthand how many\Nhave you have actually tried to use
Dialogue: 0,0:01:37.45,0:01:38.42,ch,,0,0,0,,去用RecyclerView呢\N{\ren}recycler view
Dialogue: 0,0:01:38.42,0:01:43.02,ch,,0,0,0,,还不错嘛.那么,有谁试着去写自定义的布局管理器呢\N{\ren}before,pretty good.how many have you tried to\Nbuild your own layout manager
Dialogue: 0,0:01:43.02,0:01:46.09,ch,,0,0,0,,貌似人不多咯.不过超过我的预期咯\N{\ren}okay more than I expected good
Dialogue: 0,0:01:46.09,0:01:50.42,ch,,0,0,0,,其实更重要的是,各位的头发都还在.这比啥都好啊.\N{\ren}and mostly you still have your hair\Nthat even better so
Dialogue: 0,0:01:50.42,0:01:55.36,ch,,0,0,0,,这种对视图的回收利用机制使我们\N{\ren}this this idea view recycling is really\Nit allows developers and it allows
Dialogue: 0,0:01:55.36,0:01:56.72,ch,,0,0,0,,的设备能够\N{\ren}devices to
Dialogue: 0,0:01:56.72,0:02:00.99,ch,,0,0,0,,展现非常大的数据集合,可能是成百上千条\N{\ren}present large collections of data\Nmaybe hundreds or even thousands of
Dialogue: 0,0:02:00.99,0:02:01.64,ch,,0,0,0,,的数据项\N{\ren}items
Dialogue: 0,0:02:01.64,0:02:05.13,ch,,0,0,0,,给用户.但又仅仅用有限的几个视图便可完成\N{\ren}to the user but only using a handful of\Nviews
Dialogue: 0,0:02:05.13,0:02:08.56,ch,,0,0,0,,不必创建跟数据项个数一样多的视图来展示数据\N{\ren}not creating as many views as we need to\Ndisplay that data
Dialogue: 0,0:02:08.56,0:02:12.23,ch,,0,0,0,,作为替代,使用一种叫做 回收->绑定 的过程\N{\ren}but instead, using a process called\Nrecycling of rebinding
Dialogue: 0,0:02:12.23,0:02:17.04,ch,,0,0,0,,来将用户需要看到的数据绑定到各个视图之上\N{\ren}of data to individual views as the\Nuser needs to see them
Dialogue: 0,0:02:17.04,0:02:21.34,ch,,0,0,0,,可以这么讲,\N{\ren}so basically like we've got going here\Nwe have this idea that
Dialogue: 0,0:02:21.34,0:02:25.28,ch,,0,0,0,,显示用户数据集的视图的个数\N{\ren}the number reviews necessary to show the\Nuser their collection
Dialogue: 0,0:02:25.28,0:02:28.47,ch,,0,0,0,,只等于我们屏幕上能显示出的视图的个数\N{\ren}is only what we need to be able to show\Non screen
Dialogue: 0,0:02:28.47,0:02:33.34,ch,,0,0,0,,一旦用户开始跟他的数据集交互,不管是上划\N{\ren}and as the user is interacting with this\Ncontent whether there's scrolling up
Dialogue: 0,0:02:33.34,0:02:34.26,ch,,0,0,0,,还是怎么划\N{\ren}around
Dialogue: 0,0:02:34.26,0:02:38.76,ch,,0,0,0,,只要视图被划出屏幕,这个视图就不需要了.但是\N{\ren}as view scroll off-screen they're no\Nlonger necessary but rather than
Dialogue: 0,0:02:38.76,0:02:41.65,ch,,0,0,0,,对于将要到来的新的数据,不采用创建一个新视图的方式\N{\ren}creating new views for the new data\Ncoming in
Dialogue: 0,0:02:41.65,0:02:45.45,ch,,0,0,0,,而是把这个旧的视图重新填充数据\N{\ren}we can simply take the old views\Nrepurpose them with new data
Dialogue: 0,0:02:45.45,0:02:48.65,ch,,0,0,0,,平移其到一个新位置,然后让它划入屏幕即可\N{\ren}shift them to a new location and allow\Nthem to slide back n
Dialogue: 0,0:02:48.65,0:02:52.12,ch,,0,0,0,,因此,用这种办法,才使得我们能够展示成百上千的数据项\N{\ren}so that way we can display hundreds of\Nthousands of items
Dialogue: 0,0:02:52.12,0:02:55.73,ch,,0,0,0,,仅仅使用有限的几个视图.大体上,\N{\ren}with only a handful of views. generally\Nyou're gonna see you
Dialogue: 0,0:02:55.73,0:03:00.96,ch,,0,0,0,,你会发现RecyclerView和ListView需要创建的视图个数\N{\ren}recycler views or list views creating as\Nmany viewers as necessary to display on
Dialogue: 0,0:03:00.96,0:03:03.23,ch,,0,0,0,,会比展示在屏幕上的视图的个数多一两个\N{\ren}screen plus maybe one or two more
Dialogue: 0,0:03:03.23,0:03:07.34,ch,,0,0,0,,这跟采用的算法有关.\N{\ren}depending on how the algorithm works\Nokay
Dialogue: 0,0:03:07.34,0:03:11.70,ch,,0,0,0,,再重申一次,我不会讲太多如何使用RecyclerView\N{\ren}so again I'm not gonna talk too much\Nabout how to use recycler view I think
Dialogue: 0,0:03:11.70,0:03:13.64,ch,,0,0,0,,这方面有很好的文档\N{\ren}there's some good documentation on that\Nbut
Dialogue: 0,0:03:13.64,0:03:17.65,ch,,0,0,0,,RecyclerView的精华在于\N{\ren}the basics have recycler view is that\Nrecycler view is a
Dialogue: 0,0:03:17.65,0:03:21.34,ch,,0,0,0,,RecyclerView是对这种机制的革新,更加灵活易用\N{\ren}more flexible,evolution of this\Npattern
Dialogue: 0,0:03:21.34,0:03:25.93,ch,,0,0,0,,其允许我们来对可复用的集合创建\N{\ren}that allows us to create these\Nrecyclable collections in
Dialogue: 0,0:03:25.93,0:03:30.60,ch,,0,0,0,,各种自定义(布局,动画,装饰)的实现.之前,我们只有ListView\N{\ren}all kinds of custom implementations you\Nknow previously we only had list view
Dialogue: 0,0:03:30.60,0:03:32.39,ch,,0,0,0,,是一个可在垂直方向上滚动的列表\N{\ren}which was a vertical scrolling list
Dialogue: 0,0:03:32.39,0:03:35.81,ch,,0,0,0,,开发者们已经为其做过一些自定制的实现了\N{\ren}there have been some custom\Nimplementations done by other developers
Dialogue: 0,0:03:35.81,0:03:38.95,ch,,0,0,0,,比方说水平滚动的列表.等等其他定制的效果\N{\ren} ways to do this maybe horizontally\Nor another custom ways
Dialogue: 0,0:03:38.95,0:03:43.48,ch,,0,0,0,,RecyclerView为之前大家所需要的实现提供了一个框架\N{\ren}recyclerView bring that all together\Ninto a framework so because it that
Dialogue: 0,0:03:43.48,0:03:45.84,ch,,0,0,0,,因此,要想使用RecyclerView\N{\ren}recycler you cannot be used
Dialogue: 0,0:03:45.84,0:03:49.87,ch,,0,0,0,,你必须要提供一个布局管理器不可.这俩必须成对使用,不然\N{\ren}without a layout manager.the two always\Nhave to pair together in fact if you try
Dialogue: 0,0:03:49.87,0:03:52.65,ch,,0,0,0,,当你尝试实例化一个没有定义布局管理器的RecyclerView时\N{\ren}to instantiate a RecyclerView without\Na layup manager
Dialogue: 0,0:03:52.65,0:03:56.60,ch,,0,0,0,,你会得到一个没有用的异常,会让你的程序崩溃\N{\ren}you'll get a very unhelpful exception about\Nthat will crash your application
Dialogue: 0,0:03:56.60,0:04:01.24,ch,,0,0,0,,所以,用RecyclerView之前,咱一定要有布局管理器\N{\ren}OK.so you always need to set a layout\Nmanager before you try to use a recycler
Dialogue: 0,0:04:01.24,0:04:02.06,ch,,0,0,0,,\N{\ren}view
Dialogue: 0,0:04:02.06,0:04:06.13,ch,,0,0,0,,为了使你能登堂入室,或者说为了便于应对最常用的场合\N{\ren}and to sort of get you started or cover\Nmost use cases
Dialogue: 0,0:04:06.13,0:04:09.51,ch,,0,0,0,,框架在这方面干的很不错.为我们提供了\N{\ren}the framework has done a pretty good job\Nof providing
Dialogue: 0,0:04:09.51,0:04:14.17,ch,,0,0,0,,几个自带的布局管理器.在大多数情况下,你甚至有可能\N{\ren}a handful of its own layout managers that\Nin a lot cases you might even be able
Dialogue: 0,0:04:14.17,0:04:15.54,ch,,0,0,0,,都用得上\N{\ren}to use wholesale
Dialogue: 0,0:04:15.54,0:04:19.51,ch,,0,0,0,,如果你从Lpreview或者从RecyclerView最初版本发布以来\N{\ren}and if you haven't looked at recycler\Nview since the L reviewer or maybe since
Dialogue: 0,0:04:19.51,0:04:20.93,ch,,0,0,0,,你一直都没有再看RecyclerView的话\N{\ren}some of the initial releases
Dialogue: 0,0:04:20.93,0:04:23.97,ch,,0,0,0,,你可能会漏掉几个他们目前已经加进去的布局管理器\N{\ren}you may have missed some of the layout\Nmanagers they've added
Dialogue: 0,0:04:23.97,0:04:25.87,ch,,0,0,0,,因为,预览版的时候,我们手里的RecyclerView\N{\ren}because during the preview really all we
Dialogue: 0,0:04:25.87,0:04:29.27,ch,,0,0,0,,所提供的基本功能就跟ListView差不多\N{\ren}had was some basic functionality that\Nwas very similar to ListView and they
Dialogue: 0,0:04:29.27,0:04:31.68,ch,,0,0,0,,但是到正式发布的时候,很多新功能都已经被加进去了.\N{\ren}add it quite a bit by the time they got\Nto release
Dialogue: 0,0:04:31.68,0:04:35.41,ch,,0,0,0,,接下来,我来快速梳理一遍,framework提供了些什么\N{\ren}let's just quickly go through what the\Nframework gives us the first
Dialogue: 0,0:04:35.41,0:04:39.13,ch,,0,0,0,,首先,是大家都很熟悉的\N{\ren}option which will.familiar to\Nprobably most of you
Dialogue: 0,0:04:39.13,0:04:42.72,ch,,0,0,0,,LinearLayoutManager.\N{\ren}is the linear layout manager so the\NLinearLayout manager
Dialogue: 0,0:04:42.72,0:04:46.40,ch,,0,0,0,,你基本可以把它当成ListView的替代品\N{\ren}is essentially the ListView replacement\Nif you well
Dialogue: 0,0:04:46.40,0:04:49.66,ch,,0,0,0,,尽管它还有些其他的特性,但是基本上它是\N{\ren}I it's got some additional features in\Nit but is it is a
Dialogue: 0,0:04:49.66,0:04:53.72,ch,,0,0,0,,一个列表项均分的单一列表.LinearLayoutManager有个\N{\ren}uniform single list of items.one of the\Nneat features
Dialogue: 0,0:04:53.72,0:04:57.18,ch,,0,0,0,,ListView没有的特性.那就是对方向参数的可选性\N{\ren}of linear layout manager that we\Ndidn't have in listview is the optional
Dialogue: 0,0:04:57.18,0:04:58.50,ch,,0,0,0,,那就是对方向参数的可选性\N{\ren}orientation setup
Dialogue: 0,0:04:58.50,0:05:03.63,ch,,0,0,0,,因此LinearLayoutManager允许RecyclerView创建可滚动的列表\N{\ren}so LinearLayout Manager allows recycler\Nview to create a list of items that scrolls
Dialogue: 0,0:05:03.63,0:05:08.47,ch,,0,0,0,,不管是垂直的还是水平的.很明显,我们之前\N{\ren}either vertically or horizontally which\Nis a new feature that we obviously
Dialogue: 0,0:05:08.47,0:05:09.76,ch,,0,0,0,,是没有这个特性的.\N{\ren}didn't have before
Dialogue: 0,0:05:09.76,0:05:12.77,ch,,0,0,0,,你只需要在LinearLayoutManager实例化的时候\N{\ren}and this is controlled during the\Ninstantiation of the LinearLayout
Dialogue: 0,0:05:12.77,0:05:17.49,ch,,0,0,0,,指定水平或者垂直的方向参数即可\N{\ren}manager just by giving it that vertical\Nor horizontal orientation qualifier there
Dialogue: 0,0:05:17.49,0:05:22.28,ch,,0,0,0,,这里最后一个boolean型的参数,代表是你是否要逆序进行布局\N{\ren}OK. the boolean parameter that at the end that allows you to also reverse the layout
Dialogue: 0,0:05:22.28,0:05:25.60,ch,,0,0,0,,通常,大家都是把它设为false\N{\ren}so the traditional by setting it to\Nfalse would
Dialogue: 0,0:05:25.60,0:05:29.00,ch,,0,0,0,,那么列表项显示的顺序跟适配器中getView()顺序是一致的\N{\ren}order the items as they viewed in the\Nadapter so
Dialogue: 0,0:05:29.00,0:05:32.15,ch,,0,0,0,,从位置0开始,由高到低依次依序显示列表项\N{\ren}adapter item position $0 upfront down to\Nthe end
Dialogue: 0,0:05:32.15,0:05:35.72,ch,,0,0,0,,如果你把这个参数设成true,那么就成逆序了.\N{\ren}if you set this parameter to true it\Nwill reverse that and have the
Dialogue: 0,0:05:35.72,0:05:39.13,ch,,0,0,0,,列表中最后一项会先显示.因此,从前ListView的这种特性\N{\ren}end of the adapter show first in the\Nlist okay so they have that feature in
Dialogue: 0,0:05:39.13,0:05:39.80,ch,,0,0,0,,在LinearLayoutManager中也存在\N{\ren}there as well
Dialogue: 0,0:05:43.08,0:05:46.22,ch,,0,0,0,,接下来,framework提供给我们的是GridLayoutManager\N{\ren}the next one that we have appears the\Ngrid layout manager
Dialogue: 0,0:05:46.22,0:05:51.03,ch,,0,0,0,,这个布局管理器在L预览版中是没有的,但是其功能性\N{\ren}so this is...this one was not in the\Npreview but functionality have it is
Dialogue: 0,0:05:51.03,0:05:56.16,ch,,0,0,0,,我们却不陌生.因为我们都知道GridView\N{\ren}still pretty intuitive to most of us because\Nwe've either seen or used gridview before
Dialogue: 0,0:05:56.16,0:05:59.21,ch,,0,0,0,,当然,这里的布局管理器更加灵活一点.它的特点是,\N{\ren}at a little bit more flexible than that\Nbut the idea here is that
Dialogue: 0,0:05:59.21,0:06:02.47,ch,,0,0,0,,大体上,我们仍有着均分的网格布局列表项集合\N{\ren}we're still having this uniform\Ncollection of items
Dialogue: 0,0:06:02.47,0:06:06.56,ch,,0,0,0,,但是这些列表项,现在可以一个挨着一个填满一行后,\N{\ren}but these items can now be stacked up\Nuh you know, either side by side on
Dialogue: 0,0:06:06.56,0:06:07.53,ch,,0,0,0,,再竖着往上填(- -!)\N{\ren}top of each other
Dialogue: 0,0:06:07.53,0:06:11.91,ch,,0,0,0,,像LinearLayoutManager一样,GridLayoutManager也提供\N{\ren}uh, just like with linear layout manager\Ngrid layout manager does support
Dialogue: 0,0:06:11.91,0:06:15.68,ch,,0,0,0,,方向参数,因此我们可以像之前一样,做个垂直的可滚动列表\N{\ren}orientation changes so we can do a\Nvertical scrolling list
Dialogue: 0,0:06:15.68,0:06:20.97,ch,,0,0,0,,也可以做一个水平的可滚动网格列表\N{\ren}like the traditional grid view or we can\Nflip that into a horizontally scrolling grid
Dialogue: 0,0:06:20.97,0:06:25.05,ch,,0,0,0,,这里位于参数列表中的数字代表着\N{\ren}instead now the the number that you see\Nin this
Dialogue: 0,0:06:25.05,0:06:28.91,ch,,0,0,0,,GridLayoutManager所提供的一种控制参数\N{\ren}declaration here is that the the grid\Nlayout manager supports
Dialogue: 0,0:06:28.91,0:06:33.22,ch,,0,0,0,,这个参数决定了每行item所能占用的最大span数\N{\ren}controlling how many what they call\Nspans are associated with that
Dialogue: 0,0:06:33.22,0:06:34.26,ch,,0,0,0,,每个数据项都有着相关的span数\N{\ren}particular item
Dialogue: 0,0:06:34.26,0:06:37.88,ch,,0,0,0,,这里把这个参数称作span而不是行或列的原因在于\N{\ren}now the reason they call them spans\Ninstead of rows or columns is because
Dialogue: 0,0:06:37.88,0:06:39.00,ch,,0,0,0,,GridLayoutManager有着两种方向\N{\ren}the fact that you can do it
Dialogue: 0,0:06:39.00,0:06:42.41,ch,,0,0,0,,简单的讲,span定义了\N{\ren}in either direction so a span just simply\Ndefines
Dialogue: 0,0:06:42.41,0:06:46.61,ch,,0,0,0,,你能够在某一维度上堆栈起来的item数,纵表即为列数\N{\ren}how many items you can stack up so in a\Nvertical grid the spans are the columns
Dialogue: 0,0:06:46.61,0:06:49.03,ch,,0,0,0,,横表即为行数\N{\ren}in a horizontal grid the span to be the\NRose
Dialogue: 0,0:06:49.03,0:06:53.05,ch,,0,0,0,,除此之外,span还\N{\ren}OK but they're still defined in such a\Nway that they are uniform so
Dialogue: 0,0:06:53.05,0:06:56.47,ch,,0,0,0,,仍旧体现其均匀的特性.举例来讲,在这我定义了2个span\N{\ren}for instance in this case I have two\Nspans defined so
Dialogue: 0,0:06:56.47,0:07:01.03,ch,,0,0,0,,这里每行就被均分成了两部分来给列表项占用.仅用span\N{\ren}they will evenly be spaced on both sides\Nthere's not really a mechanism to define
Dialogue: 0,0:07:01.03,0:07:04.24,ch,,0,0,0,,是无法将每行不均等分的(左边占1/3 右边占2/3).\N{\ren}you know sort of a 1/3 2/3 with the\Nspans
Dialogue: 0,0:07:04.24,0:07:09.30,ch,,0,0,0,,你一定是在这个控制水准啦,懂么?但是别怕,有哥在呢.\N{\ren}you're necessarily at this level ok\Nthey did at a
Dialogue: 0,0:07:09.30,0:07:13.08,ch,,0,0,0,,系统的确提供了一个相当有意思的特性,\N来让你对均等性进行改变\N{\ren}fairly interesting feature though that\Nallows you to change the uniformity
Dialogue: 0,0:07:13.08,0:07:16.86,ch,,0,0,0,,这显然比传参数复杂一点,我们要用SpanSizeLook\N{\ren}in in some basic ways using something\Ncalled a span size lookup
Dialogue: 0,0:07:16.86,0:07:21.33,ch,,0,0,0,,我这里的例子中,GridLayoutManager的span依然\N{\ren}so in the example that I have here the\Ngrid layout manager still has
Dialogue: 0,0:07:21.33,0:07:25.74,ch,,0,0,0,,被设置为2,但是我们自定义了SpanSizeLookUp的实现\N{\ren}two spans defined but using this custom\Nimplementation of
Dialogue: 0,0:07:25.74,0:07:29.49,ch,,0,0,0,,我们在运行时为\N{\ren}a span size lookup we can define at\Nruntime for
Dialogue: 0,0:07:29.49,0:07:32.86,ch,,0,0,0,,每个位置来设置其占用span的个数\N{\ren}each individual position how many spans
Dialogue: 0,0:07:32.86,0:07:36.95,ch,,0,0,0,,我这的方法挺简单\N{\ren}should each item take up and this is a\Nvery simple algorithm basically says
Dialogue: 0,0:07:36.95,0:07:39.14,ch,,0,0,0,,每个3的倍数的列表项都会占用2个span\N{\ren}every third item should take two spans
Dialogue: 0,0:07:39.14,0:07:42.30,ch,,0,0,0,,而其他的就还按默认的,只占用一个\N{\ren}and all the other should take just the\Ndefault 1
Dialogue: 0,0:07:42.30,0:07:45.39,ch,,0,0,0,,这里,大家所看到的,就是这种实现的效果\N{\ren}and this gives us the implementation\Nthat we see up here
Dialogue: 0,0:07:45.39,0:07:48.58,ch,,0,0,0,,这样网格就被整行分割了\N{\ren}where every other row is essentially\Nlaid out
Dialogue: 0,0:07:48.58,0:07:51.93,ch,,0,0,0,,这样网格就被整行分割了\N{\ren}all the way across but the grids\Ninterspersed in between
Dialogue: 0,0:07:51.93,0:07:55.27,ch,,0,0,0,,因此你可以在GridLayoutManager里创建一些变形的元素\N{\ren}so you can create some shifting elements\Nhere
Dialogue: 0,0:07:55.27,0:07:58.88,ch,,0,0,0,,但是这必须被定义在可用的span数之上\N{\ren}but this is always defined in terms of\Nthe number of spans available
Dialogue: 0,0:07:58.88,0:08:03.70,ch,,0,0,0,,因此,这不像明显的像素宽度或其他测量参数\N{\ren}so this isn't like a an explicit pixel\Nwidth or anything like that you define
Dialogue: 0,0:08:03.70,0:08:05.80,ch,,0,0,0,,你必须提前定义好在你的布局中要用到的span数\N{\ren}ahead a time how many spans are\Navailable
Dialogue: 0,0:08:05.80,0:08:09.89,ch,,0,0,0,,然后,你可以用LookUp来决定\N{\ren}in this layout and then you can use the\Nlookup to basically tell it how many of
Dialogue: 0,0:08:09.89,0:08:11.93,ch,,0,0,0,,(在桌子上占用的单元数)\N{\ren}those you think of them as the cells in a\Ntable
Dialogue: 0,0:08:11.93,0:08:16.44,ch,,0,0,0,,这个特定的item所应该占用的单元数\N{\ren}this specific item should take up at I
Dialogue: 0,0:08:16.44,0:08:20.49,ch,,0,0,0,,关于GridLayoutManager还有件事你不能忘\N{\ren}it one of the important things to\Nrealize with grid layout though is that the
Dialogue: 0,0:08:20.49,0:08:23.52,ch,,0,0,0,,不论其使用何种的方向.其表项的高度\N{\ren}whatever orientation it's in,the item\Nheight:
Dialogue: 0,0:08:23.52,0:08:27.93,ch,,0,0,0,,亦或其表项的宽度(水平方向),在每个表项\N{\ren}or for towards on all the item with\Nstill needs to be uniform for
Dialogue: 0,0:08:27.93,0:08:31.24,ch,,0,0,0,,所占的块中必须是均等的.在我们这个例子中,\N{\ren}each element block so for instance in\Nthis example
Dialogue: 0,0:08:31.24,0:08:34.70,ch,,0,0,0,,每一行中的item的高度必须是一样的\N{\ren}all the items in the same row have to be\Nthe same height
Dialogue: 0,0:08:34.70,0:08:37.77,ch,,0,0,0,,行高取决于\N{\ren}and the the row height itself will
Dialogue: 0,0:08:37.77,0:08:40.82,ch,,0,0,0,,最高的列表项的高度\N{\ren}essentially adjust to whatever the\Ntallest item is
Dialogue: 0,0:08:40.82,0:08:44.29,ch,,0,0,0,,因此,如果我在一行中间的元素比两边的元素高\N{\ren}so if I had one item in the middle of the\Nother two that was much taller
Dialogue: 0,0:08:44.29,0:08:47.31,ch,,0,0,0,,那么两边的元素下面就会有留白\N{\ren}there would be a gap underneath the two\Nitems on either side
Dialogue: 0,0:08:47.31,0:08:50.97,ch,,0,0,0,,位于其下面的元素并不会滑上去填充空隙\N{\ren}they don't slide up to sort of fill in\Nthe gaps or anything like that
Dialogue: 0,0:08:50.97,0:08:52.54,ch,,0,0,0,,而你恰好正是为了这种目的\N{\ren}for that
Dialogue: 0,0:08:52.54,0:08:55.30,ch,,0,0,0,,别怕,我们还有StaggeredGridLayoutManager.\N{\ren}we have the staggered grid layout\Nmanager
Dialogue: 0,0:08:55.30,0:08:59.58,ch,,0,0,0,,因此,SGLM正是构建在这种模式之上的\N{\ren}so the staggered grid layout manager\Nbuild on that pattern
Dialogue: 0,0:08:59.58,0:09:04.36,ch,,0,0,0,,其被构造的方法和布局的操作都跟GLM相似\N{\ren}and operates and is constructed in a\Nvery similar way to grid layout manager
Dialogue: 0,0:09:04.36,0:09:07.67,ch,,0,0,0,,不同的是,我们有机会去为表项视图定义\N{\ren}but in this case we have the opportunity\Nto define
Dialogue: 0,0:09:07.67,0:09:12.73,ch,,0,0,0,,不同的大小.然后SGLM会把将其布局出来\N{\ren}different size item views and the\Nstaggered grid layout manager will simply lay them out
Dialogue: 0,0:09:12.73,0:09:17.12,ch,,0,0,0,,并尽其所能的将留白用item填充起来.\N{\ren}as best it knows how underneath each\Nother filling in those individual gaps
Dialogue: 0,0:09:17.12,0:09:20.13,ch,,0,0,0,,对我们的实现来讲\N{\ren}OK the from an implementation perspective
Dialogue: 0,0:09:20.13,0:09:24.87,ch,,0,0,0,,创建这个布局管理器跟创建前面两个一样\N{\ren}creating one is again no different then\Nworking with the other two and it
Dialogue: 0,0:09:24.87,0:09:28.06,ch,,0,0,0,,这种管理器也同样支持水平和垂直\N{\ren}also supports horizontal and vertical\Norientation
Dialogue: 0,0:09:28.06,0:09:31.13,ch,,0,0,0,,前方依旧高能\N{\ren}now
Dialogue: 0,0:09:31.13,0:09:35.45,ch,,0,0,0,,有件事要注意,我刚刚所展示给你们的每一种布局管理器\N{\ren}one of the things to notice\Nabout each of these that I've shown you
Dialogue: 0,0:09:35.45,0:09:40.55,ch,,0,0,0,,它们都支持不同方向的滚动\N{\ren}so far is that well they support\Ndifferent orientations of scrolling
Dialogue: 0,0:09:40.55,0:09:44.85,ch,,0,0,0,,但是,无论何时这些实现只能支持一条坐标轴上的滚动\N{\ren}both these implementations only supports\Ngrowing in a single axis
Dialogue: 0,0:09:44.85,0:09:48.48,ch,,0,0,0,,我想要做的是\N{\ren}at any given time what what I need to do
Dialogue: 0,0:09:48.48,0:09:53.75,ch,,0,0,0,,创造一种RecyclerView,就说它是个简单的网格布局吧\N{\ren}if I wanted to create a recycler view\Nimplementation or say like a simple grid
Dialogue: 0,0:09:53.75,0:09:57.16,ch,,0,0,0,,我想让它能在两个方向上都能滚动\N{\ren}that I want to be able to actually\Nscroll in two directions
Dialogue: 0,0:09:57.16,0:10:02.00,ch,,0,0,0,,我能这么做么?答案是,你可以的.\N不过在framework里,你找不到现成的\N{\ren}can I do that? well the answer is yes \Nthe framework is not gonna give you anything to do that
Dialogue: 0,0:10:02.00,0:10:05.69,ch,,0,0,0,,这就要靠我们自己动手来创建布局管理器了\N{\ren}in that case we have to look may be perhaps building our own
Dialogue: 0,0:10:05.69,0:10:09.19,ch,,0,0,0,,那么我会向你展示我所干过的活\N{\ren}so what I've done and I'll show you the
Dialogue: 0,0:10:09.19,0:10:12.38,ch,,0,0,0,,在我们会谈结束后,你可以自己去分析源码\N{\ren}where you can look at the example at the end of the talk here
Dialogue: 0,0:10:12.38,0:10:16.22,ch,,0,0,0,,可以说我所做的研究就是现在所谈的问题的核心\N{\ren}is a sort of key study for what what\Nwe're talking about here
Dialogue: 0,0:10:16.22,0:10:19.31,ch,,0,0,0,,首先,经过我全面的分析之后,我决定去创建\N{\ren}I went through and decided I'm gonna\Ncreate a
Dialogue: 0,0:10:19.31,0:10:23.20,ch,,0,0,0,,一个二维的可滚动的布局,这是个简单均分网格布局\N{\ren}two-dimensional scrolling layout this\Njust a simple uniform grid
Dialogue: 0,0:10:23.20,0:10:26.93,ch,,0,0,0,,网格里的元素会一个挨着一个的布局出来,其中元素的位置\N{\ren}OK so the grid is going to be laid out\Nthe positions would basically be the way
Dialogue: 0,0:10:26.93,0:10:28.19,ch,,0,0,0,,就是你在屏幕上所看到的\N{\ren}you see them up there whether
Dialogue: 0,0:10:28.19,0:10:31.79,ch,,0,0,0,,元素的顺序是从左到右,网格的宽度是固定的\N{\ren}they order themselves left to right the\Ngrid with is fixed
Dialogue: 0,0:10:31.79,0:10:35.76,ch,,0,0,0,,因此元素按列数被包裹起来,按行从上往下排\N{\ren}so the number of columns they just wrap around\Nto the next and I'll just line themselves up
Dialogue: 0,0:10:35.76,0:10:40.04,ch,,0,0,0,,这就好像我正在看一个电视预告或者是体育赛事比分\N{\ren}like if I was looking at maybe a TV\Nschedule or sports scores in a grid
Dialogue: 0,0:10:40.04,0:10:40.97,ch,,0,0,0,,或者其他诸如此类的东西\N{\ren}something like that
Dialogue: 0,0:10:40.97,0:10:44.88,ch,,0,0,0,,用户可以随意的上滑下滑左滑右滑斜着划\N{\ren}then the user could simply pan and\Nscroll around
Dialogue: 0,0:10:44.88,0:10:48.88,ch,,0,0,0,,按任意方向滑动去查看网格列表中的内容\N{\ren}this content visually in whatever\Norientation they wanted
Dialogue: 0,0:10:48.88,0:10:52.31,ch,,0,0,0,,我最先给自己提出的问题是\N{\ren}okay and the question essentially I pose\Nto myself was
Dialogue: 0,0:10:52.31,0:10:56.91,ch,,0,0,0,,我能用RecyclerView来干这件事儿么?或者换一个说法\N\N{\ren}can I build this with recycler view and\Ncome out saying on the other side
Dialogue: 0,0:10:56.91,0:11:01.39,ch,,0,0,0,,好吧,想不出来别的说法了.等你听我讲完就该明白了\N{\ren}I'll let you decide when I'm done\Nwhether know that actually words okay
Dialogue: 0,0:11:01.39,0:11:06.47,ch,,0,0,0,,在我阐述你所需的,构建这种RecyclerView的方法之前\N{\ren}before I talk about the mechanisms of\Nwhat you need to do to build this
Dialogue: 0,0:11:06.47,0:11:09.67,ch,,0,0,0,,咱们先来谈谈RecyclerView内部的一些机制\N{\ren}let's discuss a little bit about\Nthe internals
Dialogue: 0,0:11:09.67,0:11:12.74,ch,,0,0,0,,来帮你理解\N{\ren}of RecyclerView you so that you can get\Nsome idea of
Dialogue: 0,0:11:12.74,0:11:16.49,ch,,0,0,0,,文档中你可能遇到过的一些方法的流程梳理\N{\ren}how these pieces that you may see in the\Ndocumentation actually fit together
Dialogue: 0,0:11:16.49,0:11:19.93,ch,,0,0,0,,首先我想讲的是\N{\ren}so the first element that i wanna talk\Nabout in the
Dialogue: 0,0:11:19.93,0:11:23.30,ch,,0,0,0,,RecyclerView给我们的一个核心帮助类\N{\ren}the core utility if you will that\Nrecycler view
Dialogue: 0,0:11:23.30,0:11:26.76,ch,,0,0,0,,这个类体现了回收利用的概念\N{\ren}gives you is this instance for this\Nconcept a recycler
Dialogue: 0,0:11:26.76,0:11:31.23,ch,,0,0,0,,在构建自定义布局管理器的时候,这个类干的活挺多的\N{\ren}this is really the workhorse of\Nbuilding a custom layout the recycler
Dialogue: 0,0:11:31.23,0:11:34.32,ch,,0,0,0,,回收器(recycler)是RecyclerView传递给你的\N{\ren}is a utility given to you by a recycler\Nview
Dialogue: 0,0:11:34.32,0:11:37.95,ch,,0,0,0,,它为你干了几乎所有的\N{\ren}that does all of the work necessary\Nfor
Dialogue: 0,0:11:37.95,0:11:42.52,ch,,0,0,0,,像获取视图,缓存视图,等等\N{\ren}obtaining views cacheing views your\Nbasically doing all the recycling
Dialogue: 0,0:11:42.52,0:11:44.20,ch,,0,0,0,,所有跟回收相关的活\N{\ren}functionality that you need
Dialogue: 0,0:11:44.20,0:11:48.48,ch,,0,0,0,,它让你能够快速的获取一个新视图来填充新数据.\N以及快速丢弃\N{\ren}to be able to quickly get new views for\Nnew data and toss away views you don't
Dialogue: 0,0:11:48.48,0:11:49.42,ch,,0,0,0,,你不再需要的视图\N{\ren}need anymore
Dialogue: 0,0:11:49.42,0:11:53.35,ch,,0,0,0,,因此,当你开始构建一个布局管理器时,\N{\ren}OK so when you're building a layout\Nmanager your interaction is almost
Dialogue: 0,0:11:53.35,0:11:54.54,ch,,0,0,0,,你的交互行为跟\N{\ren}exclusively
Dialogue: 0,0:11:54.54,0:11:58.64,ch,,0,0,0,,recycler息息相关.比方说,当你需要一个新的视图时\N{\ren}with the recycler there you know when\Nwhen you need a new view
Dialogue: 0,0:11:58.64,0:12:02.89,ch,,0,0,0,,当用户滑动屏幕到下一个位置时,有新视图进入等等\N{\ren}with the next position the user is\Nscrolling enter a view or something like
Dialogue: 0,0:12:02.89,0:12:05.94,ch,,0,0,0,,新进入的视图就是从recycler中返回的\N{\ren}that you obtain that view from the\Nrecycler
Dialogue: 0,0:12:05.94,0:12:10.18,ch,,0,0,0,,你只要告诉recycler你所需新视图的position\N{\ren}by giving it the position value that you\Nwant so this is the next position I need
Dialogue: 0,0:12:10.18,0:12:14.64,ch,,0,0,0,,那么recycler就会返回一个已经绑定过相关数据的新视图\N{\ren}please give me the view that has all the\Ndata already bound associated with it
Dialogue: 0,0:12:14.64,0:12:18.82,ch,,0,0,0,,类似地,当你的滑动一些视图移出屏幕时,\N{\ren}and similarly when you're done with a\Nview but say it scrolls of screen and
Dialogue: 0,0:12:18.82,0:12:20.00,ch,,0,0,0,,这些视图你已经不再需要了\N{\ren}you don't need it anymore
Dialogue: 0,0:12:20.00,0:12:23.39,ch,,0,0,0,,你应该把这些视图丢给recycler,以便于\N{\ren}you would toss that back to the recycler\Nso that it can
Dialogue: 0,0:12:23.39,0:12:27.64,ch,,0,0,0,,将来使用的时候还能从recycler中获取到,\N并且获取到的是已经绑定好数据的\N{\ren}keep access to that around and rebind it\Nto some other data later and headed back
Dialogue: 0,0:12:27.64,0:12:28.77,ch,,0,0,0,,(同上)\N{\ren}to another point
Dialogue: 0,0:12:28.77,0:12:34.11,ch,,0,0,0,,所有的这些工作都在recycler内部完成.\N{\ren}okay so all that functionality is bound\Ninside the recycler in the recyclers job
Dialogue: 0,0:12:34.11,0:12:38.61,ch,,0,0,0,,recycler的对外的工作是对接adapter.\N而adapter是你所有数据的来源\N{\ren}is to talk to the adapter so the adapter\Nwere all your data comes from where you
Dialogue: 0,0:12:38.61,0:12:42.00,ch,,0,0,0,,你在adapter里根据数据源创建ViewHolder和绑定数据\N{\ren}you create view holders and bind all the\Ndata that
Dialogue: 0,0:12:42.00,0:12:46.30,ch,,0,0,0,,recycler是可以直接从adapter中\N{\ren}is ... there's a direct interaction\Nbetween the recycler in the adapter to
Dialogue: 0,0:12:46.30,0:12:48.00,ch,,0,0,0,,获取所需信息的\N{\ren}get all that information
Dialogue: 0,0:12:48.00,0:12:52.01,ch,,0,0,0,,但是,布局管理器就不同,你该谨记,布局管理器绝不该\N{\ren}the key point to remember here is your\Nlayout manager should never
Dialogue: 0,0:12:52.01,0:12:55.02,ch,,0,0,0,,去引用适配器\N{\ren}ever ever touch the adapter
Dialogue: 0,0:12:55.02,0:12:59.26,ch,,0,0,0,,因为这个工作是recycler干的.\N当你正在创建一个布局管理器时\N{\ren}that is the recyclers job if you have\Nare building a layout manager that
Dialogue: 0,0:12:59.26,0:13:02.57,ch,,0,0,0,,出于某种原因,你非要获取一些状态信息的话或者\N一些其他跟列表项相关的数据时\N{\ren}somehow you was trying to get state\Ninformation or some other data directly
Dialogue: 0,0:13:02.57,0:13:03.88,ch,,0,0,0,,(从适配器中)\N{\ren}from the adapter
Dialogue: 0,0:13:03.88,0:13:07.83,ch,,0,0,0,,你会把事情搞砸.然而,对于状态信息的存取,\N其实用ViewHolder才最合适不过\N{\ren}that pattern is broken instead the view\Nholders
Dialogue: 0,0:13:07.83,0:13:11.30,ch,,0,0,0,,在RecyclerViewAPI里,ViewHolder被强制传递给你\N{\ren}that are basically forced down your\Nthroat by the recycler view API
Dialogue: 0,0:13:11.30,0:13:15.15,ch,,0,0,0,,它才是你存取状态的最佳选择.因为\N{\ren}those are great places to hold that\Nstate because the adapter
Dialogue: 0,0:13:15.15,0:13:18.53,ch,,0,0,0,,不光适配器可以获取到ViewHolder,布局管理器也能\N{\ren}has access to the view holder and so\Ndoes the layout manager
Dialogue: 0,0:13:18.53,0:13:22.65,ch,,0,0,0,,它俩能获取到VH(ViewHolder)的原因在于,\N中间者recycler在内部也对VH进行了状态信息的存取\N{\ren}and recycler view does this internally\Nyou know, all the information that
Dialogue: 0,0:13:22.65,0:13:24.86,ch,,0,0,0,,每个位置上的视图都应该知道其相关的状态信息\N{\ren}view knows about its current position
Dialogue: 0,0:13:24.86,0:13:28.66,ch,,0,0,0,,这些状态信息包含其是否正在被改变,是否被删除或添加\N{\ren}whether it's are changing weather is\Nbeing added removed all these things that
Dialogue: 0,0:13:28.66,0:13:31.84,ch,,0,0,0,,当RecyclerView对所管理的视图进行好看的动画时,\N{\ren}recycler view uses for these fancy\Ntransition animations
Dialogue: 0,0:13:31.84,0:13:36.47,ch,,0,0,0,,这些状态信息都是从ViewHolder中存取的.\N你可以继承ViewHolder来对自定义的状态信息进行存取\N{\ren}that state is all held on the beholder\Nand you can extend that the holder which
Dialogue: 0,0:13:36.47,0:13:40.11,ch,,0,0,0,,当然,当你构建自己适配器,系统也要求你这么做.\N{\ren}your obviously supposed to when you\Nbuild your own adapter so if you wanna
Dialogue: 0,0:13:40.11,0:13:42.80,ch,,0,0,0,,因此,当你需要为每个视图设置一些状态信息的话\N{\ren}stuff more state in there for each\Nindividual view
Dialogue: 0,0:13:42.80,0:13:46.70,ch,,0,0,0,,正确的做法就是继承ViewHolder来干这事儿.\N因为视图会携带着这些信息\N{\ren}that's the right way to do that and then\Nthat will transport along with the views
Dialogue: 0,0:13:46.70,0:13:49.86,ch,,0,0,0,,当其被传递到布局管理器中时.\N{\ren}as they move into the layout manager and\Nand so on and so forth
Dialogue: 0,0:13:49.86,0:13:52.99,ch,,0,0,0,,因此牢记,布局管理器只对接回收器,不对接适配器\N{\ren}so always touch the recycler never touch\Nthe adapter
Dialogue: 0,0:13:55.40,0:13:58.81,ch,,0,0,0,,接下来,咱们对recycler的讨论要再深入一点\N{\ren}alright so let's look a little bit\Ndeeper into the recycler itself so I
Dialogue: 0,0:13:58.81,0:14:00.10,ch,,0,0,0,,我之前提到的\N{\ren}mention that the recycler
Dialogue: 0,0:14:00.10,0:14:03.95,ch,,0,0,0,,recycler最核心的工作就是其对视图的缓存(回收利用)\N{\ren}is a it's a caching mechanism above all\Nelse
Dialogue: 0,0:14:03.95,0:14:08.15,ch,,0,0,0,,一方面,你要从recycler中获取新视图\N{\ren}so the recycler is where you need to get\Nnew views
Dialogue: 0,0:14:08.15,0:14:11.09,ch,,0,0,0,,另一方面,你还要把废弃视图丢给recycler,但结果是,\N{\ren}and you need to toss away your old views\Nbut it turns out that they actually have
Dialogue: 0,0:14:11.09,0:14:13.06,ch,,0,0,0,,recycler里面竟有两种级别的机制\N{\ren}a two-level mechanism inside
Dialogue: 0,0:14:13.06,0:14:17.28,ch,,0,0,0,,来干这两件事情.recycler中有个叫废料堆的概念\N{\ren}to make this work the recycler has this\Nconcept of what they call the scrap heap
Dialogue: 0,0:14:17.28,0:14:21.52,ch,,0,0,0,,它底层还有个叫回收池的东西\N{\ren}and then underneath that is this idea of\Nthe recycle poor
Dialogue: 0,0:14:21.52,0:14:26.29,ch,,0,0,0,,这两者之间的差别是很微小的.在多数情况下其影响\N{\ren}now the the difference between them is\Nfairly nuanced and in a lot cases it doesn't
Dialogue: 0,0:14:26.29,0:14:30.05,ch,,0,0,0,,可以忽略不计.不过,如果你致力于获取最佳性能时\N{\ren}really matter but there are some\Noptimizations that can be made if you
Dialogue: 0,0:14:30.05,0:14:31.33,ch,,0,0,0,,了解这种微小差别就很有必要了\N{\ren}understand the difference
Dialogue: 0,0:14:31.33,0:14:35.88,ch,,0,0,0,,这里的ScrapHeap就像是第一道防线,\N{\ren}the the scrap heap is usually the the\Nfirst line of defense where you would
Dialogue: 0,0:14:35.88,0:14:37.35,ch,,0,0,0,,当你在Layout的时候\N{\ren}typically toss views
Dialogue: 0,0:14:37.35,0:14:41.79,ch,,0,0,0,,通常会把视图先丢到那里面去.难理解,没关系.先听着.\N{\ren}while you're doing layouts and all I'll\Nexplain to you in sort of a technique how
Dialogue: 0,0:14:41.79,0:14:47.52,ch,,0,0,0,,后面我会配着代码给你讲.\NScrapHeap是一种轻量级的操作\N{\ren}you would possibly use that in your code but the\Nscrap heap is a is a very lightweight place
Dialogue: 0,0:14:47.52,0:14:50.81,ch,,0,0,0,,在它里面检索视图和丢弃视图\N{\ren}where views can be tossed and retrieved\Nback
Dialogue: 0,0:14:50.81,0:14:55.53,ch,,0,0,0,,是以一种很快的方式进行.\N甚至从中获取的视图都不用再重新绑定数据\N{\ren}in a in a very quick fashion often cases\Nwithout even having to rebind the data
Dialogue: 0,0:14:55.53,0:14:58.92,ch,,0,0,0,,作为一个布局管理器,是很适合用这种结构来存取视图的\N{\ren}so it it's a nice place that as a layout\Nmanager
Dialogue: 0,0:14:58.92,0:15:02.24,ch,,0,0,0,,你可以把一些暂时不想用的视图先丢给ScrapHeap\N{\ren}you can toss a bunch of views that you\Nknow you're going to reuse again
Dialogue: 0,0:15:02.24,0:15:05.78,ch,,0,0,0,,注意这些视图还是可见的,然后也许在你对整个列表视图\N采用一些转换操作后,再让那些被丢弃的视图回来时\N{\ren}they're still on screen but maybe you\Nneed to shift them around or something
Dialogue: 0,0:15:05.78,0:15:09.56,ch,,0,0,0,,这时,这些回来的视图可以不走适配器(重新生成,绑定数据)这条路\N{\ren}like that and rather than them having to\Ngo back to the adapter to rebind data
Dialogue: 0,0:15:09.56,0:15:10.80,ch,,0,0,0,,传回给你,而是\N{\ren}and bring them back to you
Dialogue: 0,0:15:10.80,0:15:13.85,ch,,0,0,0,,你可以直接从ScrapHeap中拿到你之前丢弃给它的视图\N{\ren}you can just quickly get them back\Nfrom the scrap heap
Dialogue: 0,0:15:13.85,0:15:17.82,ch,,0,0,0,,再然后,你再对这些视图进行一下布局,\N那么你对列表的转换操作就算完美的结束了\N因此,通常,咱都是先用ScrapHeap来丢掉视图的.\N{\ren}and lay them out again,so typically\Nyou'll toss things in the scrap heap
Dialogue: 0,0:15:17.82,0:15:23.42,ch,,0,0,0,,不过如果你确定某些视图你永远都不用了的话,\N那么就该RecyclerPool派上用场了\N{\ren}first the recycle pool is more commonly\Nused for views you are certain you don't
Dialogue: 0,0:15:23.42,0:15:24.20,ch,,0,0,0,,(同上)\N{\ren}need anymore
Dialogue: 0,0:15:24.20,0:15:28.36,ch,,0,0,0,,比方说,当你运行了一次Layout之后,你可能有一些\N{\ren}so for instance after you've run a\Nlayout maybe you have a handful of
Dialogue: 0,0:15:28.36,0:15:30.73,ch,,0,0,0,,视图滑出了屏幕,以及你知道\N{\ren}views that have scrolled off screen and\Nyou didn't
Dialogue: 0,0:15:30.73,0:15:34.38,ch,,0,0,0,,你不想再使用这些视图了.\N那么你就可以把这些视图扔给RecyclerPo\N{\ren}you didn't need these and you know that\Nyou can toss those into the recycle poor
Dialogue: 0,0:15:34.38,0:15:39.24,ch,,0,0,0,,RecyclerPool依然可以被认为,你能从中快速获取视图\N{\ren}the recycle pool is still a quick way\Nof allowing you to get data back
Dialogue: 0,0:15:39.24,0:15:42.50,ch,,0,0,0,,但是,你所获取到的视图的一些meta-data会丢失\N{\ren}but it tosses away some of the\Nadditional meta-data
Dialogue: 0,0:15:42.50,0:15:46.33,ch,,0,0,0,,它仅仅对ViewHolder以及里面的itemView进行一下缓存\N{\ren}basically recycles the view holder and\Nkeeps the view around so
Dialogue: 0,0:15:46.33,0:15:50.24,ch,,0,0,0,,尽管你知道它可以快速的从适配器中重新绑定数据\N{\ren}even know it can quickly rebind data\Nfrom the adapter its a little bit more
Dialogue: 0,0:15:50.24,0:15:53.42,ch,,0,0,0,,但是如果你对每个视图都这么操作的话,代价就有点高了\N{\ren}expensive if you're constantly doing\Nthat for every single view
Dialogue: 0,0:15:53.42,0:15:57.04,ch,,0,0,0,,所以,通常你是把确定不会再在回收器中使用的视图\N{\ren}so typically you would wanna throw views\Nyou know you don't need in recycle into
Dialogue: 0,0:15:57.04,0:15:57.93,ch,,0,0,0,,丢给RecyclePool\N{\ren}the recycle poor
Dialogue: 0,0:15:57.93,0:16:01.98,ch,,0,0,0,,其他的那就是都扔给ScrapHeap.我会给你展示\N{\ren}toss everything else in this Scrap Heap\Nand I'll show you a technique that kind of
Dialogue: 0,0:16:01.98,0:16:02.97,ch,,0,0,0,,如何具体地去干这些事\N{\ren}allows you to do this
Dialogue: 0,0:16:02.97,0:16:07.20,ch,,0,0,0,,分别针对这两种级别.接下来,我要讲解的概念是\N{\ren}on on two different levels.the other\Nconcepts that
Dialogue: 0,0:16:07.20,0:16:10.36,ch,,0,0,0,,detachment和removal的区别\N{\ren}we were illustrating here is the\Ndifference between a detachment and a
Dialogue: 0,0:16:10.36,0:16:11.16,ch,,0,0,0,,(同上)\N{\ren}removal
Dialogue: 0,0:16:11.16,0:16:15.30,ch,,0,0,0,,这里看到的方法都是绑到一起的\N{\ren}in the method that I've got appear\Nthat they look like they're bound
Dialogue: 0,0:16:15.30,0:16:18.36,ch,,0,0,0,,但是你也可以将方法拆分着用\N{\ren}together but you can actually do all\Nthese operations separately you can
Dialogue: 0,0:16:18.36,0:16:19.60,ch,,0,0,0,,attach() 和 detach()\N{\ren}attach and detach
Dialogue: 0,0:16:19.60,0:16:23.14,ch,,0,0,0,,remove() 和 scrap(),所以你可以单个调用,\N绑定在一起只是为了方便\N{\ren}remove scrap you can do those things\Nindividually these are just convenience
Dialogue: 0,0:16:23.14,0:16:23.81,ch,,0,0,0,,(同上)\N{\ren}functions
Dialogue: 0,0:16:23.81,0:16:28.18,ch,,0,0,0,,在我看来,这里的函数命名是有点臭的\N{\ren}that the syntax is a little stinky in my\Nopinion because
Dialogue: 0,0:16:28.18,0:16:32.41,ch,,0,0,0,,因为detach是跟scrap相对应的\N{\ren}detach is really.it's a mechanism\Nsimilar to scrapping
Dialogue: 0,0:16:32.41,0:16:35.54,ch,,0,0,0,,当你把一个视图暂时的丢弃时\N{\ren}that allows you to toss a view away\Ntemporarily
Dialogue: 0,0:16:35.54,0:16:38.70,ch,,0,0,0,,这个视图你知道你会在相同的布局过程中重用\N{\ren}that you know you're going to reuse in\Nthe same layout pass
Dialogue: 0,0:16:38.70,0:16:41.75,ch,,0,0,0,,尽管这里的名字是detach\N{\ren}so the while the name is detach
Dialogue: 0,0:16:41.75,0:16:46.11,ch,,0,0,0,,从专业的角度来看,被detach的视图没有在父视图中被移除\N{\ren}a detached view is not technically\Nremoved from its parent
Dialogue: 0,0:16:46.11,0:16:49.56,ch,,0,0,0,,这里的父视图是指RecyclerView.\N子视图仍被添加在父视图中的\N{\ren}which is the recycler view it's actually\Nstill added to that view
Dialogue: 0,0:16:49.56,0:16:53.12,ch,,0,0,0,,其实布局管理器只允许你对这个视图进行一点操作而已\N{\ren}the layout managers just allowed to\Nmanipulate it a little bit so it's much
Dialogue: 0,0:16:53.12,0:16:54.30,ch,,0,0,0,,因此detach其实是个相当轻量级的操作\N{\ren}more lightweight
Dialogue: 0,0:16:54.30,0:16:57.99,ch,,0,0,0,,矛盾的是虽然名字是detach,但是还是attach着父视图的\N{\ren}I but it is still attached to the parent\Nview
Dialogue: 0,0:16:57.99,0:17:02.57,ch,,0,0,0,,remove操作跟你在ViewGroup中的移除视图操作相似\N{\ren}remove view is very similar to of a\Nview removal you would have on
Dialogue: 0,0:17:02.57,0:17:06.29,ch,,0,0,0,,这里被remove的视图可是的的确确的从其\N{\ren}a view group or anything like that\Nwhere it is actually detached from its
Dialogue: 0,0:17:06.29,0:17:07.25,ch,,0,0,0,,父视图中移除了\N{\ren}parent so it's
Dialogue: 0,0:17:07.25,0:17:10.74,ch,,0,0,0,,这让我不爽的就是remove操作的视图的确是detached,\N但是detach操作的视图却不是的\N{\ren}its little bit difficult cause remove\Nactually detach and detach does not
Dialogue: 0,0:17:10.74,0:17:15.35,ch,,0,0,0,,这里的话,你把detach当成一种轻量级的操作,而remove\N{\ren}but you can really think of it as\Ndetaches the lightweight and remove is
Dialogue: 0,0:17:15.35,0:17:16.07,ch,,0,0,0,,就是一种重量级的操作.这样来理解就比较好了\N{\ren}the heavyweight
Dialogue: 0,0:17:16.07,0:17:19.90,ch,,0,0,0,,通常你会把这两种事情合并在一起来做\N{\ren}so typically in most cases you do these\Nthings together
Dialogue: 0,0:17:19.90,0:17:23.58,ch,,0,0,0,,在recycler中的detachAndScrap方法\N{\ren}so the method on a recycler for detachAndScrap
Dialogue: 0,0:17:23.58,0:17:26.86,ch,,0,0,0,,被用来丢弃可能再次用到的视图\N{\ren}is where you would you would use that\Nto toss views away that you
Dialogue: 0,0:17:26.86,0:17:31.38,ch,,0,0,0,,而removeAndRecycle丢弃掉的视图,\N{\ren}might use again and removeAndRecycler\Nis the one you would use to toss views a
Dialogue: 0,0:17:31.38,0:17:34.85,ch,,0,0,0,,当你下次再从中获取时,可能就不一样了\N{\ren}away that the next time you need it.it's\Nprobably gonna be for different
Dialogue: 0,0:17:34.85,0:17:38.60,ch,,0,0,0,,因此这两个方法被用在不同的场合\N{\ren}different use case or a different mind
Dialogue: 0,0:17:38.60,0:17:40.67,ch,,0,0,0,,一些其他的\N{\ren}okay couple other
Dialogue: 0,0:17:40.67,0:17:43.68,ch,,0,0,0,,小贴士.这些小贴士在自定义布局管理器时肯定用得到\N{\ren}tips just to know when you're building a\Nlayout manager
Dialogue: 0,0:17:43.68,0:17:48.28,ch,,0,0,0,,布局管理器顾名思义,它的作用就是负责measure和layout\N{\ren}layout manager as the name implies is\Nresponsible for measuring and laying out
Dialogue: 0,0:17:48.28,0:17:49.99,ch,,0,0,0,,RecyclerView中每个视图\N{\ren}every view in a recycler view
Dialogue: 0,0:17:49.99,0:17:53.74,ch,,0,0,0,,这个作用跟ViewGroup对待其孩子视图的作用相类似\N{\ren}very similar to the responsibility that\Na container view group has for it
Dialogue: 0,0:17:53.74,0:17:54.52,ch,,0,0,0,,(同上)\N{\ren}child views
Dialogue: 0,0:17:54.52,0:17:58.77,ch,,0,0,0,,但是,RecyclerView还提供了个\N{\ren}however recycler provides this
Dialogue: 0,0:17:58.77,0:18:03.11,ch,,0,0,0,,额外的特性叫Decorations.大家都有谁用过Decoration\N{\ren}additional feature to developers call\Ndecorations how many of you used decorations before
Dialogue: 0,0:18:03.11,0:18:07.71,ch,,0,0,0,,很不错呢,这个特性让你能够\N{\ren}okay pretty good group.they allow you to\Nprovide
Dialogue: 0,0:18:07.71,0:18:12.86,ch,,0,0,0,,做额外的绘制或者做额外的边距间隔\N或者额外的尺寸大小\N{\ren}additional drawing or additional margins\Nor sizing requirements
Dialogue: 0,0:18:12.86,0:18:17.17,ch,,0,0,0,,在每个单一的列表项之上.例如,有了列表装饰\N{\ren}on individual items so for instance with\Nan item decoration
Dialogue: 0,0:18:17.17,0:18:21.44,ch,,0,0,0,,你不仅能在视图里面定义边距,还能把边距定义在装饰里\N{\ren}I can define not in the item view itself\Nbut in a declaration that
Dialogue: 0,0:18:21.44,0:18:25.16,ch,,0,0,0,,比方说如果你在decoration设置了边距\N{\ren}all of my items should have a margin\Naround them and it just
Dialogue: 0,0:18:25.16,0:18:29.10,ch,,0,0,0,,那么RecyclerView就会把这种设置应用到所有元素之上\N{\ren}recycler view applies that for me I\Ndon't have to do anything with it
Dialogue: 0,0:18:29.10,0:18:32.97,ch,,0,0,0,,而对布局管理器来讲,它不用关心\N{\ren}and that's true on the layout side as well\NI don't have to necessarily know that
Dialogue: 0,0:18:32.97,0:18:34.28,ch,,0,0,0,,当它进行布局的时候\N{\ren}when I lay something out
Dialogue: 0,0:18:34.28,0:18:38.70,ch,,0,0,0,,它不用把视图的边距考虑在内,API已经帮我们算好了\N{\ren}it has a margin and I've inside it the\NAPI handles that part for you
Dialogue: 0,0:18:38.70,0:18:42.37,ch,,0,0,0,,前提是你要在布局的时候使用\N{\ren}but it only handles that part if you lay\Nthem out appropriately using
Dialogue: 0,0:18:42.37,0:18:45.75,ch,,0,0,0,,一组不同的方法,这些方法你可能很熟悉,如果你之前做过\N{\ren}a different set of methods and you might\Nbe familiar with if you've done custom
Dialogue: 0,0:18:45.75,0:18:46.92,ch,,0,0,0,,自定义布局的话\N{\ren}you work in the past
Dialogue: 0,0:18:46.92,0:18:50.15,ch,,0,0,0,,与你之前做自定义布局类似,用view本身的参数来布局\N{\ren}so similarly all the information about\Nthe view
Dialogue: 0,0:18:50.15,0:18:53.30,ch,,0,0,0,,从技术上来说都是错误的\N{\ren}is technically wrong if you ask the view\Nitself
Dialogue: 0,0:18:53.30,0:18:56.67,ch,,0,0,0,,比方说我使用视图的left,right,top,bottom来布局的话\N{\ren}if I asked the view for its information\Nlike it left right top bottom
Dialogue: 0,0:18:56.67,0:18:59.85,ch,,0,0,0,,这样做是错的,因为这些参数并没有把"装饰"考虑在内\N{\ren}those are incorrect because they don't\Naccount for the decoration
Dialogue: 0,0:18:59.85,0:19:03.08,ch,,0,0,0,,作为替代,我们使用的是装饰过的left,right,top,bottom\N{\ren}instead there are decorated left right\Ntop bottom
Dialogue: 0,0:19:03.08,0:19:07.91,ch,,0,0,0,,请使用这些参数来对你的视图进行布局\N{\ren}that will give you the appropriate value\Nmight need while you're laying out other views
Dialogue: 0,0:19:07.91,0:19:11.08,ch,,0,0,0,,例如,我以垂直线性的方式来布局一堆视图时\N{\ren}so for instance if I'm laying out a\Nbunch views in a linear fashion
Dialogue: 0,0:19:11.08,0:19:15.61,ch,,0,0,0,,我会使用被装饰过的top和bottom值来确定前一个\N{\ren}I would use the decorated top and bottom\Nvalues to know where the previous view
Dialogue: 0,0:19:15.61,0:19:19.51,ch,,0,0,0,,视图的位置,以确定下一个视图的布局位置\N{\ren}was so I can lay out the next one in\Nfront of it or something like that
Dialogue: 0,0:19:19.51,0:19:22.83,ch,,0,0,0,,与之相似的,我们还有新的关于获取视图大小的方法\N{\ren}similarly we have method like that for\Nsizing
Dialogue: 0,0:19:22.83,0:19:26.61,ch,,0,0,0,,被装饰过的高度和宽度同样会将视图的边距计算在内\N{\ren}so the decorated height and with will\Naccount for those margins as well
Dialogue: 0,0:19:26.61,0:19:30.37,ch,,0,0,0,,我之前提到过,当你用布局管理器layout你的视图时\N{\ren}and as I mentioned when you're laying out your views
Dialogue: 0,0:19:30.37,0:19:34.64,ch,,0,0,0,,你要确保所用的是管理器中的layout和measure方法\N{\ren}you need to make sure to use the layout\Nand measure methods on the manager
Dialogue: 0,0:19:34.64,0:19:37.67,ch,,0,0,0,,你要去调用子视图自身的measure和layout方法\N{\ren}not calling measure and layout directly\Non the child views
Dialogue: 0,0:19:37.67,0:19:41.67,ch,,0,0,0,,如果你没有这么干的话\N{\ren}okay this will if you don't do these\Nthings
Dialogue: 0,0:19:41.67,0:19:45.23,ch,,0,0,0,,你的实现没有使用decoration的话\N{\ren}and you have an implementation that\Ndoesn't use decoration
Dialogue: 0,0:19:45.23,0:19:49.22,ch,,0,0,0,,那么看起来是没啥问题的.但假如有人对其设置的适配器\N{\ren}it'll look like it's working but as soon\Nas someone brings in an adapter that has
Dialogue: 0,0:19:49.22,0:19:50.11,ch,,0,0,0,,有装饰的话\N{\ren}a decoration
Dialogue: 0,0:19:50.11,0:19:53.23,ch,,0,0,0,,你的布局看起来就会让人困惑了,你可能还不知道为什么\N{\ren}attach to it,all your layouts will be confused you won't know why
Dialogue: 0,0:19:53.23,0:19:56.75,ch,,0,0,0,,所以,只要你坚持使用这些正确的方法在布局中\N{\ren}so as long as you stick to using these\Nmethods in your layouts all the time
Dialogue: 0,0:19:56.78,0:20:00.40,ch,,0,0,0,,那么你的布局管理器就会工作的非常好,\N无论是否有人对其设置Decoration\N{\ren}it'll just work regardless of whether\Nsomebody decorated their content or not
Dialogue: 0,0:20:03.67,0:20:06.79,ch,,0,0,0,,接下来我要讲的是\N{\ren}so the next piece that I wanna talk to you
Dialogue: 0,0:20:06.79,0:20:10.27,ch,,0,0,0,,被我称作为fill技术的概念\N{\ren}about is a concept that I call the "fill" technique
Dialogue: 0,0:20:10.27,0:20:14.32,ch,,0,0,0,,framework中关于视图回收的机制都用到fill这个概念\N{\ren}this is how the framework typically does\Na view recycling they did it this way
Dialogue: 0,0:20:14.32,0:20:16.80,ch,,0,0,0,,不光ListView中有,布局管理器的核心实现\N{\ren}in ListView they do it this way in their\Ncore
Dialogue: 0,0:20:16.80,0:20:19.81,ch,,0,0,0,,也用到了这个重要概念\N{\ren}layout managers as well
Dialogue: 0,0:20:19.81,0:20:24.22,ch,,0,0,0,,fill其实是一个函数,其目的是希望能够帮助你简化\N{\ren}this is a function that hopefully will helpful simplify the concept of
Dialogue: 0,0:20:24.22,0:20:29.64,ch,,0,0,0,,如何去运行一次布局的概念.\N和如何去构建一个布局管理器的概念\N{\ren}how you run a layout and how you sort of build a layout manager,it is all centrally
Dialogue: 0,0:20:29.64,0:20:33.80,ch,,0,0,0,,这两个过程的核心都在于这个被称为fill的概念上.fill其实\N{\ren}focused around this concept called the fill the fill is really just a layout
Dialogue: 0,0:20:33.80,0:20:37.05,ch,,0,0,0,,只是个布局操作.很多操作都被封装进了这一个操作中.\N{\ren}operation but it's all encapsulated into
Dialogue: 0,0:20:37.05,0:20:40.87,ch,,0,0,0,,比如说对当前视图状态进行检查的操作,\N{\ren}this functionality that is able to check for the current state
Dialogue: 0,0:20:40.87,0:20:44.93,ch,,0,0,0,,以及对这些状态做"解释"的操作等等.通常你得自己\N{\ren}and account for differences in that sort\Nof thing.so typically what she'll have
Dialogue: 0,0:20:44.93,0:20:48.71,ch,,0,0,0,,写一个方法,当你决定用fill这项技术时\N{\ren}when you're using this technique is a single method that you write
Dialogue: 0,0:20:48.71,0:20:53.17,ch,,0,0,0,,因为RecyclerView并没有给你提供fillGap或者fillAxe方法\N{\ren}there's no fill gap or fill axe method\Nthat lives in recycler view
Dialogue: 0,0:20:53.17,0:20:58.51,ch,,0,0,0,,这就需要我们自己来写一个方法.为了方便,就叫做fill了\N{\ren}you would create an internal method that we just by convention would call fill
Dialogue: 0,0:20:58.51,0:21:02.94,ch,,0,0,0,,(高能预警,我怕解释的不清楚,请把当前的布局管理假设为StaggerGridLayoutManager)这个方法会做列举出来的事情.它首先要\N{\ren}that does these things that I've listed here.so it's going to be responsible for
Dialogue: 0,0:21:02.94,0:21:06.75,ch,,0,0,0,,根据运行这次布局前的状态,来找出布局后第一个\N{\ren}determining based on the current layout what is the first
Dialogue: 0,0:21:06.75,0:21:10.10,ch,,0,0,0,,可见元素的位置\N{\ren}visible position you can see.you know,the
Dialogue: 0,0:21:10.10,0:21:13.90,ch,,0,0,0,,根据列表被向下滚动过长度\N{\ren}based on how far down the list is scrolled
Dialogue: 0,0:21:13.90,0:21:17.06,ch,,0,0,0,,由于布局前后第一个可见视图的位置会变\N你要在fill中做的就是,找出布局后第一个可见视图的位置\N{\ren}the first visible view doesn't necessarily mean
Dialogue: 0,0:21:17.06,0:21:21.78,ch,,0,0,0,,我们的做法就是\N{\ren}the first visible position but you basically the idea is to enumerate all
Dialogue: 0,0:21:21.78,0:21:23.16,ch,,0,0,0,,对布局前的视图进行枚举\N{\ren}those individual views
Dialogue: 0,0:21:23.16,0:21:28.19,ch,,0,0,0,,根据视图的状态,\N来决定哪个视图会是布局后的第一个可见视图\N{\ren}and figure out based on the views I have\Nwhat's the first position I can see
Dialogue: 0,0:21:28.19,0:21:31.62,ch,,0,0,0,,它可能是位置0,也可能是位置5,还可能是其他\N{\ren}as position 0 or as position 5 whatever\Nthe case may be
Dialogue: 0,0:21:31.62,0:21:35.41,ch,,0,0,0,,对于此视图,我们还要找出其偏移量\N{\ren}and you'll typically wanna look at that view and also determine its offset
Dialogue: 0,0:21:35.41,0:21:39.92,ch,,0,0,0,,如果此视图进行过位置变换的话.\N这种变化可能是由于视图被向上或向下平移了\N{\ren}is the view shifted in any way as it's shifted up or it's shifted down
Dialogue: 0,0:21:39.92,0:21:43.38,ch,,0,0,0,,而作为偏移量的另一部分,你还要考虑到\N{\ren}and as part of that,placement to that view
Dialogue: 0,0:21:43.38,0:21:46.71,ch,,0,0,0,,需不需要把Gap给计算在内.\N{\ren}do I have a gap?you know have the views
Dialogue: 0,0:21:46.71,0:21:50.29,ch,,0,0,0,,如果用户的滑动操作将列表往下平移到\N{\ren}shifted because of the user input user scroll the operation
Dialogue: 0,0:21:50.29,0:21:53.72,ch,,0,0,0,,需要其他视图进入来填充列表顶部的程度\N{\ren}to the point where I've got some extra\Nspace at the top that I need to fill
Dialogue: 0,0:21:53.72,0:21:54.74,ch,,0,0,0,,那这偏移量就要算上顶部的留白(Gap)\N{\ren}with another view
Dialogue: 0,0:21:54.74,0:21:58.27,ch,,0,0,0,,Gap这个术语就是这样而来的\N{\ren}that's kinda where the term comes from\Nif I don't
Dialogue: 0,0:21:58.27,0:22:01.87,ch,,0,0,0,,当然,如果列表按其他方式被平移,结果如果造成下面留白\N{\ren}or you know and maybe it shifted the\Nother way and maybe I have a gap at the bottom
Dialogue: 0,0:22:01.87,0:22:03.63,ch,,0,0,0,,因此底部要有东西来填充,这样偏移量就要算上底部留白\N{\ren}and I need to fill something there
Dialogue: 0,0:22:03.63,0:22:07.51,ch,,0,0,0,,简而言之,fill过程分为以下几步:\N1.找到第一个可视元素位置2.计算出Gap\N{\ren}so basically it's discovering what's\Nfirst finding gaps
Dialogue: 0,0:22:07.51,0:22:10.82,ch,,0,0,0,,不管Gap处在哪个边缘或者哪个角落\N{\ren}where where ever which edge whichever\Ncorner they may live in
Dialogue: 0,0:22:10.82,0:22:15.77,ch,,0,0,0,,3.最后,把所有视图Scrap掉,丢给recycler.\N这简单的三步走战略,能解决很多令人头疼的问题\N{\ren}and then scrapped everything this is the\Npart that will save you a bunch of headache
Dialogue: 0,0:22:15.77,0:22:20.21,ch,,0,0,0,,笨方法是,判断当前的状态,搞清楚视图将要如何被转换\N{\ren}rather than trying to determine your\Ncurrent state figure out whether based
Dialogue: 0,0:22:20.21,0:22:24.37,ch,,0,0,0,,接着对各个视图都做各做各的处理.\N两种方法,孰难孰易,孰好孰坏,不言自明.\N{\ren}on if it shifted this way do this if\Nit shifted that way do that just get
Dialogue: 0,0:22:24.37,0:22:28.05,ch,,0,0,0,,兄弟,你就省省劲,按我说的.1.找到第一个可视元素的位置\N{\ren}your current state information about\Nfirst visible position and where it
Dialogue: 0,0:22:28.05,0:22:31.34,ch,,0,0,0,,2.找出其偏移量3.把视图都留给ScrapHeap\N{\ren}is offset located toss everything in\Nthis crap in
Dialogue: 0,0:22:31.34,0:22:34.47,ch,,0,0,0,,这样以来\N{\ren}OK then from there
Dialogue: 0,0:22:34.47,0:22:38.72,ch,,0,0,0,,咱就能利用第一个可视视图的位置和偏移量等初始信息\N{\ren}take that initial information of the\Nfirst view and the first location
Dialogue: 0,0:22:38.72,0:22:43.06,ch,,0,0,0,,来走一次布局的过程了.这次的布局过程的逻辑是{\ren}and run a layup pass.just whatever logic
Dialogue: 0,0:22:43.06,0:22:47.16,ch,,0,0,0,,从初始位置的视图开始布局,依次往后布局,\N直到后面没有剩下空间为止{\ren}you need to say from this position until\NI run out of space
Dialogue: 0,0:22:47.16,0:22:51.88,ch,,0,0,0,,期间不断的从recycler中取出视图,然后对视图进行layout\N{\ren}grab views from the recycler and laid\Nthem out and then in that case it
Dialogue: 0,0:22:51.88,0:22:54.61,ch,,0,0,0,,这整个layout pass中,你无须考虑哪个视图是第一个,\N以及后面的视图离第一个视图的距离有多远\N{\ren}doesn't matter what's first or how far it is
Dialogue: 0,0:22:54.61,0:22:58.12,ch,,0,0,0,,你要做的,就仅仅是把所需的所有视图拿出来\N{\ren}you always just fill the space with
Dialogue: 0,0:22:58.12,0:23:01.70,ch,,0,0,0,,填充完剩下的空间而已,而不必考虑\N{\ren}all the views that you\Nneed depending on no matter what state
Dialogue: 0,0:23:01.70,0:23:02.63,ch,,0,0,0,,你当前列表所处什么状态\N{\ren}you're currently in
Dialogue: 0,0:23:02.63,0:23:06.66,ch,,0,0,0,,根据Gap所在的部位,你可能还要做一些调整的工作\N{\ren}now depending on where your gaps are you\Nmight have to make some adjustments
Dialogue: 0,0:23:06.66,0:23:10.89,ch,,0,0,0,,例如,你将列表向下平移了,那么Gap就在列表的上面\N{\ren}so for an instance if you shift the views\Ndown that gap is above
Dialogue: 0,0:23:10.89,0:23:13.89,ch,,0,0,0,,你将要进行布局的第一个视图的位置就\N{\ren}your first visible position that you\Nactually to lay out
Dialogue: 0,0:23:13.89,0:23:17.83,ch,,0,0,0,,往前递减了1次.\N因此你要根据Gap来做一些调整工作\N{\ren}has popped back one.so you may need to\Nmake some adjustment based on the gaps
Dialogue: 0,0:23:17.83,0:23:19.98,ch,,0,0,0,,不过,当你有了这些初始的信息之后\N{\ren}but once you have that initial information
Dialogue: 0,0:23:19.98,0:23:22.98,ch,,0,0,0,,往后列表发生任何转换,都只需执行一次三步走即可\N{\ren}and you scrap everything.just run a layout every time
Dialogue: 0,0:23:22.98,0:23:27.92,ch,,0,0,0,,整个操作的花费并不昂贵.\N因为其中大多数视图都是被布局过的.\N{\ren}right it's not expensive because a lot of these views are already laid out so
Dialogue: 0,0:23:27.92,0:23:30.55,ch,,0,0,0,,再次调用layout并不会改变任何属性\N{\ren}calling layout again doesn't change any other properties
Dialogue: 0,0:23:30.55,0:23:34.32,ch,,0,0,0,,除此之外,我们是把视图给放在ScrapHeap中的\N{\ren}and in it,in addition we've tossed them\Nin the scrap heap
Dialogue: 0,0:23:34.32,0:23:37.81,ch,,0,0,0,,因此,将视图从recycler中检索回来的代价也是很低的\N{\ren}so retrieving them back from the\Nrecycler is also very cheap
Dialogue: 0,0:23:37.81,0:23:42.24,ch,,0,0,0,,所以,可以看出来,这种操作就算不停的被执行\N{\ren}okay so I can do this over and over and\Nover again and as you know it doesn't
Dialogue: 0,0:23:42.24,0:23:45.79,ch,,0,0,0,,它也不会很影响性能.因此,我们不必想着\N{\ren}it doesn't necessarily affect the performance.I don't just have to try and
Dialogue: 0,0:23:45.79,0:23:49.47,ch,,0,0,0,,1.怎么对所需的空间里的元素进行操作\N2.怎么调整其余的元素不受影响\N{\ren}manipulate the spaces that I need and\Ntry to leave all the other views along
Dialogue: 0,0:23:49.47,0:23:52.64,ch,,0,0,0,,你如果这么干的话,你会处处碰壁,举步维艰\N{\ren}you'll get yourself caught in way too\Nmany edge cases if you do that
Dialogue: 0,0:23:52.64,0:23:56.24,ch,,0,0,0,,正确的做法,就是简化整个过程,\N每次更新列表都按我刚说的办\N{\ren}you can simplify it by just doing the\Nsame process every time
Dialogue: 0,0:23:56.24,0:23:59.98,ch,,0,0,0,,fill这个方法不管是在初始化布局时\N{\ren}and then this method will be called\Nwhether it's in initial layout
Dialogue: 0,0:23:59.98,0:24:03.93,ch,,0,0,0,,还是在用户滚动列表时,\N还是在RecyclerView有任何状态改变时\N{\ren}where they were scrolling whether any\Nstate changes on the recycler view which
Dialogue: 0,0:24:03.93,0:24:06.26,ch,,0,0,0,,其都会被调用.而且每次被调用所走的都是同一个过程\N{\ren}is gonna go through this exact same\Nprocess
Dialogue: 0,0:24:06.26,0:24:09.56,ch,,0,0,0,,(太佩服我自己了,居然把fill这个概念翻译完了 - -)\N{\ren}alright
Dialogue: 0,0:24:09.56,0:24:12.44,ch,,0,0,0,,你可能又会问,上哪儿找我的Gap呢\N{\ren}questions you would ask yourself about\Nwhere my gaps
Dialogue: 0,0:24:12.44,0:24:16.61,ch,,0,0,0,,这里很重要的一点要记住,你要尽可能少的去保存状态值\N{\ren}and the important thing to remember here\Nis to save as little state as possible
Dialogue: 0,0:24:16.61,0:24:20.39,ch,,0,0,0,,你要做的是把视图的信息给算出来\N{\ren}right you want to discover the\Ninformation about your view
Dialogue: 0,0:24:20.39,0:24:24.36,ch,,0,0,0,,第一个可视视图的位置和其偏移量都要算才行.\N{\ren}what's the first visible position what\Nis it offset don't try to track
Dialogue: 0,0:24:24.36,0:24:28.30,ch,,0,0,0,,不要想着设置状态值去追踪这些信息.\N因为这通常会由于\N{\ren}that information because that typically\Ntends to lead to edge cases where you
Dialogue: 0,0:24:28.30,0:24:29.92,ch,,0,0,0,,你没有追踪到位都导致边界错误.\N{\ren}can track it correctly and then you
Dialogue: 0,0:24:29.92,0:24:34.03,ch,,0,0,0,,你会把事情推向另一个分支发展.所以正确的做法是\N{\ren}you are branching a statement all over the\Nplace.ok use this as a
Dialogue: 0,0:24:34.03,0:24:37.49,ch,,0,0,0,,尽可能把fill这个函数当成一个无状态函数,\N只借助内部状态找出\N{\ren}as stateless a function as you can\Npossibly do that discovers everything it
Dialogue: 0,0:24:37.49,0:24:38.41,ch,,0,0,0,,来找出我们所需的布局初始信息\N{\ren}needs up front
Dialogue: 0,0:24:38.41,0:24:41.71,ch,,0,0,0,,然后恰当的去运行布局过程.\N{\ren}and then runs the layout appropriately\Non each pass
Dialogue: 0,0:24:44.78,0:24:45.48,ch,,0,0,0,,\N{\ren}okay
Dialogue: 0,0:24:45.48,0:24:48.75,ch,,0,0,0,,顺便,我们这里举一个fill的例子\N{\ren}just by  way,an example,this is what a fill
Dialogue: 0,0:24:48.75,0:24:51.92,ch,,0,0,0,,fill函数应该就长得像这样\N{\ren}function might look like or you\Nmight stop one out
Dialogue: 0,0:24:51.92,0:24:56.05,ch,,0,0,0,,这里,首先,你需要想出一些逻辑来找出{\ren}so you know,at the beginning you're going to\Nhave some logic to determine what the
Dialogue: 0,0:24:56.05,0:24:58.76,ch,,0,0,0,,第一个可视视图的位置,这个位置由于布局的不同\N{\ren}first visible position is depending on\Nyour layout that
Dialogue: 0,0:24:58.76,0:25:02.65,ch,,0,0,0,,其位置的算法肯定也不相同.若是简单的算法,也许就像是\N{\ren}your could mean a number of things it's\Nprobably just gonna be something simple
Dialogue: 0,0:25:02.65,0:25:07.13,ch,,0,0,0,,枚举所有的孩子视图,对其ViewHolder进行询问\N{\ren}like enumerating overall the child views\Nasking those Child's View holders what
Dialogue: 0,0:25:07.13,0:25:08.15,ch,,0,0,0,,其所处的位置是多少\N{\ren}their position are
Dialogue: 0,0:25:08.15,0:25:12.16,ch,,0,0,0,,要是你的列表是按线性布局的话,\N那么所要找的位置就是其中最小的\N{\ren}and may be looking for the lowest value\NOK that would be true for a linear want
Dialogue: 0,0:25:12.16,0:25:14.01,ch,,0,0,0,,如果是其他情形,那么就要依据\N{\ren}it may not be true depending on what your
Dialogue: 0,0:25:14.01,0:25:18.59,ch,,0,0,0,,布局的不同来选取不同的位置了.\N总之,你要找出来第一个列表项的位置\N{\ren}your layout implementation is,but\Nfiguring out what that first visible item is
Dialogue: 0,0:25:18.59,0:25:22.88,ch,,0,0,0,,如果需要的话,你还要把偏移量给找出来.\N这就取决于你的列表有没有进行过转换\N{\ren}and if it's necessary what is its offset\Nis it has it been shifted
Dialogue: 0,0:25:22.94,0:25:25.78,ch,,0,0,0,,如果被转换过,我们就要对留白进行填充等等.\N{\ren}so that we need to of your fill a gap or\Nsomething like that
Dialogue: 0,0:25:26.42,0:25:28.05,ch,,0,0,0,,正如我之前所提到的\N{\ren}and then as i mentioned there are
Dialogue: 0,0:25:28.05,0:25:31.10,ch,,0,0,0,,RecyclerView中有一些帮助类的方法可供我们使用\N{\ren}a helper methods available on the\Nrecycler view
Dialogue: 0,0:25:31.10,0:25:34.37,ch,,0,0,0,,这样方法可以帮助我们将视图传给回收器进行回收\N{\ren}to help you toss away of views so the
Dialogue: 0,0:25:34.37,0:25:39.61,ch,,0,0,0,,framework中几乎每个主要的方法都会传递给你两个对象\N{\ren}the two objects that you're going to see\Npassed to you in pretty much every major framework method
Dialogue: 0,0:25:39.61,0:25:43.79,ch,,0,0,0,,1是回收器的实例,2是叫做回收器状态的对象\N{\ren}is a recycler instance and something\Ncalled the recycler state
Dialogue: 0,0:25:43.79,0:25:47.00,ch,,0,0,0,,这两个对象一般都是绑定在一起工作的\N{\ren}and those two things all will work together
Dialogue: 0,0:25:47.00,0:25:50.11,ch,,0,0,0,,其工作目的是\N在你需要做跟修改布局相关的事情时来帮你\N{\ren}for everything that you need to do\Nassociated with modifying your layout so
Dialogue: 0,0:25:50.11,0:25:50.87,ch,,0,0,0,,我们这个例子中\N{\ren}in this case
Dialogue: 0,0:25:50.87,0:25:55.52,ch,,0,0,0,,recycler被传进入了API中的一个帮助方法\N{\ren}the recycler is passed to this helper\Nfunction which is part of the API
Dialogue: 0,0:25:55.52,0:25:59.29,ch,,0,0,0,,这个方法不用你来做实现,你只要告诉framework,\NdetachAndScrapAttachedViews就行了\N{\ren}that's not something you have to write\Njust detach and scrap attached views
Dialogue: 0,0:25:59.29,0:26:02.68,ch,,0,0,0,,这意思是说,把当前attached的视图全都\N{\ren}that says tossed every view that I has\Ncurrently attached to me
Dialogue: 0,0:26:02.68,0:26:06.90,ch,,0,0,0,,丢给Scrap堆.之后,\N{\ren}throw into scrap.OK,and then from there
Dialogue: 0,0:26:06.90,0:26:10.74,ch,,0,0,0,,你可以简单的遍历出你所需要的视图,\N{\ren}you can simply iterate through however\Nmany views you need whether you have
Dialogue: 0,0:26:10.74,0:26:14.21,ch,,0,0,0,,不管你是要把这些视图布局到一个固定大小的窗口里,\N还是你要用视图把整个界面的空间都布局满\N{\ren}like a fixed window size or you just\Nwant to iterate through views until you
Dialogue: 0,0:26:14.21,0:26:17.49,ch,,0,0,0,,或者将这些视图应用到任何你想出来的布局算法中\N{\ren}run out of space whatever algorithm that you\Nwant to use to do this
Dialogue: 0,0:26:17.49,0:26:21.01,ch,,0,0,0,,你都得把这些需要的视图给遍历出来.你要在\N{\ren}iterate through those views and get each one back
Dialogue: 0,0:26:21.01,0:26:22.66,ch,,0,0,0,,recycler中把每个视图给查找出来.\N{\ren}from the recycler so
Dialogue: 0,0:26:22.66,0:26:26.53,ch,,0,0,0,,getViewForPosition这个方法会告诉recycler,\N我想在这个位置上进行布局\N{\ren}getViewForPosition will tell the recycler this is\Nthe position I wanna lay out
Dialogue: 0,0:26:26.53,0:26:30.16,ch,,0,0,0,,接着recycler会返回给你所需要的视图,\N并且已经给你绑定好了数据\N{\ren}and it will give you the view already\Nbound to the data that you need to do
Dialogue: 0,0:26:30.16,0:26:30.98,ch,,0,0,0,,这些数据会在你布局的时候被用到\N{\ren}that layout with
Dialogue: 0,0:26:30.98,0:26:34.94,ch,,0,0,0,,之后,就像你将视图布局到其他任何ViewGroup中一样,\N你先要把视图给添加进入\N{\ren}OK and then just like you would in any\Nother view group you need add it
Dialogue: 0,0:26:34.94,0:26:38.27,ch,,0,0,0,,或者说是attach到父视图上,然后measure,layout\N{\ren}or attach it measure it and lay it out
Dialogue: 0,0:26:38.27,0:26:43.88,ch,,0,0,0,,这之后\N{\ren}oK then from there
Dialogue: 0,0:26:43.88,0:26:48.11,ch,,0,0,0,,最后一步是看看有没有剩下的视图\N{\ren}the final job is determining if there\Nare any views that were in my layout
Dialogue: 0,0:26:48.11,0:26:52.12,ch,,0,0,0,,这些在布局中没有被用到.之前,我们开始的时候,\N我们是把当前所有的视图都丢给ScrapHeap\N{\ren}that I don't need anymore so when I went\Nthrough and I scrapped everything
Dialogue: 0,0:26:52.12,0:26:55.75,ch,,0,0,0,,如果在接下来的layout过程中,\N仅仅使用到了我们所需的视图\N{\ren}if if the next step is to lay out just what I need
Dialogue: 0,0:26:55.75,0:26:58.95,ch,,0,0,0,,那么在Scrap中就有可能还剩下没被操作的视图\N{\ren}there may be views that were left in the scrap heap
Dialogue: 0,0:26:58.95,0:27:02.48,ch,,0,0,0,,这些视图就可能是滚出屏幕的视图,\N也可能是由于某种原因\N{\ren}and those are views that I scrolled off screen or for whatever reason I don't
Dialogue: 0,0:27:02.48,0:27:03.32,ch,,0,0,0,,我不在需要的视图\N{\ren}need anymore
Dialogue: 0,0:27:03.32,0:27:07.50,ch,,0,0,0,,因为这些视图没有经过layout的过程\N(因此就不会再出现在屏幕之上了)\N{\ren}because they didn't make it back into the layout pass.you can ask the recycler
Dialogue: 0,0:27:07.50,0:27:10.23,ch,,0,0,0,,此时你可以对recycler中的视图状态进行检查\N{\ren}view for its current list of what's in scrap
Dialogue: 0,0:27:10.23,0:27:14.19,ch,,0,0,0,,此时如果还有视图存在与Scrap中的话,我们是不需要的了\N{\ren}and if there is anything left in scrap at this stage I don't need it
Dialogue: 0,0:27:14.19,0:27:18.58,ch,,0,0,0,,那对于这些视图,我就可以把它们给回收了.\N回收的过程就是\N{\ren}so I can recycle it.ok,so then this will just go through in
Dialogue: 0,0:27:18.58,0:27:22.89,ch,,0,0,0,,把视图从ScrapHeap中拿出来,\N然后显式的将其它们丢给RecyclerPool\N{\ren}and take the views out at the scrap heap and explicitly put them in their cycle poor
Dialogue: 0,0:27:22.89,0:27:26.36,ch,,0,0,0,,这是一种更有效的回收视图的方式,来把你明确知道的\N{\ren}okay and that's a more efficient way of holding those views when you know
Dialogue: 0,0:27:26.36,0:27:30.21,ch,,0,0,0,,之后还会再绑定数据的视图进行回收.这并不意味着\N{\ren}that they're gonna need to be rebound to data later on,that doesn't mean that
Dialogue: 0,0:27:30.21,0:27:34.77,ch,,0,0,0,,你把这些剩下的存在于Scrap的视图给回收后,\N{\ren}if you run out of views and recycle\Nand the only views that are available are in scrap that
Dialogue: 0,0:27:34.77,0:27:39.60,ch,,0,0,0,,这些视图就不能进行数据绑定了.recycler不光从Scrap中,\N也会从RecyclerPool中取出视图进行绑定.\N{\ren}it won't be able to rebind them.recycle will rebind data from scrap or recycle so it
Dialogue: 0,0:27:39.60,0:27:42.98,ch,,0,0,0,,你不必担心到底能不能\N{\ren}it's not something you necessarily have to worry about as to whether it will
Dialogue: 0,0:27:42.98,0:27:46.97,ch,,0,0,0,,让你的视图工作起来.这仅仅是一种优化操作\N{\ren}make your view work correctly.it's just an optimization
Dialogue: 0,0:27:46.97,0:27:51.66,ch,,0,0,0,,如果在recycler中正确的使用Scrap,\N你就能对回收行为做最大的优化\N{\ren}if you use scrap in recycle appropriately\Nthen you'll have the most optimized for recycling behavior
Dialogue: 0,0:27:51.66,0:27:53.86,ch,,0,0,0,,比方说内存管理或其他等等相关的.\N{\ren}in terms of memory management that sort of thing.okay
Dialogue: 0,0:27:53.86,0:27:56.44,ch,,0,0,0,,layout的过程讲完了.\N{\ren}okay
Dialogue: 0,0:27:56.46,0:28:00.33,ch,,0,0,0,,那么framework让我们这么干的好处在哪呢\N其好处之一就是,在实现我的例子\N{\ren}so one of the advantages from the example that I
Dialogue: 0,0:28:00.33,0:28:04.51,ch,,0,0,0,,之前,我必须要对视图的索引进行处理\N{\ren}had put forth of doing this has to do with view indices
Dialogue: 0,0:28:04.51,0:28:09.75,ch,,0,0,0,,要实现这种布局,我第一个要考虑的问题就是\N{\ren}one of the first problem i doubt with when dealing with this,this fixed grid implementation
Dialogue: 0,0:28:09.75,0:28:14.22,ch,,0,0,0,,这不像是一个通常的线性单向滚动的\N{\ren}was unlike a traditional linear single scrolling
Dialogue: 0,0:28:14.22,0:28:18.23,ch,,0,0,0,,实现,这里在滚动时,视图的索引不是连续的\N{\ren}implementation the view indices aren't always consistent
Dialogue: 0,0:28:18.23,0:28:21.65,ch,,0,0,0,,在LinearLayout甚至GridLayout中,你都可以简单的\N{\ren}you know something like a LinearLayout or even a grid layout you can typically
Dialogue: 0,0:28:21.65,0:28:23.05,ch,,0,0,0,,依赖这样一个事实\N{\ren}rely on the fact that
Dialogue: 0,0:28:23.05,0:28:26.10,ch,,0,0,0,,列表中的第一个视图,就是第一个可见的视图\N{\ren}the first views in the list are the first visible
Dialogue: 0,0:28:26.10,0:28:29.49,ch,,0,0,0,,最后一个视图,就是最后一个可见的视图.你可以依赖于\N{\ren}and the last views in list is the last visible.and you can rely on a
Dialogue: 0,0:28:29.49,0:28:33.63,ch,,0,0,0,,视图的index和position以一种相对连续的方式进行映射\N{\ren}a fairly consistent mapping between view indices
Dialogue: 0,0:28:33.63,0:28:36.08,ch,,0,0,0,,当列表往上滚的时候,\N{\ren}and positions you know when you scroll up you would
Dialogue: 0,0:28:36.08,0:28:40.25,ch,,0,0,0,,你通常在列表前面插入视图,如果列表下滚\N{\ren}typically insert views at the front and\Nif as you scroll down you would
Dialogue: 0,0:28:40.25,0:28:44.52,ch,,0,0,0,,通常就在尾部进行添加.但是对于\N{\ren}append them to the end or vice versa but\Nthat's not necessarily true with this
Dialogue: 0,0:28:44.52,0:28:46.17,ch,,0,0,0,,我们的例子来说这样做就不对了.\N{\ren}case you know in this case if the
Dialogue: 0,0:28:46.17,0:28:50.22,ch,,0,0,0,,如果用户正在查看网格中间的某些块元素\N{\ren}if the user is looking at some block of elements in the middle of the grid
Dialogue: 0,0:28:50.22,0:28:54.07,ch,,0,0,0,,视图的索引就可能看起来像这种样子,按照我布局的方式\N{\ren}the view indices might look something like this: based on the way I've laid them out
Dialogue: 0,0:28:54.07,0:28:57.82,ch,,0,0,0,,但是你可以看出来,如果你把左边和右边的\N{\ren}but you can kinda see that on the left and the right hand side there
Dialogue: 0,0:28:57.82,0:29:01.00,ch,,0,0,0,,视图索引当成适配器的位置来看时\N{\ren}those views are part of the range
Dialogue: 0,0:29:01.00,0:29:04.83,ch,,0,0,0,,从适配器的角度来看,它们就是不可见的\N{\ren}from the adapters perspective they just aren't visible right now
Dialogue: 0,0:29:04.83,0:29:08.78,ch,,0,0,0,,你可以想象的到,当我把这个窗口在视图上做各种平移时\N{\ren}so you can imagine that as i shift the window across these views
Dialogue: 0,0:29:08.78,0:29:12.51,ch,,0,0,0,,视图们就会以组的形式给添加进来.我可能\N{\ren}they will be brought in as groups\Nso I would bring in maybe
Dialogue: 0,0:29:12.51,0:29:16.36,ch,,0,0,0,,会添加4个视图来布局出下一列,\N或者添加几个视图来布局下一行\N{\ren}for call 4 views in the next column\Nmaybe a couple for the new row
Dialogue: 0,0:29:16.36,0:29:20.23,ch,,0,0,0,,这些视图以组的形式可能从各个方向上\N(上,下,左,右)被添加进来\N{\ren}and it will come in groups that could be coming from all four sides
Dialogue: 0,0:29:20.23,0:29:23.79,ch,,0,0,0,,因此如果我要依赖任何\N{\ren}so if I want to rely on any sort
Dialogue: 0,0:29:23.79,0:29:28.73,ch,,0,0,0,,视图索引的连续性的话,我需要先把所有视图都丢掉,然后\N{\ren}of consistency in the view indices I need to toss everything away and
Dialogue: 0,0:29:28.73,0:29:33.00,ch,,0,0,0,,然后对其进行重新布局,来确保索引0的孩子总在左上方\N{\ren}relayout and that insures that child 0 is always at the top left
Dialogue: 0,0:29:33.00,0:29:36.14,ch,,0,0,0,,索引X的孩子总在右下方\N{\ren}child whatever is at the bottom right.ok
Dialogue: 0,0:29:36.14,0:29:39.38,ch,,0,0,0,,否则你就不能依赖索引连续性.\N我并不是说你非得这么干.\N{\ren}otherwise I can't and I'm not saying you\Nhave to rely on that but
Dialogue: 0,0:29:39.38,0:29:43.26,ch,,0,0,0,,但你如果非要为这么干找一个原因的话,\N如果说你能够确定\N{\ren}but a little trick to help keep your sanity here is if you can be relatively sure
Dialogue: 0,0:29:43.26,0:29:45.01,ch,,0,0,0,,孩子视图的索引\N{\ren}that the child indices are in the right
Dialogue: 0,0:29:45.01,0:29:50.21,ch,,0,0,0,,一直是正常的话,这会帮你简化你一些检查的逻辑\N{\ren}order all the time then it it helps simplify some of that inspection logic
Dialogue: 0,0:29:50.21,0:29:52.87,ch,,0,0,0,,这种检查是当你对视图做改变时有可能需要做的,等等\N{\ren}that you may need to do later on for changes and stuff like that
Dialogue: 0,0:29:52.87,0:29:56.27,ch,,0,0,0,,因此,这里说的\N仅仅是遵从framework进行layout的一个好处\N{\ren}so just an advantage of using that implementation
Dialogue: 0,0:29:56.27,0:30:01.52,ch,,0,0,0,,取决于你自定义布局的功能性和你对fill方法的改写\N{\ren}and this depending on your functionality and how you mutate that fill method I showed you
Dialogue: 0,0:30:01.52,0:30:04.90,ch,,0,0,0,,你可以通过手动调用attach和detach\N{\ren}you can use attach and detach manually
Dialogue: 0,0:30:04.90,0:30:09.53,ch,,0,0,0,,来对屏幕上的视图进行重新排序.\N如果你不准备将他们都丢给Scrap的话\N{\ren}to reorder these views so you know if\Nyou're not necessarily scrapping them
Dialogue: 0,0:30:09.53,0:30:13.51,ch,,0,0,0,,但是,出于某种原因,你仅仅是想将视图进行重新排序的话\N{\ren}but for whatever reason you just want to\Nreorder them so that the same views have
Dialogue: 0,0:30:13.51,0:30:15.28,ch,,0,0,0,,视图还是同样的视图,但是视图的索引却被重新排序的话\N{\ren}different indices that are in this order
Dialogue: 0,0:30:15.28,0:30:18.49,ch,,0,0,0,,你要先把视图全detach掉,\N然后将视图以正确的顺序给attach回来\N{\ren}detach them all and reattach them in the right order that will
Dialogue: 0,0:30:18.49,0:30:24.26,ch,,0,0,0,,这样才能使孩子视图有合适的视图索引\N{\ren}that will give them the proper view index from a child perspective inside of the parent view
Dialogue: 0,0:30:28.56,0:30:30.05,ch,,0,0,0,,好了,咱接下来要讲一下\N{\ren}okay so let's talk a little bit about
Dialogue: 0,0:30:30.05,0:30:35.26,ch,,0,0,0,,整个布局过程的步骤了.\N假设你现在已经写好了一个fill方法\N{\ren}the steps to build one of these things,so assuming that you have a proper method put together
Dialogue: 0,0:30:35.26,0:30:38.96,ch,,0,0,0,,将我传授给你的秘诀都用上了.\N{\ren}one that sort of follows that recipe that I showed you.
Dialogue: 0,0:30:38.96,0:30:42.77,ch,,0,0,0,,现在,我就传授你如何将前面讲过的东西串联在一起.\N{\ren}this is sort of how we would put these things in place,so the first
Dialogue: 0,0:30:42.77,0:30:45.78,ch,,0,0,0,,我把使用recycler对视图进行布局的第一级别称为\N{\ren}the first level that I call it of working recycler view layout
Dialogue: 0,0:30:45.78,0:30:49.53,ch,,0,0,0,,让布局管理器能工作起来.布局管理器有很多回调方法\N{\ren}is just to get the thing working,right.so that there's a handful call back
Dialogue: 0,0:30:49.53,0:30:54.59,ch,,0,0,0,,需要你来进行重写和实现\N来使一个实际的布局管理器可以工作起来\N{\ren}you need to to override and implement just to get an actual layout manager functioning
Dialogue: 0,0:30:54.59,0:30:58.10,ch,,0,0,0,,第一个要重写的方法就是onLayoutChildren,\N这是一个初始化的方法\N{\ren}the first one is on layout children this is the initial method
Dialogue: 0,0:30:58.10,0:31:02.33,ch,,0,0,0,,这个方法会由framework调用,当任何一个特定的布局改变\N{\ren}they will be called by the framework anytime a significant layout change
Dialogue: 0,0:31:02.33,0:31:03.90,ch,,0,0,0,,发生在RecyclerView身上时\N{\ren}happens to the recycler view
Dialogue: 0,0:31:03.90,0:31:06.94,ch,,0,0,0,,RecyclerView就会把这个改变委托给布局管理器\N{\ren}the recycler view will delegate to the manager that
Dialogue: 0,0:31:06.94,0:31:11.49,ch,,0,0,0,,告诉它,需要它通过onLayoutChildren进行一次新的布局,\N注意,onLayoutChildren并不会被重复调用\N{\ren}it needs to do a new layout through onLayoutChildren.this is not called repeatedly
Dialogue: 0,0:31:11.49,0:31:15.60,ch,,0,0,0,,所以,其不会在每次布局改变时都被调用,而仅在初始化时\N{\ren}meaning it's not called on every change\Nbut it'll be called for initial layout
Dialogue: 0,0:31:15.60,0:31:18.85,ch,,0,0,0,,还有当RecyclerView的大小被改变时也会调用\N{\ren}it will be called if the size of the recycler view changes if you ever call
Dialogue: 0,0:31:18.85,0:31:21.83,ch,,0,0,0,,如果你有调用过RecyclerView.requestLayout的话,\N就会触发onLayoutChildren被调用\N{\ren}requestLayout on the recycler view this is what you're gonna see
Dialogue: 0,0:31:21.83,0:31:25.49,ch,,0,0,0,,如果写的fill方法合格的话,在onLayoutChildren中,\N你要干的全部工作\N{\ren}and again if you haven't inappropriately written fill method all you have to do
Dialogue: 0,0:31:25.49,0:31:29.84,ch,,0,0,0,,仅仅是运行fill而已.不管你在RecyclerView中\N是否已经存在了视图,或者其中视图为空\N{\ren}in here is to run it.whether you have views in there already or whether it's empty
Dialogue: 0,0:31:29.84,0:31:33.13,ch,,0,0,0,,这都没关系,你仅仅在里面运行fill即可,就能把事情全搞定\N{\ren}doesn't matter you just run your fill inside of here and be done
Dialogue: 0,0:31:33.13,0:31:40.08,ch,,0,0,0,,但是,我们还在这个方法中添加一些对用户操作的控制\N{\ren}okay,but we want to add a little bit of user act in there interactivity to this function as well
Dialogue: 0,0:31:40.08,0:31:45.50,ch,,0,0,0,,所以,你必须在RecyclerView中来决定或者说是通知framework\N{\ren}so you have to determine or you have to report back to the framework in recycler view
Dialogue: 0,0:31:45.50,0:31:50.11,ch,,0,0,0,,这个视图能在哪个坐标轴上进行滚动,是垂直轴呢?\N{\ren}which axis can this view scrolling,can it scroll vertically
Dialogue: 0,0:31:50.11,0:31:53.39,ch,,0,0,0,,还是水平轴?或者在我的例子中,两者都行\N{\ren}can scroll horizontally or in my case,both
Dialogue: 0,0:31:53.39,0:31:57.03,ch,,0,0,0,,多数情况下,你仅仅需要在这两个方法中\N{\ren}so in most of these cases you would only return true
Dialogue: 0,0:31:57.03,0:32:01.01,ch,,0,0,0,,的一个里面返回true就行了.\N但是我们的固定网格实现两个方法中都返回了true\N{\ren}from one of these methods but the fix grid implementation returns it for
Dialogue: 0,0:32:01.01,0:32:04.45,ch,,0,0,0,,这样它就能在水平方向和垂直方向同时滚动了.\N{\ren}both so that it can scroll both horizontally and vertically at the same time
Dialogue: 0,0:32:04.45,0:32:07.82,ch,,0,0,0,,如果你没有从这两个方法中返回true\N{\ren}if you don't return true from these methods then
Dialogue: 0,0:32:07.82,0:32:12.22,ch,,0,0,0,,那么RecyclerView的内部实现就简单地\N不把这个方向上事件分发给自己来处理\N{\ren}the recycler view implementation simply won't delivery events back to you
Dialogue: 0,0:32:12.22,0:32:15.74,ch,,0,0,0,,因为它知道你只会在一个方向上滚动,因此会锁定滚动\N{\ren}knowing that you're scrolling in one direction,the other basically locks scrolling
Dialogue: 0,0:32:15.74,0:32:18.87,ch,,0,0,0,,在另一个方向上\N{\ren}in that particular orientation but
Dialogue: 0,0:32:18.87,0:32:22.87,ch,,0,0,0,,而真正实现视图滚动的处理逻辑是在\N{\ren}the actual implementation of this scrolling functionality happens in the
Dialogue: 0,0:32:22.87,0:32:26.85,ch,,0,0,0,,scrollXBy方法中,水平方向滚动的话就是scrollHorizontallyBy,\N垂直的话就是scrollVerticallyBy\N{\ren}scroll x by methods so scroll horizontally or vertically by
Dialogue: 0,0:32:26.85,0:32:31.86,ch,,0,0,0,,这俩方法会重复地被调用,这跟你在\N{\ren}these methods will be called repeatedly very similar to the scroll by methods you
Dialogue: 0,0:32:31.86,0:32:33.53,ch,,0,0,0,,View里或ViewGroup里看到的scrollBy方法是非常相似的,\N{\ren}would see on a view or view group
Dialogue: 0,0:32:33.53,0:32:38.15,ch,,0,0,0,,当用户的手势交互到来时.因此这是布局管理器的责任\N{\ren}as user interaction is coming in.so it is the responsibility
Dialogue: 0,0:32:38.15,0:32:41.64,ch,,0,0,0,,去处理视图的移动\N{\ren}of the layout manager to handle moving the views
Dialogue: 0,0:32:41.64,0:32:45.01,ch,,0,0,0,,RecyclerView本身是不处理视图滚动的,\N它仅仅预先把信息提供给布局管理器\N{\ren}recycle view doesn't do that for you\Nokay it just gives you the information
Dialogue: 0,0:32:45.01,0:32:47.03,ch,,0,0,0,,以使其自身可以被滚动\N{\ren}up front to be able to do that
Dialogue: 0,0:32:47.03,0:32:52.89,ch,,0,0,0,,因此这些方法在调用的时候会附带着\Nframework根据用户的输入计算出来的信息\N{\ren}so these methods will be called with the information that the framework has determined from the user input
Dialogue: 0,0:32:52.89,0:32:56.16,ch,,0,0,0,,从根本上来讲,这两个方法会循序渐进地被调用,\N每次被调用都会传递给你一个delta值\N{\ren}basically they'll give you a delta value and this is called incrementally
Dialogue: 0,0:32:56.16,0:32:59.53,ch,,0,0,0,,这个值代表着framework所认为的,此时,\N你应当将你的视图平移多远\N{\ren}of how far the framework thinks you should shift your views
Dialogue: 0,0:32:59.53,0:33:03.59,ch,,0,0,0,,当然,这得分横向平移和纵向平移\N{\ren}and of course in which direction horizontally or vertically,ok
Dialogue: 0,0:33:03.59,0:33:05.96,ch,,0,0,0,,接下来,这就需要你来对视图进行真正\N{\ren}and then it will be up to you to actually do
Dialogue: 0,0:33:05.96,0:33:09.78,ch,,0,0,0,,的移动了,同时,你还要对移动过程中的边界条件做处理\N{\ren}the movement as well as making any determinations about boundary conditions
Dialogue: 0,0:33:09.78,0:33:14.57,ch,,0,0,0,,布局管理器有义务去告诉framework,当视图滚到\N{\ren}right?the layout managers responsible for telling the framework when you hit the
Dialogue: 0,0:33:14.57,0:33:17.21,ch,,0,0,0,,内容的结尾处时,应该停止滚动\N{\ren}end of the content and you need to stop scrolling
Dialogue: 0,0:33:17.21,0:33:22.44,ch,,0,0,0,,在此当前方向.其实通知framework的报告就放在return值里\N{\ren}in that particular direction.oK now that report is actually done in the terms the return value
Dialogue: 0,0:33:22.44,0:33:26.47,ch,,0,0,0,,从这个函数中返回的任何值\N{\ren}so when whatever value you return from this function
Dialogue: 0,0:33:26.47,0:33:29.74,ch,,0,0,0,,都标明给framework,此时你实际上移动了多远的距离\N{\ren}designates to the framework how far you actually traveled
Dialogue: 0,0:33:29.74,0:33:32.94,ch,,0,0,0,,接着,framework会根据其被告知移动的距离来对视图进行移动\N{\ren}and then the framework will make determination based on how much how far
Dialogue: 0,0:33:32.94,0:33:34.14,ch,,0,0,0,,(同上)\N{\ren}I told you to travel
Dialogue: 0,0:33:34.14,0:33:37.00,ch,,0,0,0,,如果返回值为0,那么framework就会假定视图滚动到了边界\N{\ren}if there's a difference there it assumes it hit boundary and it's going to do
Dialogue: 0,0:33:37.08,0:33:39.99,ch,,0,0,0,,framework就会为你做一些事情,比方说会帮你画边缘发光的效果\N{\ren}things for you like drawing edge glows
Dialogue: 0,0:33:39.99,0:33:44.24,ch,,0,0,0,,还有像其他的边缘效果,你肯定不想看到你的布局管理器\N{\ren}and other edge effect behavior that you probably don't wanna see if you're not
Dialogue: 0,0:33:44.24,0:33:47.44,ch,,0,0,0,,没有这种边缘效果,\N因此你必须要对return值是如何来的十分关心\N{\ren}all the way at the end,so you have to be very careful about how that return value
Dialogue: 0,0:33:47.44,0:33:48.36,ch,,0,0,0,,(同上)\N{\ren}actually comes up
Dialogue: 0,0:33:48.36,0:33:51.47,ch,,0,0,0,,这就是scrollXby方法的示例\N{\ren}so this is kind of an example
Dialogue: 0,0:33:51.47,0:33:56.88,ch,,0,0,0,,这是一段在FiexedGrid中的代码片段\N{\ren}of what you might see.this is a snippet version of what's in fixed grid for scroll horizontally
Dialogue: 0,0:33:56.88,0:33:59.90,ch,,0,0,0,,首先你被传入一个称为dx的值\N{\ren}so you're given a value that they call in this case dx
Dialogue: 0,0:33:59.90,0:34:03.69,ch,,0,0,0,,这个值就是framework认为的你应当滚动的值.首先,\N{\ren}thats how far they think you should scroll.first thing you have to determine
Dialogue: 0,0:34:03.69,0:34:06.98,ch,,0,0,0,,你可能要根据此次滚动发生的方向来决定\N{\ren}perhaps based on which direction that scrolling occurs is.
Dialogue: 0,0:34:06.98,0:34:10.25,ch,,0,0,0,,我能否滚动这么远,我有没有碰到边界\N{\ren}can I scroll that far or have I hit boundary
Dialogue: 0,0:34:10.25,0:34:13.98,ch,,0,0,0,,最后才来决定实际要平移的距离.这里有个好处是,\N{\ren}and determine how far you're actually going to shift.now the nice thing is
Dialogue: 0,0:34:13.98,0:34:17.58,ch,,0,0,0,,你不必对孩子视图们进行迭代,然后对其进行单独的移动\N{\ren}you don't have to iterate over the child views and individually move them
Dialogue: 0,0:34:17.58,0:34:23.70,ch,,0,0,0,,RecyclerView的LayoutManager\N为我们提供水平和垂直平移的帮助方法\N{\ren}recycler view layout manager provides of these offset children methods both horizontal and vertical
Dialogue: 0,0:34:23.70,0:34:28.15,ch,,0,0,0,,来帮我们对当前attached的所有视图进行平移转换\N{\ren}that will do the the work of shifting all views that are currently attached
Dialogue: 0,0:34:28.15,0:34:31.25,ch,,0,0,0,,因此,你只需要计算好偏移量就行了\N{\ren}so all you have to determine is the actual difference
Dialogue: 0,0:34:31.25,0:34:35.63,ch,,0,0,0,,然后把这个偏移量传递给帮助方法即可.不过,由于RecyclerView\N{\ren}and then just passed that into the method but because recycler view doesn't
Dialogue: 0,0:34:35.63,0:34:37.28,ch,,0,0,0,,对其孩子视图的布局是一无所知的,\N{\ren}really know how your layout looks
Dialogue: 0,0:34:37.28,0:34:41.76,ch,,0,0,0,,一旦当前attach的视图被移动了,就可能生成Gap,因此这就需要\N{\ren}once the views have been moved you may have created a gap so it's up to you
Dialogue: 0,0:34:41.76,0:34:47.24,ch,,0,0,0,,那么处理gap方法是?再运行一次现成的fill方法即可.\N在我的例子里\N{\ren}to go back and run another fill(),oK now in my implementation and you can look at the details
Dialogue: 0,0:34:47.24,0:34:51.22,ch,,0,0,0,,(你可以去github看),我的实现实际上为fill提供了\N{\ren}in the example on github.but in my implementation I actually provided
Dialogue: 0,0:34:51.22,0:34:57.10,ch,,0,0,0,,额外的direction参数,以此来辅助\N{\ren}direction keyword back to the fill,just to help sort of assist when I needed to shift my
Dialogue: 0,0:34:57.10,0:35:00.88,ch,,0,0,0,,我对positions的前移或后移,\N到底是前移还是后移这要看当前视图的滚动状态\N{\ren}my positions backwards or forward based on which way this scrolling was going on
Dialogue: 0,0:35:00.88,0:35:04.78,ch,,0,0,0,,这里的direction并不是我所描述的fill技巧所必需的,\N{\ren}that's not really required in the technique that I'm describing it just
Dialogue: 0,0:35:04.78,0:35:08.13,ch,,0,0,0,,这仅仅是方便我的视图二维滚动而已\N{\ren}it was helpful for my bidirectional scrolling
Dialogue: 0,0:35:08.13,0:35:11.86,ch,,0,0,0,,你也可以根据你的fill算法,来传入你所需的额外参数\N{\ren}but it it's not really part of,its whatever your algorithm needs
Dialogue: 0,0:35:11.86,0:35:16.74,ch,,0,0,0,,以便你能让你的算法效率最高\N{\ren}you know to be able to do that in the most efficient way
Dialogue: 0,0:35:16.74,0:35:19.96,ch,,0,0,0,,这里的返回值\N{\ren}okay and then as I mention the return value their
Dialogue: 0,0:35:19.96,0:35:23.85,ch,,0,0,0,,必须是你实际滚动值的负值\N{\ren}has to be the difference of what was actually scrolled
Dialogue: 0,0:35:23.85,0:35:27.79,ch,,0,0,0,,如果你直接返回dx,那么视图的滚动就不会被停止\N{\ren}if you just take this and you just return dx you'll never end up scrolling
Dialogue: 0,0:35:27.79,0:35:31.50,ch,,0,0,0,,而如果你老是返回0,那么任何时候你尝试去滚动时,\N视图都不会被滚动\N{\ren}and if you always return 0 never scroll at all anytime you try to scroll you'll
Dialogue: 0,0:35:31.50,0:35:33.39,ch,,0,0,0,,你会老是看到边缘被拉起而产生的发光效果\N{\ren}just get infinity edge glows all the time
Dialogue: 0,0:35:33.39,0:35:38.06,ch,,0,0,0,,因此,你必须得详细的在代码中体现出你何时能移动,何时不能\N{\ren}okay so you have to be very specific about when you can and when you can't move
Dialogue: 0,0:35:38.06,0:35:41.16,ch,,0,0,0,,这取决于你是否滚动到了你的列表内容的边界\N{\ren}based on whether or not you've hit a boundary of your content
Dialogue: 0,0:35:44.40,0:35:45.57,ch,,0,0,0,,在最低程度上,\N{\ren}at a minimum
Dialogue: 0,0:35:45.57,0:35:49.71,ch,,0,0,0,,这就行了.这些就是你要干的全部事情了,\N这些能保证你获取到一个能工作得起来的\N{\ren}that's it.that's all you really need to implement to get a working
Dialogue: 0,0:35:49.71,0:35:53.77,ch,,0,0,0,,布局管理器了.它能帮你把视图布局出来,\N还能让你对视图进行移动\N{\ren}layout managers something that will lay views out you can move them around
Dialogue: 0,0:35:53.77,0:35:57.06,ch,,0,0,0,,从用户交互的视角来看,所有你能期望得到的,它都能帮你满足\N{\ren}you know all the things you would expect from user interaction perspective
Dialogue: 0,0:35:57.06,0:36:00.35,ch,,0,0,0,,尽管我们还有一些额外的特性可以加进来,\N这些特性也是之后我们应该加的\N{\ren}other additional features you can add and probably should add
Dialogue: 0,0:36:00.35,0:36:04.24,ch,,0,0,0,,但是,我刚讲的是基础.就算你只做到最低程度,那么你起码可以\N{\ren}overtime but thats sort of the basics,like even get that far you can at least
Dialogue: 0,0:36:04.24,0:36:09.22,ch,,0,0,0,,来检验出你的算法是否能工作以及你的布局功能是否管用等等\N{\ren}determine if your algorithm works and your layout functionalities are okay and all that sort of thing I
Dialogue: 0,0:36:09.22,0:36:12.32,ch,,0,0,0,,干完基本的事情之后呢,如果你还有额外的时间的话\N{\ren}the next step if you have additional time is
Dialogue: 0,0:36:12.32,0:36:15.39,ch,,0,0,0,,通常地,我们还需要让布局管理器能对数据集变化做响应\N{\ren}typically to start reacting to dataset changes
Dialogue: 0,0:36:15.39,0:36:19.39,ch,,0,0,0,,实际上,这里我们的工作量并没有很多,\N大多数的工作framework都内置实现了\N{\ren}there're really not a whole lot of work to do here.most of it is built right in but
Dialogue: 0,0:36:19.39,0:36:22.94,ch,,0,0,0,,但是有个一方法叫做onAdapterChanged\N{\ren}there is one additional method here called on adapter changed
Dialogue: 0,0:36:22.94,0:36:25.95,ch,,0,0,0,,你可以在里面做一些优化的工作\N{\ren}that you can provide some optimizations inside of
Dialogue: 0,0:36:25.95,0:36:30.45,ch,,0,0,0,,其实你不必非要重写这个方法,但是重写会有更多的益处.\N这方法被触发时机是\N{\ren}you don't have to override this but it can be helpful.this will be triggered
Dialogue: 0,0:36:30.45,0:36:34.65,ch,,0,0,0,,当RecyclerView被提供一个完全不同的Adapter的时候\N{\ren}if the recycler view ever is provided with a completely different
Dialogue: 0,0:36:34.65,0:36:38.92,ch,,0,0,0,,因此,当某人再次调用setAdapter且传入的数据集不同时,\N{\ren}adapter instance so if they call said adapter again with some
Dialogue: 0,0:36:38.92,0:36:42.45,ch,,0,0,0,,onAdapterChanged就会在LayoutManager里面被调用\N{\ren}other object,then this will be called in the layout manager
Dialogue: 0,0:36:42.45,0:36:45.51,ch,,0,0,0,,此时,你就可以利用这个调用,来进行一些优化操作\N{\ren}and you can use that as an optimization opportunity
Dialogue: 0,0:36:45.51,0:36:49.92,ch,,0,0,0,,做法很简单,就是把当前的视图全清空.\N要注意,我并不是把视图丢给recycler\N{\ren}to simply clear all the views,now notice I'm not tossing them to the recycler
Dialogue: 0,0:36:49.92,0:36:53.70,ch,,0,0,0,,而是想把视图给全部移除掉.这样做是根据下面的假设\N{\ren}I just want them removed completely.the assumption here is that
Dialogue: 0,0:36:53.70,0:36:57.64,ch,,0,0,0,,如果设置了一个完全不同的adapter,\N那么我们的数据集肯定也完全不同了\N{\ren}if we're getting a completely new adapter it's definitely new data
Dialogue: 0,0:36:57.64,0:37:00.97,ch,,0,0,0,,还有视图类型也可能会是新的,因此这里并不需要\N{\ren}and it's probably gonna be new view types as well,so there's no need
Dialogue: 0,0:37:00.97,0:37:04.14,ch,,0,0,0,,我来把所有视图都丢给recycler,因为就算丢给recycler,\N{\ren}for me to dump everything I have into the recycler,coz this just going to end up
Dialogue: 0,0:37:04.14,0:37:06.06,ch,,0,0,0,,它之后也会将这个视图给进行清空的\N{\ren}having a toss those away later anyway
Dialogue: 0,0:37:06.06,0:37:10.72,ch,,0,0,0,,并不是说如果不干这件事,就会引起崩溃.\N而是说我们可以在这儿做优化\N{\ren}it's not that we would break if it did that but we can optimize that out
Dialogue: 0,0:37:10.72,0:37:13.99,ch,,0,0,0,,一旦发现adapter有改变,就把所有视图给移除\N{\ren}by saying if the adapter changes,just remove everything
Dialogue: 0,0:37:13.99,0:37:16.66,城之内,,0,0,0,,{\an8}注:(humorous) A phrase telling someone to pursue a path directly without deviations."
Dialogue: 0,0:37:13.99,0:37:16.66,ch,,0,0,0,,不用再传给recycler了,这样就会显得太死搬硬套了\N{\ren}by pass the recycler,don't collect two hundred dollars.
Dialogue: 0,0:37:18.74,0:37:21.88,ch,,0,0,0,,我们都知道在Adapter中的notifyDataSetChanged方法\N{\ren}now we all know notify dataset change on an adapter,right
Dialogue: 0,0:37:21.88,0:37:26.26,ch,,0,0,0,,如果adapter中的数据改变了,我们就出发这个方法来更新界面\N{\ren}if something has changed in the data we trigger this method to update the view
Dialogue: 0,0:37:26.26,0:37:29.84,ch,,0,0,0,,在ListView中是这么干的,在RecyclerView也仍然存在\N{\ren}right it was that way in listview still exists in recycler view
Dialogue: 0,0:37:29.84,0:37:34.47,ch,,0,0,0,,如果是做一个基础的实现的话,你并不需要干其他工作\N{\ren}at a base implementation you don't have to do anything different here
Dialogue: 0,0:37:34.47,0:37:38.37,ch,,0,0,0,,RecyclerView中的notifyDatasetChanged\N仅会触发一个新的布局改变\N{\ren}notify dataset change just triggers a new layout change
Dialogue: 0,0:37:38.37,0:37:41.90,ch,,0,0,0,,此时,再一次,如果你的fill方法写得好的话,\N你就啥也不用干,等着布局管理器帮你重新布局即可\N{\ren}and if your fill again is set up appropriately you just relayout
Dialogue: 0,0:37:41.90,0:37:47.90,ch,,0,0,0,,依赖这种实现方式,你可能唯一想干的事儿是\N{\ren}right the only thing you might want to persist in this sort of implementation dependent is
Dialogue: 0,0:37:47.90,0:37:53.35,ch,,0,0,0,,对于adapter的改变,你可能想让第一个可见视图的position持续存在\N{\ren}for an adapter change you might wanna persist with the current first position was
Dialogue: 0,0:37:53.35,0:37:58.01,ch,,0,0,0,,因此在你运行fill之前,你可能需要先找到这个位置.不过,再一次,\N{\ren}so you may want to discover that before you run your fill.but again depending on
Dialogue: 0,0:37:58.01,0:38:00.78,ch,,0,0,0,,取决于你对fill的实现,你可能在fill里面已做过找位置这事了\N{\ren}how you've written your fill you're probably already doing that anyway
Dialogue: 0,0:38:00.78,0:38:05.96,ch,,0,0,0,,因此,布局管理器兴许就能尝试着对新数据进行布局\N且其开始布局的位置会跟之前一样\N{\ren}so they can attempt with the new data to lay out from the same first visible position
Dialogue: 0,0:38:05.96,0:38:10.42,ch,,0,0,0,,但是,如果你有视图被丢弃过的话,或其他类似的事情有发生的话,\N{\ren}okay but if you toss those away already or something like that
Dialogue: 0,0:38:10.44,0:38:12.54,ch,,0,0,0,,那么你可能就需要对这个位置值做追踪\N{\ren}you may want to track that value
Dialogue: 0,0:38:12.54,0:38:15.90,ch,,0,0,0,,直到新的布局开始或类似的事情发生即可\N{\ren}just very briefly until the new layout comes around or something like that
Dialogue: 0,0:38:15.90,0:38:18.90,ch,,0,0,0,,否则的话,你就要从初始位置开始布局了,布局管理器仍然可以工作\N{\ren}otherwise you could just lay it out from the beginning,it would still work
Dialogue: 0,0:38:18.90,0:38:24.50,ch,,0,0,0,,有一点需要你在意的是,如果你的adapter设置成了固定id的话\N{\ren}the one caveat to this is that if your adapter has stable ids
Dialogue: 0,0:38:24.50,0:38:28.76,ch,,0,0,0,,RecyclerView就假定你在此时是有足够的数据\N{\ren}recycler view assumes at that point that it actually has enough data to
Dialogue: 0,0:38:28.76,0:38:30.23,ch,,0,0,0,,来对布局变化尝试着进行动画\N{\ren}try and animate the change
Dialogue: 0,0:38:30.23,0:38:34.79,ch,,0,0,0,,因此调用notifyDatasetChanged会触发新的动画序列\N{\ren}and so calling notify dataset changed will trigger an animation sequence
Dialogue: 0,0:38:34.79,0:38:39.08,ch,,0,0,0,,一会咱们就要谈到animations啦,\N但是如果你的adapter没有固定id的话\N{\ren}and we'll talk about animations a little bit later but if you if your adapter doesn't do that
Dialogue: 0,0:38:39.08,0:38:43.23,ch,,0,0,0,,那仅仅就是进行一次一般的布局而已.以此来适应新的数据集\N{\ren}this will just be a snap layout.it'll adjust to the new data
Dialogue: 0,0:38:43.23,0:38:46.64,ch,,0,0,0,,\N{\ren}alright
Dialogue: 0,0:38:46.64,0:38:49.16,ch,,0,0,0,,如果前边的活干完后,咱手头里恰好还留有点时间的话\N{\ren}well let's say that we happen to have a little bit more extra time on our hands
Dialogue: 0,0:38:49.16,0:38:52.20,ch,,0,0,0,,咱还想要搞点别的的东西放入到布局管理器中\N{\ren}we want to get a little bit more fancy with this functionality
Dialogue: 0,0:38:52.20,0:38:56.01,ch,,0,0,0,,那么,接下来我们能加入到manager中的特性就是\N让RecyclerView可随意滚动到目标位置\N{\ren}the next feature that we could add to our manager is target scrolling
Dialogue: 0,0:38:56.01,0:39:00.19,ch,,0,0,0,,像这种外部的APIs\N{\ren}so the external APIs for allowing
Dialogue: 0,0:39:00.19,0:39:04.64,ch,,0,0,0,,这种可以让开发者对视图进行滚动到指定位置的APIs\N其滚动形式不管是立即式的\N{\ren}a developer to scroll your layout to a specific position whether that immediately
Dialogue: 0,0:39:04.64,0:39:09.13,ch,,0,0,0,,还是以某种动画过渡的,这些framework里都没有,\N这就需要你来提供\N{\ren}or in some animated fashion again are not baked and you have to provide some
Dialogue: 0,0:39:09.13,0:39:10.81,ch,,0,0,0,,一些实现,来告诉framework该如何去做\N{\ren}implementation of how that works
Dialogue: 0,0:39:10.81,0:39:14.70,ch,,0,0,0,,因此,对于这种非动画的scrollToPosition方法的实现\N{\ren}so for the scroll to position case which is a non animated case
Dialogue: 0,0:39:14.70,0:39:18.24,ch,,0,0,0,,这种实现可以非常简单.就像我之前提到过的\N{\ren}it can be pretty simple just like in the case I mentioned before
Dialogue: 0,0:39:18.24,0:39:22.17,ch,,0,0,0,,你需要以某种方式追踪到当前被请求的位置是哪个\N{\ren}you would need to track somehow what the requested position was
Dialogue: 0,0:39:22.17,0:39:26.17,ch,,0,0,0,,接下来很简单,调用一下requestLayout即可.\N这会触发一次新的布局\N{\ren}and then just call request layout that will trigger a new layout which will
Dialogue: 0,0:39:26.17,0:39:28.76,ch,,0,0,0,,从而触发可以能做fill操作的onLayoutChildren方法\N{\ren}trigger on layout children which you can just do fill
Dialogue: 0,0:39:28.76,0:39:32.01,ch,,0,0,0,,从这儿你总该看出来了吧,如果你的fill写的好\N{\ren}right.so,you can start to see how if you do your
Dialogue: 0,0:39:32.01,0:39:35.39,ch,,0,0,0,,那么你干任何事都能用到它.你就不必去做很多\N{\ren}fill right it becomes everything to you and you don't have to do a whole
Dialogue: 0,0:39:35.39,0:39:37.13,ch,,0,0,0,,其他的琐碎事情来修饰好RecyclerView啦\N{\ren} lot else to sort of decorate around
Dialogue: 0,0:39:37.13,0:39:43.03,ch,,0,0,0,,为了取得更炫酷的效果,\N我们有这种smoothScrollToPosition方法\N{\ren}oK,to get a little bit more fancy,we have the smooth scroll to position
Dialogue: 0,0:39:43.03,0:39:46.74,ch,,0,0,0,,作为一个开发者,我们会想着让视图\N{\ren}and this is where we would want as a developer we would want the view to
Dialogue: 0,0:39:46.74,0:39:50.76,ch,,0,0,0,,已动画的形式移动到目标位置.\N{\ren}actually animate into place.oK now the
Dialogue: 0,0:39:50.76,0:39:54.17,ch,,0,0,0,,而实现这种功能需要去实现一个\N{\ren}the functionality for doing this requires an implementation of something
Dialogue: 0,0:39:54.17,0:39:57.42,ch,,0,0,0,,被叫做SmoothScroller的帮助类.这个是个由\N{\ren}called a smooth scroller.this is an abstract class provided by the
Dialogue: 0,0:39:57.42,0:40:01.93,ch,,0,0,0,,framework提供的抽象类.你可以重写和新建你自己的实现\N{\ren}by the framework that you can override and create your own implementation
Dialogue: 0,0:40:01.93,0:40:05.21,ch,,0,0,0,,(下)当Scroller对你的视图进行动画和寻找目标位置时,\N{\ren}of essentially what should happen on an incremental basis
Dialogue: 0,0:40:05.21,0:40:08.59,ch,,0,0,0,,(上)来自定义对dx,dy这种增量进行处理\N{\ren}as it animates around your view trying to find the target
Dialogue: 0,0:40:08.59,0:40:12.83,ch,,0,0,0,,这种接口其实还是有点复杂的\N{\ren}oK this interface is actually fairly complex there's
Dialogue: 0,0:40:12.83,0:40:17.33,ch,,0,0,0,,我记得不太清了,\N你可能需要重写5到10个方法才能让其工作起来\N{\ren}I can't remember five to 10 methods that you have to override to make that happen
Dialogue: 0,0:40:17.33,0:40:20.39,ch,,0,0,0,,你当然可以老老实实地这么做\N{\ren}you can certainly do that if you're not a
Dialogue: 0,0:40:20.39,0:40:23.66,ch,,0,0,0,,如果你对framework给出的行为感到不爽的话\N{\ren}if you're not happy with the behavior that the framework gives you
Dialogue: 0,0:40:23.66,0:40:28.03,ch,,0,0,0,,不过这儿的确还存在着一种被称为\NLinearSmoothScroller的实现\N{\ren}but there is an implementation called linear smooth scroller that is provided
Dialogue: 0,0:40:28.03,0:40:33.09,ch,,0,0,0,,其存在于support.v7中,你可以拿来做代替.\N这个类帮我做了大多数的工作\N{\ren}in the support package that you can just take instead.this does most of the work for you
Dialogue: 0,0:40:33.09,0:40:36.59,ch,,0,0,0,,通过提供一种线性的补间动画\N{\ren}by providing a linearly interpolated animation
Dialogue: 0,0:40:36.59,0:40:39.99,ch,,0,0,0,,运行在其往各种目标位置进行移动的路上.\N{\ren}on its way to whatever the target position is and the only piece of
Dialogue: 0,0:40:39.99,0:40:42.19,ch,,0,0,0,,这里你要提供的唯一信息就是\N{\ren}information you have to provide in this case
Dialogue: 0,0:40:42.19,0:40:46.35,ch,,0,0,0,,以坐标系的眼光来看,我们的目标位置在哪.\N{\ren}is where is the target position and that's from a coordinate's perspective
Dialogue: 0,0:40:46.35,0:40:50.85,ch,,0,0,0,,当这个被称为smoothScrollToPosition的方法被调用时\N{\ren}so when this method is called smooth scroll to position you basically
Dialogue: 0,0:40:50.85,0:40:53.89,ch,,0,0,0,,你得搞清楚你现在第一个可视视图的位置是在哪\N{\ren}have to figure out what's the first visible position I have now
Dialogue: 0,0:40:53.89,0:40:59.10,ch,,0,0,0,,还要知道你的目标位置在哪,\N这样你就能算出进行移动的向量了\N{\ren}what's the target that they're trying to get to and then this computation what they call a vector
Dialogue: 0,0:40:59.10,0:41:02.10,ch,,0,0,0,,向量包含了你到达目标位置的方向\N{\ren}on what is the direction that I need to scroll to get there
Dialogue: 0,0:41:02.10,0:41:07.19,ch,,0,0,0,,不管这个方向可能是上,下,左,右,斜,其都必须是个一维的向量\N{\ren}is it left?is it right?is it up?is it down,is it diagonal?but has to be some linear value
Dialogue: 0,0:41:07.19,0:41:12.33,ch,,0,0,0,,通常,由于布局的多种多样的,\N因此你得搞清楚这两个位置之间的真实距离\N{\ren}ok and so you would typically figure out what's the conceptual distance between the two
Dialogue: 0,0:41:12.33,0:41:15.69,ch,,0,0,0,,你可以把你能想到的都放在一起来考虑\N{\ren}based on you know whatever guess you can put together
Dialogue: 0,0:41:15.69,0:41:19.58,ch,,0,0,0,,在我的例子里,所有的孩子视图的大小都是固定的,\N所以我会有一个很准确的猜测\N{\ren}in my case all the views are the same size,so I can have a really good guess
Dialogue: 0,0:41:19.58,0:41:21.92,ch,,0,0,0,,因为我清楚地知道我需要移动多远\N{\ren}because I knew exactly how far i would need to travel
Dialogue: 0,0:41:21.92,0:41:25.16,ch,,0,0,0,,但这并不是必须的.\NScroller并不需要知道要进行移动的精确距离\N{\ren}but that may not necessarily be the case.it doesn't have to be the exact distance
Dialogue: 0,0:41:25.16,0:41:26.75,ch,,0,0,0,,它只需要知道要移动的方向即可\N{\ren}it just has to know the direction
Dialogue: 0,0:41:26.75,0:41:31.31,ch,,0,0,0,,一旦知道了方向和位置,LinearSmoothScroller能开始工作了\N{\ren}and then linear smooth scroller is gonna go through and run an incremental fashion
Dialogue: 0,0:41:31.31,0:41:34.74,ch,,0,0,0,,它会不断地在目的方向上执行动画滚动\N{\ren}they're gonna walk through they're just going to incrementally animate
Dialogue: 0,0:41:34.74,0:41:38.24,ch,,0,0,0,,直到到达目标位置为止\N{\ren}and scroll in whatever direction it needs to get to that position
Dialogue: 0,0:41:38.24,0:41:41.95,ch,,0,0,0,,它的机制就是每滚动出一个新位置上的视图,\N就去检查目标位置的视图是否被布局出来\N{\ren}and it'll scroll can see if it's been laid out scroll again
Dialogue: 0,0:41:41.95,0:41:45.54,ch,,0,0,0,,它会滚动,检查,再滚动,再检查\N{\ren}see if it's been laid out its just gonna hunt and hunt until
Dialogue: 0,0:41:45.54,0:41:49.76,ch,,0,0,0,,直到其感兴趣的位置被layout出来为止.\N{\ren}the position that it's interested in has finally come into the layout.it was just
Dialogue: 0,0:41:49.76,0:41:52.06,ch,,0,0,0,,这个过程会调用你写过的那些scroll方法\N{\ren}going to be triggering your scroll methods that you've already written
Dialogue: 0,0:41:52.06,0:41:55.27,ch,,0,0,0,,直到其找到了目标值,它才会停止滚动\N{\ren}and as soon as it finds that value then it will stop scrolling
Dialogue: 0,0:41:55.27,0:41:59.40,ch,,0,0,0,,直到目标视图在屏幕上完全可见,\N{\ren}once that fully visible on the display at that point then it will just
Dialogue: 0,0:41:59.40,0:42:02.48,ch,,0,0,0,,它才会结束工作.因此,你可以重写SmoothScroller\N{\ren}it'll end.oK so you can override the smooth scroller
Dialogue: 0,0:42:02.48,0:42:06.84,ch,,0,0,0,,然后传给它目标位置,最后只需调用一下startSmoothScroll\N{\ren}set the target position and to just start it and that's really the simplest end
Dialogue: 0,0:42:06.84,0:42:09.00,ch,,0,0,0,,你就完成了最基本的动画滚动视图的实现\N{\ren}of the implementation to animated scrolling
Dialogue: 0,0:42:12.21,0:42:15.90,ch,,0,0,0,,最后一部分,如果你的时间很充裕的话\N{\ren}the last piece if you have a lot extra\Ntime
Dialogue: 0,0:42:15.90,0:42:20.29,ch,,0,0,0,,或者你觉得某些地方还不太满意的话.你可以尝试\N{\ren}and maybe some sanity left you can attempt
Dialogue: 0,0:42:20.29,0:42:23.67,ch,,0,0,0,,去添加一些动画支持.目前,\N{\ren}to add some animation support now out of the box
Dialogue: 0,0:42:23.67,0:42:28.14,ch,,0,0,0,,尽管RecyclerView的确支持被称为\NdefaultItemAnimations的东西\N{\ren}recycler view does support what they called default item animations
Dialogue: 0,0:42:28.18,0:42:31.70,ch,,0,0,0,,利用RecyclerView的新特性,在它上面实现动效不像\N{\ren}what the new features of recycler view that was not easy to
Dialogue: 0,0:42:31.70,0:42:33.59,ch,,0,0,0,,在ListView上那么难,这种新特性就是\N{\ren}implement on something like listview was
Dialogue: 0,0:42:33.59,0:42:37.03,ch,,0,0,0,,不管你对列表项是做插入还是移除或者是做一些视图改变\N{\ren}if you inserted a new item or removed it or made some changes
Dialogue: 0,0:42:37.03,0:42:40.28,ch,,0,0,0,,都可以以一种很美妙的方式来针对这些操作定制动画\N{\ren}animating all that in a nice fancy way for the user
Dialogue: 0,0:42:40.28,0:42:44.83,ch,,0,0,0,,像framework里的核心布局管理器类(LLM,GLM,SGLM等)\N{\ren}the functionality with all the core layout managers
Dialogue: 0,0:42:44.83,0:42:48.42,ch,,0,0,0,,其作用是提供一种很基础的算法来支持ItemAnimator\N{\ren}is to provide a very basic algorithm for that out of the box
Dialogue: 0,0:42:48.42,0:42:51.54,ch,,0,0,0,,我一会儿会向你展示核心布局管理器的动画,\N但我要先给大家讲下其原理\N{\ren}and I have an animation to show you what that looks like but essentially
Dialogue: 0,0:42:51.54,0:42:52.69,ch,,0,0,0,,布局管理器会对视图进行监测\N{\ren}it just looks at the views
Dialogue: 0,0:42:52.69,0:42:57.35,ch,,0,0,0,,它会观察列表项被操作前后的变化,然后尝试根据\N{\ren}looks at the change before and after and then tries to determine based on
Dialogue: 0,0:42:57.35,0:42:59.69,ch,,0,0,0,,前后布局的快照来决定\N{\ren}this layout and this layout in the two snapshots
Dialogue: 0,0:42:59.69,0:43:03.76,ch,,0,0,0,,哪些视图不见了,哪些视图是新增的,\N以及哪些视图是被移动过了的\N{\ren}what views have gone away,what views are new and what views are moved around
Dialogue: 0,0:43:03.76,0:43:07.09,ch,,0,0,0,,它就会把老的视图给淡出,新的视图给淡入以及\N{\ren}and it will fade out the old views,fade in the new views and
Dialogue: 0,0:43:07.09,0:43:10.20,ch,,0,0,0,,对其他还在屏幕上的视图进行平移\N{\ren}simply translate the other ones on screen okay
Dialogue: 0,0:43:10.20,0:43:14.08,ch,,0,0,0,,在大多数情况下,这种实现工作的非常好.\N但是你会发现\N{\ren}and in a lot cases it does a pretty good job but you'll see there are some
Dialogue: 0,0:43:14.08,0:43:17.78,ch,,0,0,0,,当你在做自定义布局管理器时,\N采用了这种免费的动画的话,这儿会存在一些问题\N{\ren}problems with what you get for free if you're doing a custom layout because you
Dialogue: 0,0:43:17.78,0:43:23.22,ch,,0,0,0,,你可能想要把某些视图给移出屏幕,\N因为这些视图不属于当前位置了\N{\ren}may be animating views off screen that because they're no longer there the default
Dialogue: 0,0:43:23.22,0:43:25.33,ch,,0,0,0,,默认的动画实现就会认为这些视图已经消失了\N{\ren}animation just thinks they've disappeared
Dialogue: 0,0:43:25.33,0:43:27.94,ch,,0,0,0,,因此会把这些视图给淡出掉而不是优雅地将它们移动到\N{\ren}so it fades them out instead of gracefully moving them
Dialogue: 0,0:43:27.96,0:43:30.33,ch,,0,0,0,,其在概念上来讲,应该所处的位置上\N{\ren}to where they conceptually were supposed to go
Dialogue: 0,0:43:30.33,0:43:35.58,ch,,0,0,0,,接下来,哥就教你如何让布局管理器来支持这种优雅的动画\N{\ren}ok.and so we'll take a look at what you need to do to sort of provide that
Dialogue: 0,0:43:35.58,0:43:40.29,ch,,0,0,0,,这在android里面其实被称为predictive列表项动画\N如果你想要\N{\ren}so android calls that predictive item animations and if you want to support
Dialogue: 0,0:43:40.29,0:43:41.54,ch,,0,0,0,,在你的布局管理器中支持它的话\N{\ren}that in your layout manager
Dialogue: 0,0:43:41.54,0:43:46.38,ch,,0,0,0,,那么你只需要告诉布局管理器即可.\N在supportsPredictiveItemAnimations中返回true即可\N{\ren}you just have to tell them.to say yes I support predictive animations return true from this method
Dialogue: 0,0:43:46.38,0:43:49.74,ch,,0,0,0,,这样做会稍微改变一下你布局管理器的布局行为\N{\ren}and this will change your layout behavior just a little bit
Dialogue: 0,0:43:49.74,0:43:54.35,ch,,0,0,0,,这种情况下,每当有列表项改变时,都将成为一个触发点\N{\ren}in this case anytime an item change is triggered
Dialogue: 0,0:43:54.35,0:43:57.61,ch,,0,0,0,,现在,我们的初始化布局还是跟从前一样\N{\ren}now for an initial layout or anything like that still gonna be the same
Dialogue: 0,0:43:57.61,0:44:01.18,ch,,0,0,0,,但是当你移除或者添加列表项等等类似的操作时\N{\ren}but you remove an item or you insert an item something like that
Dialogue: 0,0:44:01.22,0:44:04.06,ch,,0,0,0,,在这个item仍是可见的时候\N{\ren}and that item is visible at the moment
Dialogue: 0,0:44:04.06,0:44:08.82,ch,,0,0,0,,那么,实际上,布局的过程就变成两条通路\N{\ren}then the layout process actually becomes a two pass layout
Dialogue: 0,0:44:08.82,0:44:13.98,ch,,0,0,0,,它会在被称为preLayout的状态下,\N首先调用onLayoutChildren\N{\ren}it calls on layout children first in what they called the pre layout state
Dialogue: 0,0:44:13.98,0:44:18.19,ch,,0,0,0,,这个状态下,\N布局管理器中的所有视图和适配器中的所有数据\N{\ren}this is a state where all the views all the data from the adapter
Dialogue: 0,0:44:18.19,0:44:22.23,ch,,0,0,0,,都被处理成\N{\ren}is massaged such that it looks the way it would have looked
Dialogue: 0,0:44:22.23,0:44:26.47,ch,,0,0,0,,item变化前的状态.\N因此,这儿为你提供了一个机会来执行一次layout pass\N{\ren}before the change this gives you an opportunity to run a layout pass
Dialogue: 0,0:44:26.47,0:44:29.72,ch,,0,0,0,,这个layout pass就被称为\N对布局前的视图快照的preLayout\N{\ren}in what they call the pre layout of the the initial snapshot
Dialogue: 0,0:44:29.72,0:44:34.34,ch,,0,0,0,,以屏幕上的视图的观点来看,这意味着\N{\ren}oK,so from the views on screen perspective this means you just
Dialogue: 0,0:44:34.34,0:44:37.66,ch,,0,0,0,,你只需要运行一次你fill方法即可,但是你可能还需要\N{\ren}run your traditional fill but you might need to
Dialogue: 0,0:44:37.66,0:44:41.93,ch,,0,0,0,,对被移除屏幕的视图做记录,因为如果有视图被移除屏幕\N{\ren}make note if any of the views that were on screen were removed
Dialogue: 0,0:44:41.93,0:44:47.25,ch,,0,0,0,,你就需要对gap进行填充,\N如果此时你让默认的动画来干活的话\N{\ren}you've got gaps to fill and if you just let the default animations do their work
Dialogue: 0,0:44:47.25,0:44:51.10,ch,,0,0,0,,在gap出现的时候,它们就开始执行动画了,\N它们就仅仅把新的视图给淡入进来\N{\ren}they will animate until they can see that gap and they'll just fade the new view in
Dialogue: 0,0:44:51.10,0:44:54.61,ch,,0,0,0,,但是,如果你想要达到那种视图滑入槽位的效果的话\N{\ren}but if you wanna make it look like the view actually slides into place
Dialogue: 0,0:44:54.61,0:44:57.66,ch,,0,0,0,,那么你就要在这个layout pass里,\N把槽位上的视图给布局出来\N{\ren}you have to lay it out during this pass
Dialogue: 0,0:44:57.66,0:45:01.30,ch,,0,0,0,,你需要将视图布局在屏幕里其应当进入的位置之上\N{\ren}and you lay it out in the location of screen where it should come from
Dialogue: 0,0:45:01.30,0:45:04.86,ch,,0,0,0,,因此,这些视图称之为appearing视图\N{\ren}ok.so those are what they call appearing views
Dialogue: 0,0:45:04.86,0:45:08.73,ch,,0,0,0,,这些在LayoutParams中为你提供了额外的信息\N{\ren}and they give you additional information on the layout parameters which you can
Dialogue: 0,0:45:08.73,0:45:09.87,ch,,0,0,0,,LayoutParams可以用ViewHolder中获取\N{\ren}get from the view holder
Dialogue: 0,0:45:09.87,0:45:13.95,ch,,0,0,0,,对于每个单独的视图,不管这个视图此时是否真的可见\N{\ren}for each individual view as to whether or not this view that you can see
Dialogue: 0,0:45:13.95,0:45:18.03,ch,,0,0,0,,只要你在LayoutParams.isViewRemoved为真的话,\N在下一次布局时,这个视图就一定会消失掉\N{\ren}has actually been removed and in the next step it's gone and if that's the case
Dialogue: 0,0:45:18.03,0:45:22.20,ch,,0,0,0,,你可能发现此时你有2到3个视图要被移除掉了,\N那么你就要保证\N{\ren}you say wow I've got maybe two or three views that were removed I need to make sure
Dialogue: 0,0:45:22.20,0:45:26.43,ch,,0,0,0,,你能从别处拿来2到3个appearing视图给添加进来\N{\ren}I add two or three appearing views in wherever they should be so that the
Dialogue: 0,0:45:26.43,0:45:29.30,ch,,0,0,0,,这样以来,\Nanimation才会把这些视图以正确的动画形式给带进来\N{\ren}animation brings them in the way they're supposed to look
Dialogue: 0,0:45:29.30,0:45:34.24,ch,,0,0,0,,所以,你该把要被移除的视图给记录下来,\N以便于你的appearing视图来进行利用\N{\ren}okay,so you want to take note of how many are removed so that you can use that for the appearing views
Dialogue: 0,0:45:34.24,0:45:37.60,ch,,0,0,0,,在这里,你通常还会做另一件事\N{\ren}the other thing that you would typically do during this step
Dialogue: 0,0:45:37.60,0:45:41.38,城之内,,0,0,0,,{\an8}注:take stock v. 盘货; 清查存货; 
Dialogue: 0,0:45:37.60,0:45:41.38,ch,,0,0,0,,对在当前布局里的视图进行盘查\N{\ren}is take some stock of what's currently in the layout
Dialogue: 0,0:45:41.38,0:45:45.62,ch,,0,0,0,,为的是在你操作了item之后,你有没有视图\N{\ren}so that after the fact you can determine if any are the views
Dialogue: 0,0:45:45.62,0:45:49.91,ch,,0,0,0,,虽没有被显式的被移除,但其此时已不在当前布局中了\N{\ren}that weren't explicitly removed are no longer in the layout
Dialogue: 0,0:45:50.00,0:45:51.96,ch,,0,0,0,,因为这些视图是被滚出了屏幕.\N{\ren}because they shifted off screen
Dialogue: 0,0:45:52.02,0:45:55.60,ch,,0,0,0,,如果是这种情况的话,你就要在布局的第二个阶段\N{\ren}and if that's the case you need to lay them out during the second phase
Dialogue: 0,0:45:55.66,0:46:00.18,ch,,0,0,0,,也就是我们通常进行布局的阶段,\N把这些视图布局在那些被滚出屏幕的位置之上\N{\ren}which is the the regular layout phase in their off screen positions.ok
Dialogue: 0,0:46:00.18,0:46:03.20,ch,,0,0,0,,因此,在preLayout过程里,你要对appearing视图进行布局\N{\ren}so during pre layout you have to lay out those appearing views
Dialogue: 0,0:46:03.20,0:46:06.55,ch,,0,0,0,,然后把此时的布局快照里面视图的状态给记录下来\N{\ren}and just take note of what the state of that snapshot is
Dialogue: 0,0:46:06.55,0:46:09.48,ch,,0,0,0,,最后,你再来运行一次平常的fill即可\N{\ren}and then run your fill the way you normally would
Dialogue: 0,0:46:09.50,0:46:12.92,ch,,0,0,0,,之后,onLayoutChildren还会被再调用一次\N{\ren}then that method is gonna be called again in this case that
Dialogue: 0,0:46:12.92,0:46:17.17,ch,,0,0,0,,此时,isPreLayout会返回false.\N那么我们的布局过程就跟运行一次fill没啥不同了.\N{\ren}is pre layout is gonna be set to false and this is no different than any other fill
Dialogue: 0,0:46:17.17,0:46:20.64,ch,,0,0,0,,现在,适配器中的位置和数据都被设置成\N{\ren}now all the adapter positions and all the values are set the way they are
Dialogue: 0,0:46:20.64,0:46:23.46,ch,,0,0,0,,变化后的值了.此时你就该把变化后的东西全布局出来了\N{\ren}after the change and you can lay everything out
Dialogue: 0,0:46:23.46,0:46:25.28,ch,,0,0,0,,你就差这最后一步没有走了\N{\ren}and then you just have that final step
Dialogue: 0,0:46:25.28,0:46:29.14,ch,,0,0,0,,你是要对布局管理器说,现在我不需要adapter里的这部分了\N{\ren}of saying ok,at this point I don't need this piece in ...(adapter)
Dialogue: 0,0:46:29.14,0:46:32.40,ch,,0,0,0,,这部分已经不在了,我需要把这些视图给布局出屏幕,\N{\ren}this piece has gone away I need to lay it out off screen
Dialogue: 0,0:46:32.40,0:46:35.14,ch,,0,0,0,,这样视图的动画才能按正确的方向滑入.\N{\ren}so that the animation can slide in the right direction
Dialogue: 0,0:46:35.14,0:46:38.82,ch,,0,0,0,,\N{\ren}ok
Dialogue: 0,0:46:38.82,0:46:43.19,ch,,0,0,0,,让我们快速的浏览一个例子,来领会其中的奥妙\N{\ren}let's take a look at a quick example here you can get an idea there so
Dialogue: 0,0:46:43.19,0:46:47.92,ch,,0,0,0,,现在你的onLayoutChildren方法看起来就变得有点复杂了\N{\ren}now you're on layout children might look a little bit more complicated right
Dialogue: 0,0:46:47.92,0:46:51.27,ch,,0,0,0,,在preLayout时,你需要对LayoutParams中的信息\N{\ren}so during pre layout is where you're going to make that information
Dialogue: 0,0:46:51.27,0:46:54.30,ch,,0,0,0,,进行检查,来得到实际上被移除去的视图\N{\ren}check that information about how many views were actually removed
Dialogue: 0,0:46:54.30,0:46:58.34,ch,,0,0,0,,如果有视图被移除,我就得在这个位置上\N{\ren}were there any,if there was a view removed then I need to account for that
Dialogue: 0,0:46:58.34,0:47:01.89,ch,,0,0,0,,加入一点appearing的逻辑了\N{\ren}by adding some appearing logic so
Dialogue: 0,0:47:01.89,0:47:05.93,ch,,0,0,0,,在我的例子中,我把这事放在fill方法里面了\N{\ren}in in my implementation if you look at the example I added that to the sill
Dialogue: 0,0:47:05.93,0:47:10.81,ch,,0,0,0,,因此会把任何需要加进布局的appearing视图传给fill\N{\ren}so the fill he's also passed if there are any additional appearing view that needs to add
Dialogue: 0,0:47:10.81,0:47:14.26,ch,,0,0,0,,在fill里对这些视图进行另外的布局,以使其将来会被看到\N{\ren}and it lays those out in addition to what would (otherwise) be able to see
Dialogue: 0,0:47:14.26,0:47:18.10,ch,,0,0,0,,好吧,我刚说的就是fill中比较隐晦的地方了.与这类似的\N{\ren}okay so that's kind of hidden in here and similarly
Dialogue: 0,0:47:18.10,0:47:21.18,ch,,0,0,0,,我们可以在preLayout之后,也就是我们\N{\ren}we can look after pre layout after we've
Dialogue: 0,0:47:21.18,0:47:26.08,ch,,0,0,0,,真正完成fill方法之后,我们可以对Scrap表进行检查\N{\ren}done our fill for real and we can check that scrap list again and say
Dialogue: 0,0:47:26.08,0:47:27.68,ch,,0,0,0,,是否Scrap中还有剩余的视图\N{\ren}was there anything that was left in scrap
Dialogue: 0,0:47:27.68,0:47:32.78,ch,,0,0,0,,如果还有的话,这些视图其实就是disappearing视图,\N它们没有被移除掉(只是不在当前屏幕上显示而已)\N{\ren}if there was then those are actually disappearing views,they weren't removed
Dialogue: 0,0:47:32.78,0:47:36.20,ch,,0,0,0,,因此,对这些视图,我们也要对其再进行一次布局\N{\ren}or and they...you anything like that so we\Nlay them out again
Dialogue: 0,0:47:36.20,0:47:40.88,ch,,0,0,0,,你可以再运行一次fill.但是更简单的是你可以抽象出\N{\ren}so you you could run a fill what's usually easier is just too abstract that
Dialogue: 0,0:47:40.88,0:47:43.67,ch,,0,0,0,,这种布局逻辑,封装成函数,传入特定的视图再次调用即可\N{\ren}layout logic and call it again for that specific view
Dialogue: 0,0:47:43.67,0:47:46.08,ch,,0,0,0,,同时,你得明白,这个操作是针对移出屏幕的视图进行的\N{\ren}and figure out this is where the view should be off screen
Dialogue: 0,0:47:47.06,0:47:51.74,ch,,0,0,0,,现在,我会快速地向你展示这里的不同之处.\N{\ren}alright,so just quickly,i will show you what that difference looks like
Dialogue: 0,0:47:51.74,0:47:56.16,ch,,0,0,0,,如果将defaultItemAnimation应用到我的例子里的话\N{\ren}ok,so with default item animations on the example that I had
Dialogue: 0,0:47:56.16,0:47:59.94,ch,,0,0,0,,达到的效果就是你现在所见到的,你能清楚的知道这并不符合\N{\ren}this is kind of what you get and you can you can see how it's not exactly what we
Dialogue: 0,0:47:59.94,0:48:02.28,ch,,0,0,0,,我们所期望的优雅动画的要求.这儿的红色视图\N{\ren}were looking for. so in this case the red view
Dialogue: 0,0:48:02.28,0:48:05.70,ch,,0,0,0,,是我们将要移除的视图,绿色视图是\N{\ren}is the one we're going to remove and the green views are the ones that should
Dialogue: 0,0:48:05.70,0:48:08.77,ch,,0,0,0,,将要进行位置转换的视图,但它们的做法并不符合我们的想法\N{\ren}shift location but they don't quite do what they're supposed to
Dialogue: 0,0:48:08.77,0:48:12.33,ch,,0,0,0,,当我们移除掉这个红色的视图时,这儿所发生的事情就是\N{\ren}right so when we remove this view what happens is that
Dialogue: 0,0:48:12.33,0:48:15.55,ch,,0,0,0,,所有在左边的视图也都淡出了\N{\ren}all the views on the left also fade out
Dialogue: 0,0:48:15.55,0:48:19.17,ch,,0,0,0,,然后它们会在其新位置上淡入\N{\ren}and then they fade in in their new locations
Dialogue: 0,0:48:19.17,0:48:22.40,ch,,0,0,0,,这就是因为RecyclerView对视图的动画形式是一无所知的\N{\ren}and that's because the recycler view doesn't know any better
Dialogue: 0,0:48:22.40,0:48:25.68,ch,,0,0,0,,它只知道在preLayout之后,这些视图就不在原来位置上了\N{\ren}it just knows that after pre layout they weren't there anymore
Dialogue: 0,0:48:25.68,0:48:29.18,ch,,0,0,0,,当我对视图滚动时,\N我能看到这些视图实际上还存在于RecyclerView中\N{\ren}and then when I scroll over to see where they actually are
Dialogue: 0,0:48:29.18,0:48:34.01,ch,,0,0,0,,它们会在新的layout中出现.如何来修正这个问题呢,\N我们要通过添加对predictive动画支持的属性\N{\ren}they'll show up there in the new layout.ok by adding proper predictive animation support
Dialogue: 0,0:48:34.01,0:48:39.02,ch,,0,0,0,,这样我才能修改其默认的动画行为,\N在我的例子中也是通过这种方法来实现的\N{\ren}I can modify that behavior and again this is the way the example actually works if you go run it
Dialogue: 0,0:48:39.02,0:48:42.99,ch,,0,0,0,,我可以改变其行为,这样以来,这些绿的视图就会\N{\ren}I can modify their behaviors so that those green views
Dialogue: 0,0:48:42.99,0:48:47.36,ch,,0,0,0,,沿着既定的方向滑出屏幕到其应该所处的位置上\N{\ren}slide off screen to where they're supposed to go into that direction.
Dialogue: 0,0:48:47.36,0:48:50.33,ch,,0,0,0,,在用户的屏幕上,我们可能只能看到这些视图\N{\ren}now from the user screen they'll probably just slide
Dialogue: 0,0:48:50.33,0:48:53.78,ch,,0,0,0,,移出屏幕而已,除非你有足够大的显示屏能容纳下所有视图\N{\ren}off screen unless there is a large enough display for them might see the whole thing
Dialogue: 0,0:48:53.78,0:48:56.78,ch,,0,0,0,,在我们这个例子中\N{\ren}but in that case they actually
Dialogue: 0,0:48:56.78,0:49:01.21,ch,,0,0,0,,我们这么做的好处在于我们能让用户看到视图是如何移走的\N{\ren}that you get the benefit of the user seeing where they should go
Dialogue: 0,0:49:01.21,0:49:05.34,ch,,0,0,0,,因此,当用户要去滚动查找这些视图时,\N会发现视图的确是在那里的\N{\ren}so that when they scroll over they're actually there,right.it's that idea of
Dialogue: 0,0:49:05.34,0:49:09.72,ch,,0,0,0,,这可谓把通过用动画引导用户操作的思想给运用得淋漓尽致了\N{\ren}teaching the user how things are supposed to go by animating them to the proper locations
Dialogue: 0,0:49:09.72,0:49:13.51,ch,,0,0,0,,如果对这些视图采用淡出动画的话,\N用户就可能认为这些视图被移除了,而实际上并没有\N{\ren}if they just all fade out,they might think they remove them all which is not correct
Dialogue: 0,0:49:13.51,0:49:19.01,ch,,0,0,0,,因此,这就是实现predictiveItemAnimation的背后思想\N{\ren}ok.so that's the idea behind implementing predictive item animations to give you some better info
Dialogue: 0,0:49:19.01,0:49:22.33,ch,,0,0,0,,\N{\ren}okay so
Dialogue: 0,0:49:22.33,0:49:26.11,ch,,0,0,0,,我再给大家提供一点关于RecyclerView Layout的相关信息\N{\ren}just a couple more pieces of information to wrap up here so
Dialogue: 0,0:49:26.11,0:49:30.09,ch,,0,0,0,,我们刚谈论到的例子在我的github页面上\N{\ren}the example that I've been discussing here I is on my github page
Dialogue: 0,0:49:30.09,0:49:34.70,ch,,0,0,0,,我的那个应用里面还有一些其他的关于FGLM的基本用例\N{\ren}that application also has a few other basic samples in it for using the grid
Dialogue: 0,0:49:34.70,0:49:38.59,ch,,0,0,0,,以及等等类似的东西,不过你放心,里面有着完整的\N{\ren}layout managers and things like that but it has the full source code for that fixed
Dialogue: 0,0:49:38.59,0:49:41.15,ch,,0,0,0,,FGLM实现的源码.你可以研究其中所有\N{\ren}grid implementations you can dive into all the
Dialogue: 0,0:49:41.15,0:49:45.91,ch,,0,0,0,,你感兴趣的地方.同时,我还写了一系列相当\N{\ren}(hairy) details if you're interested.I also went through a series a fairly
Dialogue: 0,0:49:45.91,0:49:48.74,ch,,0,0,0,,详细的博客,在我构建这个布局管理器的时候\N{\ren}detailed blog posts as I was building that thing
Dialogue: 0,0:49:48.74,0:49:52.65,ch,,0,0,0,,所以,如果你对我在做这个东西的时候抓掉了多少头发感兴趣的话\N{\ren}so if you wanna get a sense for how much hair i actually tore out while doing this
Dialogue: 0,0:49:52.65,0:49:53.97,ch,,0,0,0,,你可以把我的博客也过一遍\N{\ren}you can go through and read that
Dialogue: 0,0:49:53.97,0:49:59.08,ch,,0,0,0,,具体来讲,如果你要做的布局管理器跟我这种相类似的话\N{\ren}specifically if you're doing anything similar to what I did with that
Dialogue: 0,0:49:59.08,0:50:03.27,ch,,0,0,0,,都是这种间断区间的grid,你在屏幕上所看到的\N{\ren}that sort of disconnected range where the grid and what you're seeing
Dialogue: 0,0:50:03.27,0:50:07.04,ch,,0,0,0,,仅仅是整体布局的一个子集,以及这些视图的位置\N{\ren}is actually just a subset of the overall layout but the views that are in between
Dialogue: 0,0:50:07.04,0:50:09.10,ch,,0,0,0,,处于是区间中间\N{\ren}are actually in the middle of the range
Dialogue: 0,0:50:09.10,0:50:11.18,ch,,0,0,0,,如果是这种非线性的一维的布局的话\N{\ren}which you wouldn't typically have with the linear
Dialogue: 0,0:50:11.24,0:50:13.46,ch,,0,0,0,,那么你可能就需要去读一读我系列里的最后一篇文章了\N{\ren}you might want to read the last blog post
Dialogue: 0,0:50:13.50,0:50:16.71,ch,,0,0,0,,我称这篇文章为Redux篇,我在其中讨论的一些\N{\ren}that I call the redux where I actually discuss some other bugs and
Dialogue: 0,0:50:16.71,0:50:21.70,ch,,0,0,0,,Layout Manager API的bugs,\N这些bug为这种布局管理器的实现又增加了难度\N{\ren}issues with the layout manager API that actually makes that implementation much more difficult than it should be
Dialogue: 0,0:50:21.70,0:50:24.22,ch,,0,0,0,,以及其他一些为解决bug而要求你所做的事情.\N{\ren}and some other things you have to do to work around that.
Dialogue: 0,0:50:24.22,0:50:26.42,ch,,0,0,0,,不过,如果你是在做一种更简单的实现的话\N{\ren}if you're doing a much more simpler implementation
Dialogue: 0,0:50:26.44,0:50:29.70,ch,,0,0,0,,如果其只是在一个坐标轴上布局的话,\N那就不存在这种间断的问题了\N{\ren}that's either single axis doesn't have that disconnection problem
Dialogue: 0,0:50:29.70,0:50:33.73,ch,,0,0,0,,你可能不会遇到这种问题,但是读读文章还是会很有收益的\N{\ren}then you won't have any issues like that but it might be an interesting read
Dialogue: 0,0:50:33.73,0:50:36.69,ch,,0,0,0,,除此之外呢,SDK的文档也是写的很好的,\N{\ren}and then the SDK also has some pretty good documentation on just getting you
Dialogue: 0,0:50:36.74,0:50:39.88,ch,,0,0,0,,能使你快速上手RecyclerView\N{\ren}started with recycler view there.
Dialogue: 0,0:50:39.88,0:50:40.34,ch,,0,0,0,,\N{\ren}okay
Dialogue: 0,0:50:40.34,0:50:43.67,ch,,0,0,0,,我看了下时间,我不知道我们是否会有\N{\ren}so looking at the time I don't know do we have
Dialogue: 0,0:50:43.67,0:50:45.18,ch,,0,0,0,,时间来留给大家提问.\N{\ren}any time for questions
Dialogue: 0,0:50:47.28,0:50:52.99,ch,,0,0,0,,噢,有一点时间空余.因此现在我接受一些问题的提问,\N等时间到了,如果还有更多问题的话,我们台下解决.\N{\ren}couple,okay.we will take a couple questions and then if there anymore we'll kind of walk out stage.
Dialogue: 0,0:50:52.99,0:50:57.06,ch,,0,0,0,,好,那位我最先看到\N{\ren}I saw him first up
Dialogue: 0,0:51:16.30,0:51:18.29,ch,,0,0,0,,你所说的并不影响Decorators\N{\ren}what you mean by they don't affect the decorators
Dialogue: 0,0:51:33.73,0:51:34.99,ch,,0,0,0,,正确\N{\ren}that's correct
Dialogue: 0,0:51:34.99,0:51:40.05,ch,,0,0,0,,取决于你如何实现你的Decorators{\ren}the the information,depending on how you implement the actual decorator
Dialogue: 0,0:51:40.05,0:51:44.23,ch,,0,0,0,,如果你在Decorator里采用孩子的高度或宽度这些信息\N{\ren}if you're using that information of basically what's the height or the width
Dialogue: 0,0:51:44.23,0:51:46.38,ch,,0,0,0,,来给孩子视图画装饰的时候\N{\ren}of the child to know where to draw those lines
Dialogue: 0,0:51:46.38,0:51:49.55,ch,,0,0,0,,这些信息并不会随时更新\N{\ren}that information is not updated incrementally
Dialogue: 0,0:51:49.55,0:51:53.05,ch,,0,0,0,,其只会在初始化的时候进行更新\N{\ren}so it's only gonna be updated when its in its initial state
Dialogue: 0,0:51:53.05,0:51:56.17,ch,,0,0,0,,在列表被操作改变后,它需要给你提供一份新的信息\N{\ren}and then after the change it should give you the new information so
Dialogue: 0,0:51:56.17,0:52:01.22,ch,,0,0,0,,你可能会看到它跳到其合适的位置去,\N但是它不会向你说的那样平移转换\N{\ren}you might see it jump into where its proper position is but it won't transition like that
Dialogue: 0,0:52:01.22,0:52:02.81,ch,,0,0,0,,因为那个信息不会...\N{\ren}because that information is not...
Dialogue: 0,0:52:02.81,0:52:06.34,ch,,0,0,0,,如果我在那个视图上调用getDecoratedHeight的话\N{\ren}if I called again get decorated height on that view
Dialogue: 0,0:52:06.34,0:52:09.52,ch,,0,0,0,,这个值并不会被改变\N{\ren}on each of those instances it's not going to change until the
Dialogue: 0,0:52:09.52,0:52:13.47,ch,,0,0,0,,直到其处在一个新的状态\N{\ren}the value is actually in its new state,cos from that perspective
Dialogue: 0,0:52:13.47,0:52:17.29,ch,,0,0,0,,height本身不是逐渐变化的变量,它只有一个初始状态\N{\ren}the height itself is not incremental it has its initial state and its final
Dialogue: 0,0:52:17.29,0:52:19.15,ch,,0,0,0,,和结束状态,这里唯一改变的就是drawing.\N{\ren}state the only thing that changes is the drawing
Dialogue: 0,0:52:19.15,0:52:23.40,ch,,0,0,0,,因此,你必须通过某种方式去监听到那个事件\N{\ren}so you have to you have to somehow listen for that event
Dialogue: 0,0:52:23.40,0:52:26.47,ch,,0,0,0,,然后试着手动触发它,虽然你可以这么干\N{\ren}and try to trigger it manually which you can do I
Dialogue: 0,0:52:26.47,0:52:31.44,ch,,0,0,0,,但是布局管理器本身\N就提供了这些像列表项插入,删除等等之类的方法\N{\ren}the layout manager does have a handful of methods for on item removed added inserted that sort of thing
Dialogue: 0,0:52:31.44,0:52:34.83,ch,,0,0,0,,这些方法能通知到你有事件发生\N{\ren}that can signal you when that event is occurring
Dialogue: 0,0:52:34.83,0:52:38.40,ch,,0,0,0,,因此把你的动画匹配的相应的事件上去\N{\ren}so that you can try to match it as best as you can with your animation
Dialogue: 0,0:52:38.40,0:52:43.55,ch,,0,0,0,,除此之外,并没有其他办法来直接给你操作反馈在decorator中\N{\ren}but otherwise that yeah, unfortunately it doesn't give you that feedback directly in the decorator
Dialogue: 0,0:52:43.55,0:52:45.32,ch,,0,0,0,,\N{\ren}yes
Dialogue: 0,0:52:46.22,0:52:51.94,ch,,0,0,0,,刚开始的时候,你讲到布局管理器中去存储很多状态是不好的\N{\ren}layout manager very beginning you said that keeping a lot of state is bad
Dialogue: 0,0:52:51.96,0:52:55.83,ch,,0,0,0,,你还举了个例子\N{\ren}given an example of where (state i will be kept),that is good
Dialogue: 0,0:52:55.83,0:52:59.49,ch,,0,0,0,,那是不是布局管理器就要去全方位的保持其无状态的性质呢\N{\ren}should it be aiming to be fully stateless
Dialogue: 0,0:52:59.49,0:53:03.54,ch,,0,0,0,,最好的实践是将追踪的状态控制在可控范围之内\N{\ren}aim to be fully stateless if you can manage it
Dialogue: 0,0:53:03.54,0:53:07.97,ch,,0,0,0,,就拿我的例子来说明好了,在我写的初版中\N{\ren}so I'll give you an example from the way I built it so the initial implementation that i wrote
Dialogue: 0,0:53:07.97,0:53:12.16,ch,,0,0,0,,我对状态的追踪很重,像说第一可见视图的位置\N{\ren}I track very heavily things like the first visible position
Dialogue: 0,0:53:12.16,0:53:15.18,ch,,0,0,0,,以及整个位置的偏移,我总是保持着对这两个状态的追踪\N{\ren}and that position offset and I kept that state around
Dialogue: 0,0:53:15.18,0:53:19.68,ch,,0,0,0,,那当我开始调用datasetChanged的时候,当我从\N{\ren}all the time and when we started doing dataset changes where we went from
Dialogue: 0,0:53:19.68,0:53:23.29,ch,,0,0,0,,一个很大的grid转到一个很小的grid的时候,\N{\ren}like a really large grid to really small grid or something like that
Dialogue: 0,0:53:23.29,0:53:26.53,ch,,0,0,0,,我尝试着还让这两个状态是有效的\N{\ren}trying to assume that value was even valid anymore
Dialogue: 0,0:53:26.53,0:53:29.94,ch,,0,0,0,,这导致我写了很多if语句.如果我是把视图\N{\ren}lead to a long list if statements.well,if I shifted
Dialogue: 0,0:53:29.94,0:53:33.58,ch,,0,0,0,,给往下平移了话,那么新的位置就要平移回去.\N如果往其他方向,同样也要把位置给变回去\N{\ren}all the way down and l need to shift back but if I shifted from here I need to do this
Dialogue: 0,0:53:33.58,0:53:38.38,ch,,0,0,0,,那样做就很麻烦.其实,在此时,如果我执行一次fill的话,\N{\ren}and if I had just basically run a new fill where at that point I say okay
Dialogue: 0,0:53:38.38,0:53:39.68,ch,,0,0,0,,就相当于我对framework说,根据我现在的情况\N{\ren}based on what I've got
Dialogue: 0,0:53:39.68,0:53:41.91,ch,,0,0,0,,你帮我布局出来要看到的视图吧\N{\ren}what am I supposed to be able to see
Dialogue: 0,0:53:41.91,0:53:46.67,ch,,0,0,0,,这就会是一种非常简单的布局流程了.\N因此,我的建议是,尽量去对好的状态进行追踪\N{\ren}it would have been a much simpler flow.so I mean as far as good state to track
Dialogue: 0,0:53:46.67,0:53:50.60,ch,,0,0,0,,换一种说法,在实现基本布局管理器的前提下,\N唯一我推荐你去追踪的就是\N{\ren}that mean the only thing that I would recommend in a basic implementation you track
Dialogue: 0,0:53:50.60,0:53:53.80,ch,,0,0,0,,对任何将要移动过去的目标位置进行追踪\N{\ren}is any target positions you're moving towards
Dialogue: 0,0:53:53.80,0:53:57.52,ch,,0,0,0,,因此,如果你在做一个线性滚动或者在做scrollToPosition的话,\N{\ren}so if you're doing a linear scroll or if you are doing scroll to position and you're
Dialogue: 0,0:53:57.52,0:54:00.67,ch,,0,0,0,,在进行一次新的布局pass时,你可能不得不去追踪\N{\ren}going to get a new layout pass you kinda have to track
Dialogue: 0,0:54:00.67,0:54:03.70,ch,,0,0,0,,你将要移向的目标位置.\N因为这个位置在布局流程中并不会被传递给你\N{\ren}where you wanna go cos that's not passed around for you
Dialogue: 0,0:54:03.70,0:54:06.96,ch,,0,0,0,,但是通常,对于当前的layout里的任何状态\N{\ren}but in general,anything about the current state of the layout
Dialogue: 0,0:54:06.96,0:54:10.06,ch,,0,0,0,,我认为大多数情况下你的布局不应该去依赖这些状态\N{\ren}if you can get away with it and most cases I think you should be able to
Dialogue: 0,0:54:10.10,0:54:11.48,ch,,0,0,0,,你不必去追踪任何东西\N{\ren}you shouldn't have to track anything
Dialogue: 0,0:54:11.48,0:54:13.58,ch,,0,0,0,,如果你要需要在每个列表项上都保存一个状态时\N{\ren}and if you do it as per item
Dialogue: 0,0:54:13.58,0:54:15.04,ch,,0,0,0,,你应该将其保存在ViewHolder中\N{\ren}stick in the view holder
Dialogue: 0,0:54:18.12,0:54:19.48,ch,,0,0,0,,我觉得我们还能再提问一个问题\N{\ren}one more question I think we have time for
Dialogue: 0,0:54:34.80,0:54:36.98,ch,,0,0,0,,噢,你是在说像飞划这种手势么\N{\ren}oh you mean like for fling behavior
Dialogue: 0,0:54:37.02,0:54:39.06,ch,,0,0,0,,onFling什么的并不在布局管理器中\N{\ren}it's not really exposed
Dialogue: 0,0:54:39.12,0:54:41.46,ch,,0,0,0,,因此如果你要去对Fling什么的做自定制的话\N{\ren}so if you were to do it you would have to override the
Dialogue: 0,0:54:41.46,0:54:43.71,ch,,0,0,0,,你就要该去重写RecyclerView的方法了\N{\ren}recycler view itself as well
Dialogue: 0,0:54:43.71,0:54:47.96,ch,,0,0,0,,以及对API进行一些修改.我并没有去这么做过\N{\ren}and kinda modify the API a little bit so I haven't really looked doing it
Dialogue: 0,0:54:47.96,0:54:52.09,ch,,0,0,0,,我只知道这样干是有可能的,\N但是并不会去让你对Fling本身进行定制\N{\ren}it would be possible but it's not given to you,that behavior is really
Dialogue: 0,0:54:52.09,0:54:54.51,ch,,0,0,0,,这个行为是在内部处理的,你唯一能获取到的是\N{\ren}define internally the only one when you're given is the
Dialogue: 0,0:54:54.51,0:54:57.53,ch,,0,0,0,,Fling行为整个动画,而Fling内部的行为并不能由用户直接控制\N{\ren}is the animation part of that that's not user directed
Dialogue: 0,0:54:59.70,0:55:01.94,ch,,0,0,0,,好了,谢谢大家,如果大家还有任何问题\N{\ren}alright,well thanks your time,guys.if you have any other questions,
Dialogue: 0,0:55:01.98,0:55:04.06,ch,,0,0,0,,等我站在台下后,我们可以一起再探讨.\N{\ren}i will step off the side here,we can address on that
Dialogue: 0,0:55:04.06,0:55:18.82,ch,,0,0,0,,各位可以鼓掌了
