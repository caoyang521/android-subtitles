[Script Info]
; Script generated by Aegisub 3.2.1
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: Mastering the Android Touch System.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.000000
Scroll Position: 1633
Active Line: 1635

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1
Style: 城之内,Weibei SC,32,&H00FFFFFF,&H00FEFEFF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,0.8,0.3,2,10,10,10,134
Style: 游戏,Hiragino Sans GB,32,&H00FFFFFF,&H00FEFEFF,&H00FF0000,&H00000000,0,0,0,0,100,100,0,0,1,0.7,0.2,2,10,10,12,1
Style: 十代,Songti SC,32,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1,0.2,2,10,10,10,1
Style: 海马,Kaiti TC,20,&H00FFFFFF,&H00FEFEFF,&H00060607,&H00000000,0,0,0,0,100,100,0,0,1,1,0.2,2,10,10,10,1
Style: en,Monaco,32,&H00FFFFFF,&H00FFFFFF,&H00020209,&H00040000,-1,0,0,0,100,100,0,0,1,1.7,0.3,2,10,10,10,1
Style: ch,Heiti SC,50,&H00FFFFFF,&H00FBFBFF,&H00AD9000,&H00000000,0,0,0,0,100,100,0,0,1,1,0.3,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:05.34,ch,,0,0,0,,精通Android触摸系统\N{\ren}Mastering the Android Touch System
Dialogue: 0,0:00:05.37,0:00:09.65,ch,,0,0,0,,翻译:@Ocean-藏心  推荐:★★★★☆\N\N简介:略有枯燥,但内容清晰,很有广度深度
Dialogue: 0,0:00:09.65,0:00:11.65,ch,,0,0,0,,欢迎大家\N{\ren}So welcome everyone
Dialogue: 0,0:00:11.65,0:00:13.65,ch,,0,0,0,,饭吃饱了吧\N{\ren}welcome back from lunch
Dialogue: 0,0:00:13.68,0:00:14.54,ch,,0,0,0,,吃饱后就要跟我来搬砖了\N{\ren}i hope it was delicious
Dialogue: 0,0:00:14.54,0:00:16.54,ch,,0,0,0,,我是大卫-史密斯\N{\ren}my name is Dave Smith
Dialogue: 0,0:00:16.54,0:00:18.54,ch,,0,0,0,,今天下午我们要讨论的是\N{\ren}and we'll gonna talk about here this afternoon
Dialogue: 0,0:00:18.57,0:00:21.48,ch,,0,0,0,,如何精通Android的触摸系统\N{\ren}is mastering the android touch system
Dialogue: 0,0:00:21.54,0:00:23.82,ch,,0,0,0,,在我们开始讨论之前\N{\ren}so before we get started
Dialogue: 0,0:00:23.88,0:00:25.28,ch,,0,0,0,,我先自报家门一下\N{\ren}just a little bit about myself
Dialogue: 0,0:00:25.28,0:00:27.28,ch,,0,0,0,,我刚说了我叫大卫\N{\ren}i said my name is Dave
Dialogue: 0,0:00:27.28,0:00:29.28,ch,,0,0,0,,我在Double Encore工作\N{\ren}i work for Double Encore
Dialogue: 0,0:00:29.34,0:00:32.54,ch,,0,0,0,,公司位于丹佛市,为客户做一些定制开发\N{\ren}a company based on Denver,does contract Denver development
Dialogue: 0,0:00:32.57,0:00:36.60,ch,,0,0,0,,我主要关注ROM的定制开发\N{\ren}i primarily focus on ROM customization
Dialogue: 0,0:00:36.68,0:00:39.51,ch,,0,0,0,,以及一些嵌入式的应用在那儿\N{\ren}and android embedded applications there
Dialogue: 0,0:00:39.57,0:00:42.48,ch,,0,0,0,,不过干的活一般也就是些应用开发\N{\ren}and do basically is application development
Dialogue: 0,0:00:42.51,0:00:44.88,ch,,0,0,0,,或者做系统镜像的定制\N{\ren}or customization of the system images
Dialogue: 0,0:00:44.94,0:00:46.88,ch,,0,0,0,,当然这些都是根据客户的需求来定做的\N{\ren}for different clients we have in that regard
Dialogue: 0,0:00:46.91,0:00:49.74,ch,,0,0,0,,之前,我是个电子工程师\N{\ren}in the previous life,i was an Electronic Engineer
Dialogue: 0,0:00:49.82,0:00:52.80,ch,,0,0,0,,我搞过无线电链路,用于油气监控\N{\ren}i used to develop Radio Links for oil and gas monitoring.
Dialogue: 0,0:00:52.91,0:00:54.31,ch,,0,0,0,,在我从事移动开发之前\N{\ren}before i get into the mobile
Dialogue: 0,0:00:54.31,0:00:56.31,ch,,0,0,0,,我还跟人写过一本书\N{\ren}i am also the co-author
Dialogue: 0,0:00:56.31,0:00:58.31,ch,,0,0,0,,由Apress出版的"Android 秘诀"\N{\ren}of Android Recipes from Apress
Dialogue: 0,0:00:58.37,0:01:00.05,ch,,0,0,0,,要是我没记错的话\N{\ren}though if i remember correctly
Dialogue: 0,0:01:00.11,0:01:02.28,ch,,0,0,0,,在展厅那里有个Apress的摊位\N{\ren}Apress has a booth in the exhibit hall
Dialogue: 0,0:01:02.37,0:01:03.91,ch,,0,0,0,,你要是愿意的话去那儿喵喵\N{\ren}so take that to me which you will
Dialogue: 0,0:01:03.91,0:01:05.91,ch,,0,0,0,,就算不买也可以看看嘛\N{\ren}they might have copies my books there
Dialogue: 0,0:01:07.51,0:01:09.51,ch,,0,0,0,,好吧,言归正传\N{\ren}ok so what we gonna talk about today
Dialogue: 0,0:01:09.51,0:01:11.51,ch,,0,0,0,,言归正传..传..传....\N{\ren}what we gonna talk about is
Dialogue: 0,0:01:11.57,0:01:17.17,ch,,0,0,0,,对android的触摸机制做一个全面的探索\N{\ren}we gonna look at an overview of the android touch framework
Dialogue: 0,0:01:17.22,0:01:20.60,ch,,0,0,0,,让你掌握在应用中触摸事件如何被分发\N{\ren}give you an idea of how touches flow though your application
Dialogue: 0,0:01:20.65,0:01:23.48,ch,,0,0,0,,以及android如何对事件进行处理\N{\ren}and how android handles all of those events
Dialogue: 0,0:01:23.51,0:01:27.34,ch,,0,0,0,,在这整个触摸交互的过程中\N{\ren}we'll kind of look at the APIs that are available to you
Dialogue: 0,0:01:27.40,0:01:30.22,ch,,0,0,0,,我会带领大家一一了解所用到的APIs\N{\ren}as monitoring the interacting with this process
Dialogue: 0,0:01:30.28,0:01:33.77,ch,,0,0,0,,和一些思路,将有助于你自定义各种基于触摸的交互\N{\ren}and ways that you can implement custom touch interaction
Dialogue: 0,0:01:33.82,0:01:35.22,ch,,0,0,0,,以便将其集成到程序中\N{\ren}inside your apps
Dialogue: 0,0:01:35.28,0:01:39.22,ch,,0,0,0,,最后讲解框架本身已经做好的一些东西\N{\ren}as well as the pieces the framework that are available for you
Dialogue: 0,0:01:39.22,0:01:41.22,ch,,0,0,0,,可能会使你事半功倍\N{\ren}sort of assist you in the process
Dialogue: 0,0:01:41.22,0:01:43.22,ch,,0,0,0,,\N{\ren}
Dialogue: 0,0:01:43.28,0:01:45.28,ch,,0,0,0,,那么,我们就先从\N{\ren}ok.let's go ahead and start with
Dialogue: 0,0:01:45.28,0:01:47.28,ch,,0,0,0,,Android如何处理触摸消息开始讲起\N{\ren}how android deals with touch
Dialogue: 0,0:01:47.34,0:01:51.97,ch,,0,0,0,,每一个由设备上的触摸屏产生的事件\N{\ren}so every event that comes from the touch screen
Dialogue: 0,0:01:51.97,0:01:53.97,ch,,0,0,0,,且被分发到你的应用程序中去\N{\ren}on the device into your application
Dialogue: 0,0:01:54.00,0:01:56.82,ch,,0,0,0,,每一个事件都被包裹成MotionEvent中的一种\N{\ren}is wrapped up in one of these MotionEvents
Dialogue: 0,0:01:56.85,0:01:59.71,ch,,0,0,0,,MotionEvent为你提供了\N{\ren}the MotionEvent essentially provides you
Dialogue: 0,0:01:59.71,0:02:01.62,ch,,0,0,0,,关于这个事件的你所需要的全部信息\N{\ren}all the Information that you need
Dialogue: 0,0:02:01.71,0:02:05.94,ch,,0,0,0,,这些信息包括事件所产生的动作,\N{\ren}associate with each event as to what the event action was
Dialogue: 0,0:02:05.97,0:02:09.45,ch,,0,0,0,,以及关于本事件的一些额外的元信息\N{\ren}as well as any additional meta data that may be necessary
Dialogue: 0,0:02:09.45,0:02:11.45,ch,,0,0,0,,比如说触摸点的位置\N{\ren}such as the touch's location
Dialogue: 0,0:02:11.51,0:02:14.14,ch,,0,0,0,,事件发生时有多少根手指处于屏幕上\N{\ren}the number of fingers that we on the screen at that time
Dialogue: 0,0:02:14.20,0:02:17.45,ch,,0,0,0,,还有事件发生的时间\N{\ren}you know,the actual event time itself
Dialogue: 0,0:02:17.51,0:02:20.54,ch,,0,0,0,,总之,你感兴趣的任何事件信息都有\N{\ren}anything you might need to process that information
Dialogue: 0,0:02:20.62,0:02:23.80,ch,,0,0,0,,这些信息在你的程序中都获取得到\N{\ren}and use that inside your application
Dialogue: 0,0:02:23.88,0:02:27.51,ch,,0,0,0,,系统提供了一些常用的事件动作类型\N{\ren}you know,there is number of primary useful actions
Dialogue: 0,0:02:27.57,0:02:30.94,ch,,0,0,0,,光看其名字,你就能猜出其本身的含义\N{\ren}and by their name you can probably figure out what they are
Dialogue: 0,0:02:30.94,0:02:32.94,ch,,0,0,0,,但是我还是打算给大家一一讲解下\N{\ren}but just to kind give you a basic idea
Dialogue: 0,0:02:33.00,0:02:35.42,ch,,0,0,0,,这里面有 动作_按下 动作_弹起\N{\ren}so there is ACTION_DOWN and ACTION_UP
Dialogue: 0,0:02:35.51,0:02:37.20,ch,,0,0,0,,这两个动作是当\N{\ren}those are the primary actions when
Dialogue: 0,0:02:37.25,0:02:41.02,ch,,0,0,0,,第一根手指在屏幕上按下\N{\ren}the first pointer or finger comes in contact with the screen
Dialogue: 0,0:02:41.08,0:02:42.48,ch,,0,0,0,,然后释放手指所产生的\N{\ren}and then that released
Dialogue: 0,0:02:42.54,0:02:45.48,ch,,0,0,0,,动作_移动产生于\N{\ren}ACTION_MOVE is an event that is happening
Dialogue: 0,0:02:45.57,0:02:48.65,ch,,0,0,0,,手指在屏幕上拖拽时\N{\ren}as that pointer is dragging around the screen
Dialogue: 0,0:02:48.71,0:02:51.68,ch,,0,0,0,,动作_触点_按下 和 动作_触点_弹起\N{\ren}ACTION_POINTER_DOWN and UP
Dialogue: 0,0:02:51.74,0:02:55.20,ch,,0,0,0,,这两个动作会在第二根或更多手指\N{\ren}will be seen for secondary or additional
Dialogue: 0,0:02:55.28,0:02:58.34,ch,,0,0,0,,跟屏幕交互时所产生的\N{\ren}fingers or pointers as they coming contact with the screen
Dialogue: 0,0:02:58.40,0:03:00.60,ch,,0,0,0,,这两个动作当你在处理多点-触控时会用到\N{\ren}these are what you'll see and what you need to look for
Dialogue: 0,0:03:00.60,0:03:02.37,ch,,0,0,0,,这两个动作当你在处理多点-触控时会用到\N{\ren}we you dealing with multi-touch
Dialogue: 0,0:03:02.45,0:03:05.40,ch,,0,0,0,,最后一个是 动作_取消\N{\ren}and then finally ACTION_CANCEL
Dialogue: 0,0:03:05.45,0:03:07.54,ch,,0,0,0,,这个动作会在一些特殊的情形下用到\N{\ren}which we will come up in a couple special cases
Dialogue: 0,0:03:07.54,0:03:09.28,ch,,0,0,0,,在我们接下来的讲解中会遇到\N{\ren}that we'll see as we're moving forward
Dialogue: 0,0:03:09.28,0:03:11.28,ch,,0,0,0,,主要的用法在于\N{\ren}that has to do primarily with
Dialogue: 0,0:03:11.34,0:03:14.14,ch,,0,0,0,,当事件起初被一个视图处理,\N{\ren}when events are initially handled by one view
Dialogue: 0,0:03:14.22,0:03:16.14,ch,,0,0,0,,之后又交给其他视图处理时,就会用到动作_取消\N{\ren}and then that is transferred over to another
Dialogue: 0,0:03:16.22,0:03:17.80,ch,,0,0,0,,\N{\ren}
Dialogue: 0,0:03:17.88,0:03:20.14,ch,,0,0,0,,牢记一点\N{\ren}the primary thing to keep in mind
Dialogue: 0,0:03:20.20,0:03:23.00,ch,,0,0,0,,这点会被反复强调\N{\ren}and you'll see the theme sort of coming in and out
Dialogue: 0,0:03:23.08,0:03:25.97,ch,,0,0,0,,那就是android只定义了一种手势\N{\ren}is that android really defines a single gesture
Dialogue: 0,0:03:26.00,0:03:29.68,ch,,0,0,0,,此手势的全部事件组成发生在动作_按下和弹起之间\N{\ren}as all the events that happen between an ACTION_DOWN event
Dialogue: 0,0:03:29.68,0:03:31.31,ch,,0,0,0,,此手势的全部事件组成发生在动作_按下和弹起之间\N{\ren}and an ACTION_UP
Dialogue: 0,0:03:31.34,0:03:35.85,ch,,0,0,0,,在你程序中,处理一个新的手势时\N{\ren}so the ACTION_DOWN is sort of the initialization of any new gesture
Dialogue: 0,0:03:35.94,0:03:38.28,ch,,0,0,0,,动作_按下就是这个新手势的起始\N{\ren}that you would be handling in your application
Dialogue: 0,0:03:38.34,0:03:43.14,ch,,0,0,0,,之后手势的状态会一直由\N{\ren}and basically the state that is maintained though that gesture
Dialogue: 0,0:03:43.22,0:03:45.45,ch,,0,0,0,,不同的移动事件所维护着\N{\ren}though all the different move events and things like that
Dialogue: 0,0:03:45.54,0:03:47.91,ch,,0,0,0,,直到动作_弹起发生\N{\ren}is then terminated on ACTION_UP
Dialogue: 0,0:03:47.97,0:03:50.88,ch,,0,0,0,,这有点像重新洗牌,再开一局的意味\N{\ren}that's sort of resets the whole game and starts over
Dialogue: 0,0:03:50.94,0:03:54.48,ch,,0,0,0,,这个过程我们会遇到几次\N{\ren}you'll see that theme kind of come though couple different times
Dialogue: 0,0:03:54.48,0:03:56.48,ch,,0,0,0,,\N{\ren}
Dialogue: 0,0:03:56.51,0:03:59.71,ch,,0,0,0,,那么事件到底是如何在你的应用中传递的呢\N{\ren}how does these things actually flow though your application
Dialogue: 0,0:03:59.77,0:04:02.08,ch,,0,0,0,,对于每一个由\N{\ren}so,for every event that as generated
Dialogue: 0,0:04:02.14,0:04:05.14,ch,,0,0,0,,硬件和底层框架产生的事件\N{\ren}by the hardware and the underlying framework
Dialogue: 0,0:04:05.14,0:04:09.31,ch,,0,0,0,,这些事件最先被发送到你的Activity中\N{\ren}they are first dispatched to your application is Activity
Dialogue: 0,0:04:09.37,0:04:12.51,ch,,0,0,0,,在你程序中,哪个Activity在前台的最顶部\N{\ren}whatever the foreground Activity is at the top level
Dialogue: 0,0:04:12.51,0:04:14.51,ch,,0,0,0,,在你程序中,哪个Activity在前台的最顶部\N{\ren}inside your application
Dialogue: 0,0:04:14.51,0:04:16.37,ch,,0,0,0,,那个Activity就会接收触摸事件\N{\ren}that activity will receive the touch event
Dialogue: 0,0:04:16.37,0:04:19.17,ch,,0,0,0,,优先于你程序中的其他任何组件\N{\ren}before any other component inside of your application
Dialogue: 0,0:04:19.22,0:04:22.25,ch,,0,0,0,,这个过程是经由框架调用\N{\ren}it will do that by the framework calling
Dialogue: 0,0:04:22.25,0:04:25.60,ch,,0,0,0,,那个Activity的dispatchTouchEvent()来完成的\N{\ren}the dispatchTouchEvent() on that activity
Dialogue: 0,0:04:25.71,0:04:31.17,ch,,0,0,0,,我首先要强调的是,在你的应用中,\N{\ren}i first point this out to say is for whatever reason in your application
Dialogue: 0,0:04:31.22,0:04:36.20,ch,,0,0,0,,你需要了解知道\N{\ren}you need to gain knowledge of or get understanding of
Dialogue: 0,0:04:36.20,0:04:39.62,ch,,0,0,0,,不管你在程序做了何种事件处理\N{\ren}touch events before anything else in your application does
Dialogue: 0,0:04:39.71,0:04:44.05,ch,,0,0,0,,最先获取事件处理机会的\N{\ren}the very first opportunity you have at all to see a touch event
Dialogue: 0,0:04:44.05,0:04:46.05,ch,,0,0,0,,就是在Activity中的dispatchTouchEvent()\N{\ren}is the dispatchTouchEvent() on activity
Dialogue: 0,0:04:46.11,0:04:48.11,ch,,0,0,0,,因此,你可以重载这个方法\N{\ren}so you can override that method
Dialogue: 0,0:04:48.11,0:04:50.91,ch,,0,0,0,,在这个方法里检查各种移动事件\N{\ren}and inspect those motion events there
Dialogue: 0,0:04:50.97,0:04:53.60,ch,,0,0,0,,我不建议大家在这个方法里面做过多的事情\N{\ren}i wouldn't necessarily recommend doing a whole lot with them
Dialogue: 0,0:04:53.60,0:04:55.71,ch,,0,0,0,,但是大家起码要监测一些事件的流向\N{\ren}other than just monitoring them
Dialogue: 0,0:04:55.77,0:04:58.37,ch,,0,0,0,,因为事件要在整个框架中走完还有很长的路\N{\ren}case they have a long way to go still though the framework
Dialogue: 0,0:04:58.42,0:05:00.80,ch,,0,0,0,,总而言之,这是事件流经的第一站\N{\ren}but this is the first method that we'll ever be called
Dialogue: 0,0:05:00.85,0:05:02.40,ch,,0,0,0,,在这个方法里\N{\ren}and then,in that point
Dialogue: 0,0:05:02.42,0:05:04.42,ch,,0,0,0,,这些事件会开启其旅程\N{\ren}these events are going to traversal their way
Dialogue: 0,0:05:04.45,0:05:07.57,ch,,0,0,0,,由Activity开始往下传递给你的视图结构树,\N{\ren}down from the activity down though from your view hierarchy
Dialogue: 0,0:05:07.65,0:05:09.22,ch,,0,0,0,,而在视图结构树中会由上到下传递\N{\ren}from the top down
Dialogue: 0,0:05:09.28,0:05:11.51,ch,,0,0,0,,事件首先由窗口服务端发送到Activity里面\N{\ren}so they are gonna start at the activity in the window level
Dialogue: 0,0:05:11.57,0:05:14.28,ch,,0,0,0,,再由Activity发送给RootView(详情参考:Android内核剖析)\N{\ren}and they will be first delivered to the RootView
Dialogue: 0,0:05:14.28,0:05:16.08,ch,,0,0,0,,这个RootView存在于你的contentView里\N{\ren}of whatever your content ViewGroup is
Dialogue: 0,0:05:16.14,0:05:20.48,ch,,0,0,0,,之后,再由根ViewGroup将其发送给子视图们\N{\ren}and then that ViewGroup's job is to deliver it to its childViews
Dialogue: 0,0:05:20.48,0:05:22.48,ch,,0,0,0,,如果这些子视图中也有ViewGroup,就递归地再往下分发\N{\ren}and if those are ViewGroups,to their childViews
Dialogue: 0,0:05:22.51,0:05:25.08,ch,,0,0,0,,直到事件分发到视图树的最底部\N{\ren}all the way down the tree to way get the bottom
Dialogue: 0,0:05:25.11,0:05:28.88,ch,,0,0,0,,之后,事件会反过来由底向上传递\N{\ren}and then if necessary traversal those back up
Dialogue: 0,0:05:28.94,0:05:31.91,ch,,0,0,0,,这里的传递机制是\N{\ren}the way that this works is
Dialogue: 0,0:05:31.94,0:05:34.74,ch,,0,0,0,,事件会在你的程序中从上往下再从下往上穿梭\N{\ren}the events will flow through your application
Dialogue: 0,0:05:34.80,0:05:37.08,ch,,0,0,0,,直到某个View\N{\ren}until such point that one of the views
Dialogue: 0,0:05:37.14,0:05:39.60,ch,,0,0,0,,宣布其对这个事件感兴趣为止\N{\ren}declares that is interested in that event
Dialogue: 0,0:05:39.60,0:05:41.60,ch,,0,0,0,,一旦如此,那么关于某个手势的其他信息就会接踵而来\N{\ren}and wants to know more about the rest of the gesture
Dialogue: 0,0:05:42.22,0:05:46.60,ch,,0,0,0,,是否"感兴趣"体现在框架上就是onTouchEvent()这个方法\N{\ren}the way the framework does this is the onTouchEvent()
Dialogue: 0,0:05:46.68,0:05:50.14,ch,,0,0,0,,每个View和ViewGroup都有这个函数,其返回一个布尔值\N{\ren}every View or ViewGroup has,returns a boolean value
Dialogue: 0,0:05:50.22,0:05:53.62,ch,,0,0,0,,因此,作为一个自定义视图的实现者\N{\ren}and so,as a implementer of a custom view
Dialogue: 0,0:05:53.68,0:05:57.28,ch,,0,0,0,,或者自定义视图树中其他部分\N{\ren}or you know some other piece of the view hierarchy
Dialogue: 0,0:05:57.34,0:06:00.85,ch,,0,0,0,,你就可以在这个方法中返回true\N{\ren}your application can return true from this method
Dialogue: 0,0:06:00.91,0:06:03.74,ch,,0,0,0,,来宣布你的自定义视图对触摸事件感兴趣\N{\ren}to declare interest in that particular gesture
Dialogue: 0,0:06:03.74,0:06:04.68,ch,,0,0,0,,到那时,\N{\ren}and at that point
Dialogue: 0,0:06:04.68,0:06:08.14,ch,,0,0,0,,Android框架就知道了有一个视图会对触摸事件感兴趣\N{\ren}the framework has found a view that is interested in the touch
Dialogue: 0,0:06:08.14,0:06:10.14,ch,,0,0,0,,那么它就会中断原本的对触摸事件的响应链\N{\ren}and it will stop that respond chain
Dialogue: 0,0:06:10.36,0:06:13.05,ch,,0,0,0,,如果一个触摸事件\N{\ren}but essentially if a touch event
Dialogue: 0,0:06:13.05,0:06:15.65,ch,,0,0,0,,成功的传递到了视图的底部\N{\ren}manages to go all the way down the view hierarchy
Dialogue: 0,0:06:15.68,0:06:19.00,ch,,0,0,0,,以及在此过程中,没有任何视图对其产生兴趣\N{\ren}and not find a single view that is interested in that touch
Dialogue: 0,0:06:19.05,0:06:21.80,ch,,0,0,0,,此事件就会在视图树中一直往上返回\N{\ren}it will start to work back up to the hierarchy
Dialogue: 0,0:06:21.80,0:06:23.80,ch,,0,0,0,,直到这个事件返回到Activity为止\N{\ren}until it gets all the way back to the activity
Dialogue: 0,0:06:23.85,0:06:27.00,ch,,0,0,0,,现在你可能对这个流程没啥感觉,\N{\ren}that may make a little more sense when you see
Dialogue: 0,0:06:27.00,0:06:30.52,ch,,0,0,0,,不过当你看到一些视觉化的东西时就会感觉好很多了\N{\ren}sort of a visualization of it here a little bit in an example
Dialogue: 0,0:06:30.60,0:06:32.22,ch,,0,0,0,,核心内容在于\N{\ren}but the kind of core
Dialogue: 0,0:06:32.25,0:06:34.57,ch,,0,0,0,,我再强调一下,核心内容是\N{\ren}the core thing to come a way with that is
Dialogue: 0,0:06:34.65,0:06:38.22,ch,,0,0,0,,当你尝试去做任何的自定义事件处理时\N{\ren}if you are trying to do any custom touch handling
Dialogue: 0,0:06:38.25,0:06:40.48,ch,,0,0,0,,动作_按下 这个事件将会是\N{\ren}the ACTION_DOWN event is something
Dialogue: 0,0:06:40.48,0:06:42.85,ch,,0,0,0,,你的View或者ViewGroup中onTouchEvent()需要注意的\N{\ren}that your View or your ViewGroup
Dialogue: 0,0:06:42.94,0:06:47.71,ch,,0,0,0,,如果你对这个事件感兴趣抑或对其后的事件感兴趣\N{\ren}need to return true for if you're interested in that event
Dialogue: 0,0:06:47.71,0:06:49.71,ch,,0,0,0,,你需在onTouchEvent()中处理 动作_按下 时返回true\N{\ren}or any event after that effect
Dialogue: 0,0:06:49.74,0:06:52.85,ch,,0,0,0,,因为如果你不宣布你对 动作_按下 感兴趣时\N{\ren}case if you don't declare interest in ACTION_DOWN
Dialogue: 0,0:06:52.88,0:06:55.82,ch,,0,0,0,,此时,系统就会觉得你对其他事件亦不感兴趣\N{\ren}there is a good chance you may not see another touch event
Dialogue: 0,0:06:55.82,0:06:57.42,ch,,0,0,0,,此时,系统就会觉得你对其他事件亦不感兴趣\N{\ren}at all at that point
Dialogue: 0,0:06:57.51,0:06:59.62,ch,,0,0,0,,就效率而言,系统认为他们这么做理所当然\N{\ren}for efficiency reasons they don't..
Dialogue: 0,0:06:59.71,0:07:05.02,ch,,0,0,0,,一旦某个特定的View宣布了\N它对某个事件感兴趣以及返回true\N{\ren}once a particular View has declared an interest and has returned true
Dialogue: 0,0:07:05.11,0:07:09.34,ch,,0,0,0,,那么这个View就是某个手势中其他事件的直接目的地\N{\ren}that is the effective destination for all the other MotionEvent
Dialogue: 0,0:07:09.34,0:07:11.34,ch,,0,0,0,,那么这个View就是某个手势中其他事件的直接目的地\N{\ren}for the reminder of that gesture
Dialogue: 0,0:07:11.42,0:07:16.31,ch,,0,0,0,,还是那句话,见了视觉化的东西你就能顿悟了\N{\ren}that might make more sense when you actually see in visualization
Dialogue: 0,0:07:16.34,0:07:21.00,ch,,0,0,0,,综上所述,整个视图树的传递流程是\N{\ren}but as i mentioned,the way that this hierarchy basically works
Dialogue: 0,0:07:21.08,0:07:23.82,ch,,0,0,0,,通过View和ViewGroup自顶向下传递\N{\ren}is that they will traversal down thought the Views and ViewGroups
Dialogue: 0,0:07:24.11,0:07:27.31,ch,,0,0,0,,根据是View还是ViewGroup调用其各自的dispatch方法\N{\ren}by individually calling the dispatch methods of each
Dialogue: 0,0:07:27.31,0:07:31.88,ch,,0,0,0,,ViewGroup会把事件交由它的孩子,孩子会交给孙子等等\N{\ren}so the ViewGroup will dispatch to the View and so on and so forth
Dialogue: 0,0:07:31.91,0:07:34.14,ch,,0,0,0,,接下来,当事件往上传递时\N{\ren}and then as they work back up
Dialogue: 0,0:07:34.22,0:07:37.54,ch,,0,0,0,,View和ViewGroup就会调用onTouchEvent()了\N{\ren}it's the onTouchEvent() that get called
Dialogue: 0,0:07:37.54,0:07:40.51,ch,,0,0,0,,简而言之,dispatch一层一层往下调用\N{\ren}effectively,the dispatch methods go on the way down
Dialogue: 0,0:07:40.51,0:07:42.34,ch,,0,0,0,,onTouchEvent一层一层往上返回\N{\ren}and onTouch on the way back up
Dialogue: 0,0:07:42.34,0:07:44.34,ch,,0,0,0,,所以\N{\ren}so
Dialogue: 0,0:07:44.34,0:07:46.20,ch,,0,0,0,,我们中有些人也可能做过这事儿\N{\ren}some of you may have done this before
Dialogue: 0,0:07:46.20,0:07:48.05,ch,,0,0,0,,这事儿是我之前犯过的一个错误\N{\ren}i know i've made this mistake before
Dialogue: 0,0:07:48.28,0:07:51.54,ch,,0,0,0,,在Activity中有一个onTouchEvent()的方法\N{\ren}that there is an onTouchEvent() on activity
Dialogue: 0,0:07:51.62,0:07:54.48,ch,,0,0,0,,既然事件经由Activity分发下去\N{\ren}and thinking while activity is the top value
Dialogue: 0,0:07:54.48,0:07:56.28,ch,,0,0,0,,那么在Activity中的onTouchEvent()就是\N{\ren}onTouchEvent() is probably the place for
Dialogue: 0,0:07:56.28,0:07:59.37,ch,,0,0,0,,我要监控触摸事件的传递流程的第一站\N{\ren}i want to monitor for touches if i wanna see them first
Dialogue: 0,0:07:59.42,0:08:01.85,ch,,0,0,0,,但是结果却是恰恰相反\N{\ren}and it turns out the opposite is true
Dialogue: 0,0:08:01.91,0:08:06.48,ch,,0,0,0,,如果你在Activity的onTouchEvent中监测触摸事件\N{\ren}if you monitor for touchEvents in the activity's onTouchEvent()
Dialogue: 0,0:08:06.54,0:08:09.14,ch,,0,0,0,,这个地方会是触摸事件到达的终点\N{\ren}that is the last place that the touch event will end up
Dialogue: 0,0:08:09.25,0:08:11.80,ch,,0,0,0,,而且大多数情况下你根本监测不到\N{\ren}and in many cases that they may not show up at all
Dialogue: 0,0:08:11.91,0:08:12.85,ch,,0,0,0,,因为\N{\ren}because
Dialogue: 0,0:08:13.91,0:08:15.91,ch,,0,0,0,,如果触摸事件被中间过程中的某个View消费了\N{\ren}if a touch event is consumed by some View
Dialogue: 0,0:08:15.91,0:08:18.22,ch,,0,0,0,,那么事件终点就会停到那个View处了\N{\ren}lower down in the tree,that's where it stops
Dialogue: 0,0:08:18.28,0:08:22.37,ch,,0,0,0,,也就是说那个View上面的onTouchEvent就不会被调用了\N{\ren}so anything after that on the way back up won't be called at all
Dialogue: 0,0:08:22.37,0:08:24.37,ch,,0,0,0,,这些你要谨记\N{\ren}just something you keep in mind
Dialogue: 0,0:08:24.45,0:08:26.82,ch,,0,0,0,,额外的说,我们可以\N{\ren}additionally,we do have the ability
Dialogue: 0,0:08:26.82,0:08:29.48,ch,,0,0,0,,有另外一种方式监测触摸事件或者是对事件做交互处理\N{\ren}to either monitor or interact with
Dialogue: 0,0:08:29.54,0:08:33.22,ch,,0,0,0,,这种方法不必我们去派生View或ViewGroup的子类\N{\ren}touch events without having to subclass View or ViewGroups
Dialogue: 0,0:08:33.25,0:08:35.74,ch,,0,0,0,,而是直接调用其onTouchListener()即可\N{\ren}by way of what's known is onTouchListener()
Dialogue: 0,0:08:35.77,0:08:38.57,ch,,0,0,0,,onTouchListener()就跟\N{\ren}and onTouchListener() behaves very similar
Dialogue: 0,0:08:38.57,0:08:40.28,ch,,0,0,0,,onTouchEvent()没啥两样\N{\ren}to the onTouchEvent() of a view
Dialogue: 0,0:08:40.40,0:08:44.25,ch,,0,0,0,,在此方法中,你照样可以返回true\N{\ren}and that you still have the ability to return true from that method
Dialogue: 0,0:08:44.25,0:08:45.91,ch,,0,0,0,,来消耗某些事件\N{\ren}to consume those events
Dialogue: 0,0:08:45.91,0:08:47.77,ch,,0,0,0,,当我们对待某些情形时,\N{\ren}you'll see how we can use that a little bit
Dialogue: 0,0:08:47.77,0:08:49.88,ch,,0,0,0,,使用这个方法是个不错的选择\N{\ren}to our advantage in certain use cases
Dialogue: 0,0:08:49.88,0:08:51.88,ch,,0,0,0,,\N{\ren}
Dialogue: 0,0:08:51.88,0:08:55.68,ch,,0,0,0,,好了,咱已经把触摸的流程走完了\N{\ren}ok,we just kind walk though the specifics what's really happening
Dialogue: 0,0:08:55.74,0:08:57.45,ch,,0,0,0,,之前我说过,我们于Activity开始\N{\ren}as i mentioned,we start with activity
Dialogue: 0,0:08:57.45,0:09:00.95,ch,,0,0,0,,因此,当Activity调用dispatchTouchEvent()时\N{\ren}so when the dispatchTouchEvent() is called on activity
Dialogue: 0,0:09:01.02,0:09:02.54,ch,,0,0,0,,这当然是事件传递的第一步了\N{\ren}which is always the first things to happen
Dialogue: 0,0:09:02.54,0:09:05.74,ch,,0,0,0,,Activity就通过其dispatch方法将事件传给RootView\N{\ren}the activity dispatches that event to the RootView
Dialogue: 0,0:09:05.74,0:09:09.84,ch,,0,0,0,,RootView大多数情况下就是一个ViewGroup\N{\ren}which improbably almost all cases is actually a ViewGroup
Dialogue: 0,0:09:09.84,0:09:11.84,ch,,0,0,0,,或者说是个布局(继承自ViewGroup)\N{\ren}or some sort of Layout
Dialogue: 0,0:09:11.88,0:09:14.94,ch,,0,0,0,,因此Activity的工作是\N{\ren}so the job of the activity
Dialogue: 0,0:09:14.94,0:09:18.14,ch,,0,0,0,,调用那个ViewGroup的dispatchTouchEvent()\N{\ren}is to call the dispatchTouchEvent() of that ViewGroup and then
Dialogue: 0,0:09:18.14,0:09:22.84,ch,,0,0,0,,在ViewGroup的dispatch中会调用其孩子的dispatch\N{\ren}the ViewGroups will call the dispatchTouchEvent() of their children
Dialogue: 0,0:09:22.88,0:09:24.48,ch,,0,0,0,,一会我们就对这个过程做详解\N{\ren}but we'll look at that there just in a second
Dialogue: 0,0:09:24.48,0:09:26.78,ch,,0,0,0,,之后,在Activity中的onTouchEvent()会是\N{\ren}and then onTouchEvent() on the activity
Dialogue: 0,0:09:26.78,0:09:28.60,ch,,0,0,0,,触摸事件传递链条的终点\N{\ren}will be the end of that chain
Dialogue: 0,0:09:28.60,0:09:32.08,ch,,0,0,0,,不过前提是在整个过程中没有视图\N{\ren}if there are no other Views though out the entire process
Dialogue: 0,0:09:32.08,0:09:34.38,ch,,0,0,0,,去对触摸事件感兴趣\N{\ren}that say they want that event
Dialogue: 0,0:09:34.38,0:09:39.68,ch,,0,0,0,,整体来看,View在这个过程中的逻辑要比ViewGroup简单\N{\ren}the View case is a little bit simpler,certainly simpler than ViewGroup
Dialogue: 0,0:09:39.68,0:09:43.78,ch,,0,0,0,,View的dispatchTouchEvent()\N{\ren}the dispatchTouchEvent() inside just regular of a View
Dialogue: 0,0:09:43.78,0:09:45.78,ch,,0,0,0,,只需要干两件事儿\N{\ren}really only has two jobs
Dialogue: 0,0:09:45.82,0:09:47.08,ch,,0,0,0,,第一件事儿是\N{\ren}the first thing that will happen
Dialogue: 0,0:09:47.08,0:09:48.54,ch,,0,0,0,,检查是否有\N{\ren}is it will check to see whether or not
Dialogue: 0,0:09:48.54,0:09:51.18,ch,,0,0,0,,TouchListener注册在这个View中\N{\ren}a TouchListener() has been registered on that View
Dialogue: 0,0:09:51.28,0:09:52.42,ch,,0,0,0,,如果有\N{\ren}and if it has
Dialogue: 0,0:09:52.42,0:09:54.25,ch,,0,0,0,,就会先对此监听器进行检查\N{\ren}it will check with the Listener first
Dialogue: 0,0:09:54.25,0:09:56.22,ch,,0,0,0,,看看其是否想要消费此次事件\N{\ren}to see if he wants to consume that event
Dialogue: 0,0:09:56.31,0:09:59.91,ch,,0,0,0,,如果触摸监听器不消费事件\N{\ren}if the TouchListener does not consume the event
Dialogue: 0,0:09:59.97,0:10:01.62,ch,,0,0,0,,或者传进来的事件跟要监听的事件无关\N{\ren}or if there isn't one attached
Dialogue: 0,0:10:01.62,0:10:04.82,ch,,0,0,0,,接下来该View的onTouchEvent()就要被调用了\N{\ren}then the onTouchEvent() of that View gets called
Dialogue: 0,0:10:04.82,0:10:06.77,ch,,0,0,0,,如果在onTouchEvent()中也没有返回true\N{\ren}and if it doesn't return true there
Dialogue: 0,0:10:06.77,0:10:08.62,ch,,0,0,0,,那么事件就会返回到视图树上的上一层\N{\ren}it's gonna pass it back up the hierarchy
Dialogue: 0,0:10:08.71,0:10:12.77,ch,,0,0,0,,在一般的View中,就只有这两个地方来处理事件\N{\ren}ok.so really only this two places on a traditional View
Dialogue: 0,0:10:12.94,0:10:15.62,ch,,0,0,0,,ViewGroup的机制就有点复杂了\N{\ren}ViewGroup is little bit more complex
Dialogue: 0,0:10:15.65,0:10:16.77,ch,,0,0,0,,有以下几点\N{\ren}for a couple of reasons
Dialogue: 0,0:10:16.77,0:10:18.77,ch,,0,0,0,,首先,它要对childView进行管理\N{\ren}first,it has childViews to manage
Dialogue: 0,0:10:18.88,0:10:20.88,ch,,0,0,0,,因此,在处理事件时,\N{\ren}so it's responsible for actually
Dialogue: 0,0:10:20.88,0:10:23.74,ch,,0,0,0,,它需要对自己的child进行遍历和迭代\N{\ren}going though and iterating though its childViews
Dialogue: 0,0:10:23.80,0:10:26.00,ch,,0,0,0,,来确定哪些孩子\N{\ren}to determine which one of those Views may
Dialogue: 0,0:10:26.08,0:10:27.85,ch,,0,0,0,,有可能对此事件感兴趣\N{\ren}possibly want this event
Dialogue: 0,0:10:27.91,0:10:30.08,ch,,0,0,0,,这些孩子肯定是在当前处理事件的ViewGroup中的孩子\N{\ren}that all actually managed inside ViewGroup
Dialogue: 0,0:10:30.14,0:10:31.60,ch,,0,0,0,,如果你去看ViewGroup的源码\N{\ren}if you look at the source code for ViewGroup
Dialogue: 0,0:10:31.71,0:10:35.22,ch,,0,0,0,,这个过程是在ViewGroup的dispatchTouchEvent()中\N{\ren}you will see it doing this inside it by dispatchTouchEvent()
Dialogue: 0,0:10:35.22,0:10:37.22,ch,,0,0,0,,实际上,ViewGroup会\N{\ren}effectively,what it doing is
Dialogue: 0,0:10:37.28,0:10:39.85,ch,,0,0,0,,根据触摸的位置来判断\N{\ren}evaluating based on the touch location
Dialogue: 0,0:10:39.97,0:10:43.65,ch,,0,0,0,,有哪些childViews可以代表此位置\N{\ren}which childViews actually represent that location
Dialogue: 0,0:10:43.68,0:10:47.25,ch,,0,0,0,,意思是触摸位置处于childView的边界内\N{\ren}which childViews have their bounds inside this touch
Dialogue: 0,0:10:47.31,0:10:50.31,ch,,0,0,0,,这样才说明触摸事件与此View相关\N{\ren}so that might be considered relevant to that View
Dialogue: 0,0:10:50.34,0:10:53.20,ch,,0,0,0,,如果此childView不只1个\N{\ren}and it there are more than one,for instance,if there're..
Dialogue: 0,0:10:53.28,0:10:55.57,ch,,0,0,0,,比方说两个有重叠部分的View\N{\ren}overlapping at all,or something like that
Dialogue: 0,0:10:55.60,0:10:58.57,ch,,0,0,0,,ViewGroup就会逆序遍历这些孩子View\N{\ren}it will iterate though those children in reverse order
Dialogue: 0,0:10:58.60,0:11:02.68,ch,,0,0,0,,逆序是指按照被加入到ViewGroup中的顺序的逆序\N{\ren}basically,in reverse order that they were added to the ViewGroup
Dialogue: 0,0:11:02.71,0:11:06.31,ch,,0,0,0,,这些View就有处理事件的机会\N{\ren}they will be given the opportunity to process that event
Dialogue: 0,0:11:06.37,0:11:08.60,ch,,0,0,0,,通过父View的dispatch,首先是第一个childView处理事件\N{\ren}by dispatching it to,first this childView
Dialogue: 0,0:11:08.74,0:11:10.37,ch,,0,0,0,,之后再轮到第二个childView\N{\ren}and then to the next childView
Dialogue: 0,0:11:10.42,0:11:13.08,ch,,0,0,0,,前提是第一个childView没有消耗掉事件\N{\ren}assuming the first one didn't consume the event
Dialogue: 0,0:11:13.11,0:11:15.62,ch,,0,0,0,,这些都是发生在ViewGroup中的\N{\ren}this is all happening inside the ViewGroup
Dialogue: 0,0:11:15.62,0:11:18.28,ch,,0,0,0,,额外的,ViewGroup还可以对\N{\ren}additionally,ViewGroup has the ability to
Dialogue: 0,0:11:18.34,0:11:22.14,ch,,0,0,0,,触摸事件进行中断或者窃取\N{\ren}intercept or steal touchEvent() from their children
Dialogue: 0,0:11:22.20,0:11:24.60,ch,,0,0,0,,通过以下的方法\N{\ren}so,there is also the secondary method
Dialogue: 0,0:11:24.68,0:11:27.05,ch,,0,0,0,,onInterceptTouchEvent()可以达到这个目的\N{\ren}called onInterceptTouchEvent()
Dialogue: 0,0:11:27.08,0:11:29.20,ch,,0,0,0,,此方法在不断的监测触摸事件\N{\ren}that is constant monitoring all of these events
Dialogue: 0,0:11:29.28,0:11:31.71,ch,,0,0,0,,监测哪些流入到此ViewGroup的事件\N{\ren}has they're flowing though the ViewGroup as well
Dialogue: 0,0:11:31.74,0:11:34.08,ch,,0,0,0,,监测的目的在于,任意指定一个时间\N{\ren}for the purposes that,at any given time
Dialogue: 0,0:11:34.08,0:11:36.28,ch,,0,0,0,,由于手势的特殊需求\N{\ren}based on what the gesture becomes
Dialogue: 0,0:11:36.37,0:11:39.48,ch,,0,0,0,,使得ViewGroup要停止将事件分发下去\N{\ren}the ViewGroup may want to stop delivering those events
Dialogue: 0,0:11:39.48,0:11:42.25,ch,,0,0,0,,停止将事件分发给原本将要消耗此事件的childViews\N{\ren}to whatever childView was originally consuming them
Dialogue: 0,0:11:42.25,0:11:44.25,ch,,0,0,0,,转而直接让自己来处理事件\N{\ren}and start process them by itself
Dialogue: 0,0:11:44.31,0:11:46.51,ch,,0,0,0,,这个机制主要用于\N{\ren}the primary use case for this
Dialogue: 0,0:11:46.57,0:11:49.25,ch,,0,0,0,,当你进行"滚动"的时候\N{\ren}the one you probably all familiar with is scrolling
Dialogue: 0,0:11:49.34,0:11:50.60,ch,,0,0,0,,举个例子来说\N{\ren}so,for instance
Dialogue: 0,0:11:50.65,0:11:53.42,ch,,0,0,0,,你有一个ScrollView,这个ScrollView里面有一些孩子视图\N{\ren}ScrollView may have several childViews inside of it
Dialogue: 0,0:11:53.48,0:11:55.05,ch,,0,0,0,,这些孩子视图也同样需要交互\N{\ren}that need to be interactive
Dialogue: 0,0:11:55.08,0:11:57.34,ch,,0,0,0,,在具体点,如果我的ScrollView里面放了Button\N{\ren}you know,if i have Buttons inside my ScrollView
Dialogue: 0,0:11:57.37,0:11:59.31,ch,,0,0,0,,这些Button肯定是要能被点击的\N{\ren}i need to be able to tap those,i'm actually
Dialogue: 0,0:11:59.31,0:12:01.31,ch,,0,0,0,,那么他们身上就会被注册点击监听器\N{\ren}register those click events on the childViews
Dialogue: 0,0:12:01.37,0:12:04.80,ch,,0,0,0,,一旦你的手指开始做一个滚动的动作时\N{\ren}but as soon as the fingers starts moving in a scrolling motion
Dialogue: 0,0:12:04.85,0:12:07.54,ch,,0,0,0,,你的ScrollView就开始工作了,由它来处理\N{\ren}it's the ScrollView's job to know process those touchEvents
Dialogue: 0,0:12:07.62,0:12:08.97,ch,,0,0,0,,哪些可以滚动视图内容的事件了\N{\ren}that can scroll the content
Dialogue: 0,0:12:09.08,0:12:12.62,ch,,0,0,0,,ScrollView优先Button响应事件的做法\N就是用我刚提到的中断机制.\N{\ren}the way that is does that is using this intercept mechanism
Dialogue: 0,0:12:12.68,0:12:16.14,ch,,0,0,0,,实际上,ViewGroup本来就在监控各种触摸事件\N{\ren}effectively,the ViewGroup is watching all of those touches
Dialogue: 0,0:12:16.20,0:12:18.94,ch,,0,0,0,,尽管事件最终是要被分发到不同的孩子身上\N{\ren}even they're being delivered to the different children
Dialogue: 0,0:12:19.02,0:12:21.37,ch,,0,0,0,,不过一旦ViewGroup监测到了一个拖拽的手势\N{\ren}once that gesture turns into a drag
Dialogue: 0,0:12:21.40,0:12:23.17,ch,,0,0,0,,那就不能让孩子来响应了,于是就会触发这种中断\N{\ren}it's gonna trigger an intercept
Dialogue: 0,0:12:23.25,0:12:25.91,ch,,0,0,0,,把事件直接交给自己来处理\N{\ren}and start processing all of those directly itself
Dialogue: 0,0:12:26.22,0:12:28.80,ch,,0,0,0,,那么,作为开发者的我们\N{\ren}so,as a developer
Dialogue: 0,0:12:28.88,0:12:32.02,ch,,0,0,0,,你也可以好好利用这种机制\N{\ren}you can sort of work with the same process,by again
Dialogue: 0,0:12:32.02,0:12:34.02,ch,,0,0,0,,把那些需要从孩子中截取的事件处理\N放在onInterceptTouchEvent()中\N{\ren}monitoring the events on intercept
Dialogue: 0,0:12:34.05,0:12:36.57,ch,,0,0,0,,一旦你从onIntercept()中返回true\N{\ren}and as soon as you return true from that
Dialogue: 0,0:12:36.60,0:12:39.65,ch,,0,0,0,,你就要开始在你的自定义布局中处理事件了\N{\ren}start processing the events yourself in your layout
Dialogue: 0,0:12:39.74,0:12:42.45,ch,,0,0,0,,你就要开始在你的自定义布局中处理事件了\N{\ren}whatever custom layout you're building as opposed to
Dialogue: 0,0:12:42.45,0:12:44.45,ch,,0,0,0,,而不是把事件交给子控件\N{\ren}passing them down to the Views
Dialogue: 0,0:12:44.51,0:12:46.91,ch,,0,0,0,,我们这里谈的百分之九十九都是\N{\ren}99% of what we're talking about
Dialogue: 0,0:12:46.91,0:12:48.91,ch,,0,0,0,,框架自己干的事情\N{\ren} is just what happens in the framework
Dialogue: 0,0:12:49.22,0:12:51.37,ch,,0,0,0,,这些都不用你去替框架实现,\N{\ren}it's not something that you have necessarily
Dialogue: 0,0:12:51.42,0:12:54.91,ch,,0,0,0,,创建一个新的ViewGroup并不意味着\N你可以去干涉系统的内政\N{\ren}consistently manage yourself,cause you create a new ViewGroup
Dialogue: 0,0:12:54.94,0:12:58.00,ch,,0,0,0,,你要做的是把系统的工作搞清,顺着系统的意思干活\N{\ren}you just have to be mindful how this works
Dialogue: 0,0:12:58.05,0:13:00.14,ch,,0,0,0,,要是你干了不该干的事儿,你就会把东西搞砸\N{\ren}because there are things you can do to screw this up
Dialogue: 0,0:13:00.17,0:13:02.11,ch,,0,0,0,,比方说,你对你并不需要的事件进行了消费\N{\ren}if you start consuming events
Dialogue: 0,0:13:02.17,0:13:04.37,ch,,0,0,0,,比方说,你对你并不需要的事件进行了消费\N{\ren}for reasons that you may be don't need them
Dialogue: 0,0:13:04.42,0:13:08.71,ch,,0,0,0,,在ViewGroup中有个额外的标识\N{\ren}ok,now,there is this sort of additional flag
Dialogue: 0,0:13:08.71,0:13:10.71,ch,,0,0,0,,我们可以用来\N{\ren}that we can use on a ViewGroup
Dialogue: 0,0:13:10.77,0:13:12.94,ch,,0,0,0,,打断这个onIntercept的逻辑\N{\ren}to interrupt this process
Dialogue: 0,0:13:12.97,0:13:14.34,ch,,0,0,0,,通常\N{\ren}so in general,
Dialogue: 0,0:13:14.42,0:13:17.71,ch,,0,0,0,,整个触摸事件流程中任何事件都是\N{\ren}the touch flow is such that parent views are responsible for
Dialogue: 0,0:13:17.71,0:13:21.11,ch,,0,0,0,,先由ViewGroup监测,再分发到childView中\N{\ren}monitoring in dispatching the views to the childViews
Dialogue: 0,0:13:21.20,0:13:24.17,ch,,0,0,0,,同时,也由ViewGroup决定是否屏蔽其子视图的事件\N{\ren}and at the same time,determining it at any give point
Dialogue: 0,0:13:24.20,0:13:28.31,ch,,0,0,0,,如果手势更多的是针对ViewGroup的话\N{\ren}if that gesture is more interesting to the parent view
Dialogue: 0,0:13:28.31,0:13:30.31,ch,,0,0,0,,理所当然就由ViewGroup接管了\N{\ren}and take over control of it
Dialogue: 0,0:13:30.37,0:13:32.42,ch,,0,0,0,,但是,这点也是有可能发生的\N{\ren}there are possibly cases
Dialogue: 0,0:13:32.51,0:13:35.54,ch,,0,0,0,,那就是孩子视图需要确保\N{\ren}where the childView needs to ensure
Dialogue: 0,0:13:35.60,0:13:38.77,ch,,0,0,0,,父视图是否可以屏蔽触摸事件\N{\ren}the parentView either temporarily or permanently
Dialogue: 0,0:13:38.80,0:13:42.05,ch,,0,0,0,,或者是暂时屏蔽抑或是永久屏蔽\N{\ren}is not able to intercept touch
Dialogue: 0,0:13:42.05,0:13:44.25,ch,,0,0,0,,要达到此目的\N{\ren}now,in order to do that
Dialogue: 0,0:13:44.31,0:13:46.68,ch,,0,0,0,,系统给我提供了这个又长又拗口的方法\N{\ren}we have this mouthful method down here
Dialogue: 0,0:13:46.71,0:13:49.97,ch,,0,0,0,,那就是requestDisallowTouchIntercept()\N{\ren}called requestDisallowTouchIntercept()
Dialogue: 0,0:13:51.02,0:13:53.77,ch,,0,0,0,,看,这个方法在这儿\N{\ren}this is what we look on right there
Dialogue: 0,0:13:54.80,0:13:55.94,ch,,0,0,0,,他们应该如此\N{\ren}they should be
Dialogue: 0,0:13:56.31,0:13:58.42,ch,,0,0,0,,它们应该在网站上的幻灯片里\N{\ren}they should be on the slide site,yes absolutely
Dialogue: 0,0:13:59.37,0:14:02.34,ch,,0,0,0,,如果不是的话,我会随后把这些东西传上去\N{\ren}if not i can make sure afterwards they are posted
Dialogue: 0,0:14:02.42,0:14:04.42,ch,,0,0,0,,因此requestDisallowTouchIntercept()\N{\ren}so requestDisallowTouchIntercept()
Dialogue: 0,0:14:04.42,0:14:07.14,ch,,0,0,0,,是一个由父视图调用的方法\N{\ren}is a method that you call on that parentView
Dialogue: 0,0:14:07.17,0:14:10.11,ch,,0,0,0,,调用时只用传入一个布尔参数即可,如果传的是true\N{\ren}and basically just has a flag that you pass true
Dialogue: 0,0:14:10.11,0:14:12.11,ch,,0,0,0,,那么此时就剥夺了\N{\ren}and that effectively blocks the
Dialogue: 0,0:14:12.11,0:14:15.48,ch,,0,0,0,,ViewGroup对那个手势的中断能力\N{\ren}ViewGroups from being able to intercept that gesture
Dialogue: 0,0:14:15.54,0:14:18.60,ch,,0,0,0,,在刚讲的滑动的例子里面\N{\ren}for whatever reason in that scrolling example
Dialogue: 0,0:14:18.68,0:14:21.82,ch,,0,0,0,,如果你自定义的子视图出于某些原因,也准备处理一些\N{\ren}you had some custom view that also need to process
Dialogue: 0,0:14:21.88,0:14:23.42,ch,,0,0,0,,拖拽事件时\N{\ren}sort of a drag event
Dialogue: 0,0:14:23.48,0:14:25.85,ch,,0,0,0,,当然,子视图外面包裹的是ScrollView\N{\ren}but it was inside of that scrolling container
Dialogue: 0,0:14:25.91,0:14:28.48,ch,,0,0,0,,这样的话,你希望暂时的由子视图去处理拖拽\N{\ren}then you may temporarily want to deal with
Dialogue: 0,0:14:28.54,0:14:32.48,ch,,0,0,0,,从而需要阻止ScrollView去处理拖拽\N{\ren}that gesture and not allow the ScrollView to intercept,so
Dialogue: 0,0:14:32.54,0:14:36.37,ch,,0,0,0,,你会把这个标识置为真一段时间,之后再清掉此标识\N{\ren}you would set the flag for a period,and then clear it again
Dialogue: 0,0:14:36.42,0:14:39.28,ch,,0,0,0,,你需要注意的是,这个标识默认\N{\ren}the thing you realize about this flag is by default
Dialogue: 0,0:14:39.31,0:14:41.82,ch,,0,0,0,,只对当前的手势有效\N{\ren}it's only set for the current gesture
Dialogue: 0,0:14:41.88,0:14:45.62,ch,,0,0,0,,因此,如果我在父视图里面调用requestDisallowIntercept() \N{\ren}so if i call a requestDisallowIntercept() on my parent
Dialogue: 0,0:14:45.68,0:14:48.08,ch,,0,0,0,,随着我的手指在屏幕上移动\N{\ren}as i moving my finger around
Dialogue: 0,0:14:48.17,0:14:50.48,ch,,0,0,0,,当动作_弹起发生\N{\ren}when the ACTION_UP is fired
Dialogue: 0,0:14:50.54,0:14:52.17,ch,,0,0,0,,又一个新的动作_按下到来时\N{\ren}and new ACTION_DOWN comes in
Dialogue: 0,0:14:52.22,0:14:54.91,ch,,0,0,0,,这意味着一个新的手势的开始,\N那么之前设置的标识就会被置空\N{\ren}it's a new gesture and that flag is auto cleared anyway
Dialogue: 0,0:14:54.97,0:14:57.02,ch,,0,0,0,,因此,当你需要这个标识的时候\N{\ren}so if you're needing to do this
Dialogue: 0,0:14:57.08,0:14:59.34,ch,,0,0,0,,你要针对特定的手势来设置此标识,意味着每次手势开始\N你都要重新调用requestDisallowIntercept()一次\N{\ren}you're having to do it on a gesture by gesture basis
Dialogue: 0,0:14:59.40,0:15:01.11,ch,,0,0,0,,这个标识可不像某些全局变量一样,不要有这样的期待,\N{\ren}not just some global flag,you can say
Dialogue: 0,0:15:01.11,0:15:02.65,ch,,0,0,0,,你对它说,"不要屏蔽我的事件"\N{\ren}don't ever intercept my touches
Dialogue: 0,0:15:02.65,0:15:04.71,ch,,0,0,0,,之后它就会永远帮你屏蔽一样\N{\ren}and expect to be that way in entire time
Dialogue: 0,0:15:04.82,0:15:07.02,ch,,0,0,0,,关于requestDisallowIntercept,我准备了一个例子\N{\ren}and i have an example of this where you can
Dialogue: 0,0:15:07.05,0:15:10.20,ch,,0,0,0,,你可以从中看出它的用处在哪\N{\ren}kind of try to see where is useful
Dialogue: 0,0:15:10.31,0:15:11.54,ch,,0,0,0,,通常\N{\ren}in general
Dialogue: 0,0:15:11.60,0:15:13.80,ch,,0,0,0,,用这个方法的时候你要格外注意\N{\ren}this is probably something you wanna use with care
Dialogue: 0,0:15:13.85,0:15:15.51,ch,,0,0,0,,因为这好像在某种程度上\N{\ren}because it starts to sort of
Dialogue: 0,0:15:15.54,0:15:17.62,ch,,0,0,0,,这开启了让孩子视图\N{\ren}it starts tearing the tables and have the childViews
Dialogue: 0,0:15:17.71,0:15:19.91,ch,,0,0,0,,去控制父视图行为的先河\N{\ren}start to control what the parent does
Dialogue: 0,0:15:19.91,0:15:21.82,ch,,0,0,0,,框架本来的设计意图是,\N{\ren}when the design of the framework is really
Dialogue: 0,0:15:21.91,0:15:24.31,ch,,0,0,0,,不论何时,都要让父视图\N{\ren}whenever possible to force the parentViews to
Dialogue: 0,0:15:24.31,0:15:26.94,ch,,0,0,0,,去控制和管理其孩子视图中的事情\N{\ren}control and manage what's going down to the children
Dialogue: 0,0:15:26.94,0:15:28.94,ch,,0,0,0,,你要把这点牢记\N{\ren}ok.just keep that in mind
Dialogue: 0,0:15:28.94,0:15:30.94,ch,,0,0,0,,\N{\ren}
Dialogue: 0,0:15:30.94,0:15:32.94,ch,,0,0,0,,好了,是时候\N{\ren}all right.let's look at a
Dialogue: 0,0:15:33.02,0:15:35.14,ch,,0,0,0,,看点视觉性的东西了\N{\ren}slightly more visual example of this
Dialogue: 0,0:15:35.14,0:15:36.68,ch,,0,0,0,,这可能会让大家更容易理解\N{\ren}which might make this a little bit clear
Dialogue: 0,0:15:36.68,0:15:38.11,ch,,0,0,0,,我刚所说的那些\N{\ren}than just seeing it all on words
Dialogue: 0,0:15:39.22,0:15:41.94,ch,,0,0,0,,首先,第一个例子是\N{\ren}so the first example that i have
Dialogue: 0,0:15:42.02,0:15:44.88,ch,,0,0,0,,一个很简单的Activity,其根视图是个FrameLayout\N{\ren}just very simple activity with the framelayout inside of it
Dialogue: 0,0:15:44.94,0:15:47.51,ch,,0,0,0,,FrameLayout里面套了一个白板View\N{\ren}and just a plain ignorant view
Dialogue: 0,0:15:47.51,0:15:49.51,ch,,0,0,0,,它不能被点击\N{\ren}you know,this view is not clickable
Dialogue: 0,0:15:49.54,0:15:51.34,ch,,0,0,0,,也不能被聚焦,反正啥也做不了,仅仅\N{\ren}focusable anything like that just a view
Dialogue: 0,0:15:51.37,0:15:52.71,ch,,0,0,0,,有一层背景而已\N{\ren}has a background on it
Dialogue: 0,0:15:52.74,0:15:54.11,ch,,0,0,0,,接下来,用户要进行交互了\N{\ren}so when the user comes in
Dialogue: 0,0:15:54.20,0:15:56.51,ch,,0,0,0,,如果用户把手指按在了这个视图身上\N{\ren}if they were to touch their finger down on that view
Dialogue: 0,0:15:56.57,0:15:59.02,ch,,0,0,0,,那么此时此刻,就是整个触摸响应链的开端\N{\ren}this the essentially the chain of calls that
Dialogue: 0,0:15:59.05,0:16:01.02,ch,,0,0,0,,那么此时此刻,就是整个触摸响应链的开端\N{\ren}you would see happen
Dialogue: 0,0:16:01.08,0:16:03.02,ch,,0,0,0,,因此,我们会从Activity的这层开始\N{\ren}so we will start at the activity level
Dialogue: 0,0:16:03.74,0:16:05.74,ch,,0,0,0,,看,在这儿呢.之后\N{\ren}over here.and then
Dialogue: 0,0:16:05.82,0:16:09.31,ch,,0,0,0,,Activity会把事件往下传递给FrameLayout\N{\ren}that would be dispatched down to the FrameLayout
Dialogue: 0,0:16:09.37,0:16:11.45,ch,,0,0,0,,通过调用其dispatchTouchEvent()方法\N{\ren}by calling its dispatchTouchEvent()
Dialogue: 0,0:16:11.45,0:16:13.45,ch,,0,0,0,,之后,就由FrameLayout往下传,直到View这一层\N{\ren}and then,finally down to the View
Dialogue: 0,0:16:13.51,0:16:14.80,ch,,0,0,0,,你懂的,我们这个例子里的View\N{\ren}you know,this View,
Dialogue: 0,0:16:14.85,0:16:17.34,ch,,0,0,0,,天生不关心各种触摸事件\N{\ren}but inherently,cares nothing about touch.though
Dialogue: 0,0:16:17.40,0:16:20.82,ch,,0,0,0,,默认的,它的onTouchEvent()会返回false\N{\ren}by default,its onTouchEvent() is gonna return false
Dialogue: 0,0:16:20.85,0:16:24.88,ch,,0,0,0,,事件链就会由此往上返回\N{\ren}and so,that will get chain back up to the FrameLayout
Dialogue: 0,0:16:24.91,0:16:28.14,ch,,0,0,0,,那么这一层的onTouchEvent()被调用\N{\ren}which will then gets its onTouchEvent() called
Dialogue: 0,0:16:28.17,0:16:29.77,ch,,0,0,0,,FrameLayout也不关心\N{\ren}and again,it doesn't care
Dialogue: 0,0:16:29.80,0:16:34.37,ch,,0,0,0,,最终,事件还是回到了Activity的onTouchEvent()方法中\N{\ren}finally,we end up back with the activity's onTouchEvent()
Dialogue: 0,0:16:34.37,0:16:36.37,ch,,0,0,0,,因此\N{\ren}so..
Dialogue: 0,0:16:36.42,0:16:40.11,ch,,0,0,0,,如果手指按下,没有视图对事件感兴趣\N{\ren}if a finger comes down and no Views are interested in this
Dialogue: 0,0:16:40.17,0:16:43.42,ch,,0,0,0,,这将会是你能在Activity的onTouchEvent()中\N{\ren}this is one of those cases were you actually would see the event
Dialogue: 0,0:16:43.48,0:16:45.25,ch,,0,0,0,,看到事件的情况之一\N{\ren}in onTouchEvent() in the activity
Dialogue: 0,0:16:45.31,0:16:48.20,ch,,0,0,0,,这种情形可能使你纠结,因为你原本以为事件\N{\ren}but you might annoyingly think that might you saw
Dialogue: 0,0:16:48.20,0:16:50.20,ch,,0,0,0,,最初会在Activity中响应,但其实反而是最后\N{\ren}they're first when actually you saw they're last
Dialogue: 0,0:16:50.20,0:16:52.20,ch,,0,0,0,,OK\N{\ren}ok..
Dialogue: 0,0:16:52.20,0:16:53.97,ch,,0,0,0,,\N{\ren}
Dialogue: 0,0:16:54.02,0:16:56.57,ch,,0,0,0,,之后,我们会把手指弹起,这次,事件传递路线又有变化了\N{\ren}then when we decide to lift their finger though,something
Dialogue: 0,0:16:56.60,0:16:58.05,ch,,0,0,0,,变化有点不寻常哦\N{\ren}quiet different happens
Dialogue: 0,0:16:58.08,0:16:59.74,ch,,0,0,0,,由于\N{\ren}again,because the
Dialogue: 0,0:16:59.77,0:17:04.08,ch,,0,0,0,,由于在视图层级中找不到视图去消费ACTION_DOWN\N{\ren}none of those views in the hierarchy try to consume ACTION_DOWN
Dialogue: 0,0:17:04.11,0:17:06.77,ch,,0,0,0,,框架就觉得吧,我又可以偷偷懒了\N{\ren}the framework is gonna just be a little bit more efficiency
Dialogue: 0,0:17:06.85,0:17:08.54,ch,,0,0,0,,既然大家连ACTION_DOWN都不喜欢\N{\ren}none of you care these events
Dialogue: 0,0:17:08.57,0:17:10.88,ch,,0,0,0,,那么ACTION_UP也不用给你们了\N{\ren}i'm not gonna continue to deliver them to you
Dialogue: 0,0:17:10.88,0:17:15.54,ch,,0,0,0,,所以用来移动事件以及结束手势的弹起事件\N{\ren}so all subsequent move events and the terminating up event that gesture
Dialogue: 0,0:17:15.60,0:17:18.02,ch,,0,0,0,,都会从Activity的dispatch\N{\ren}will simply go from the activity dispatch
Dialogue: 0,0:17:18.08,0:17:19.94,ch,,0,0,0,,直接传递到Activity的onTouchEvent()中\N{\ren}directly into activity ontouch
Dialogue: 0,0:17:19.94,0:17:21.94,ch,,0,0,0,,不会再流向视图树中的任意一个视图了\N{\ren}won't pass though any of the other views
Dialogue: 0,0:17:21.94,0:17:23.94,ch,,0,0,0,,\N{\ren}
Dialogue: 0,0:17:23.94,0:17:25.94,ch,,0,0,0,,\N{\ren}
Dialogue: 0,0:17:26.00,0:17:27.62,ch,,0,0,0,,\N{\ren}
Dialogue: 0,0:17:27.62,0:17:29.62,ch,,0,0,0,,对,我在下一个例子中会提到\N{\ren}correct,and you'll see that in the next example
Dialogue: 0,0:17:29.71,0:17:31.11,ch,,0,0,0,,在这个例子中\N{\ren}so in this example
Dialogue: 0,0:17:31.17,0:17:32.80,ch,,0,0,0,,我只是小改了一下下\N{\ren}i've changed just a little bit slightly
Dialogue: 0,0:17:32.88,0:17:35.82,ch,,0,0,0,,我用到了这个很老式的"冻酸奶"按钮\N{\ren}to use one of these very old Froyo looking Buttons
Dialogue: 0,0:17:35.82,0:17:37.82,ch,,0,0,0,,在这个例子中\N{\ren}so in this case
Dialogue: 0,0:17:37.82,0:17:39.82,ch,,0,0,0,,如果类似的情况发生\N{\ren}if that same finger comes in
Dialogue: 0,0:17:39.88,0:17:41.42,ch,,0,0,0,,这里是手指点在按钮上\N{\ren}and touches a Button
Dialogue: 0,0:17:41.45,0:17:44.14,ch,,0,0,0,,按钮是可点击的,也是可聚焦的\N{\ren}which is by default,clickable and focusable
Dialogue: 0,0:17:44.17,0:17:47.74,ch,,0,0,0,,因此按钮的onTouchEvent()就会返回true\N{\ren}and it's going to return true from its onTouchEvent()
Dialogue: 0,0:17:47.80,0:17:51.22,ch,,0,0,0,,这里,我们"按下"事件走的流程就跟刚才有所不同了\N{\ren}then the touch flow of the initial down looks very different
Dialogue: 0,0:17:51.25,0:17:53.05,ch,,0,0,0,,事件虽然也会从Activity出发\N{\ren}it's still is gonna go though
Dialogue: 0,0:17:53.05,0:17:55.57,ch,,0,0,0,,之后是Activity到ViewGroup,ViewGroup往下传给View\N{\ren}the activity,ViewGroup and View dispatch chain
Dialogue: 0,0:17:55.60,0:17:58.74,ch,,0,0,0,,但是View收到事件后,会在onTouchEvent()中返回真\N{\ren}but the View is gonna return true from onTouch()
Dialogue: 0,0:17:58.80,0:18:01.17,ch,,0,0,0,,因此,FrameLayout中的onTouchEvent()\N{\ren}so the onTouchEvent() of the frameLayout
Dialogue: 0,0:18:01.17,0:18:03.17,ch,,0,0,0,,以及随后的Activity中的onTouchEvent()\N{\ren}and subsequently the one on activity
Dialogue: 0,0:18:03.17,0:18:05.17,ch,,0,0,0,,就不会被调用了\N{\ren}will never be called
Dialogue: 0,0:18:05.25,0:18:09.11,ch,,0,0,0,,我看到的在StackOverflow上许多问题都与此有关\N{\ren}so this is where i see a source of a lot questions on StackOverflow
Dialogue: 0,0:18:09.11,0:18:12.51,ch,,0,0,0,,提问的人在Activity中的onTouchEvent()中等待事件到来\N{\ren}where people start looking at the onTouchEvent() on activity
Dialogue: 0,0:18:12.57,0:18:14.08,ch,,0,0,0,,他们摸着脑袋说,咦,我的触摸事件怎么不跑这儿\N{\ren}and saying,oh my touch events aren't here
Dialogue: 0,0:18:14.08,0:18:16.08,ch,,0,0,0,,它们去哪儿了\N{\ren}i don't know where they're going
Dialogue: 0,0:18:16.14,0:18:19.05,ch,,0,0,0,,这里的原因就是一旦事件被其他的视图给消耗了\N{\ren}it turns out this because the ones that consumed by other views
Dialogue: 0,0:18:19.08,0:18:21.54,ch,,0,0,0,,他们就不会返回给上一层了\N{\ren}will never show up there
Dialogue: 0,0:18:21.54,0:18:23.54,ch,,0,0,0,,问题来吧\N{\ren}question
Dialogue: 0,0:18:35.60,0:18:39.05,ch,,0,0,0,,如果你的确设置了点击监听器还是触摸监听器\N{\ren}if you do set a clickListener() or touchListener()
Dialogue: 0,0:19:05.40,0:19:08.42,ch,,0,0,0,,那个手势的剩下的事件?是的\N{\ren}the remaining events in that gesture? yes
Dialogue: 0,0:19:08.48,0:19:09.77,ch,,0,0,0,,所有的ACTION_MOVE跟ACTION_UP\N{\ren}all the moves and ups
Dialogue: 0,0:19:09.82,0:19:12.48,ch,,0,0,0,,而下一个ACTION_DOWN,还是会走之前的流程\N{\ren}the next down starts all over again
Dialogue: 0,0:19:12.54,0:19:16.28,ch,,0,0,0,,这就是我说的事件都是绑定到手势上的\N{\ren}so that's that bundling of a gesture that i'm talking about
Dialogue: 0,0:19:16.31,0:19:19.42,ch,,0,0,0,,很重要的一点是,随着ACTION_DOWN的到来\N所有的一切都将重新开始\N{\ren}it's really important to say that everything with down starts over
Dialogue: 0,0:19:19.42,0:19:22.11,ch,,0,0,0,,这就是为啥ACTION_DOWN是最重要的事件\N{\ren}and that's why down is the most important
Dialogue: 0,0:19:22.11,0:19:24.11,ch,,0,0,0,,嗯,嗯\N{\ren}right. right
Dialogue: 0,0:19:24.11,0:19:26.11,ch,,0,0,0,,那是对的.\N{\ren}that's correct. ok
Dialogue: 0,0:19:26.17,0:19:28.42,ch,,0,0,0,,还是这个例子\N{\ren}so,thin in this case
Dialogue: 0,0:19:28.45,0:19:31.05,ch,,0,0,0,,不管是你的手指在按钮上摩擦,还是你的手指抬起\N{\ren}when you move your finger around on the Button and then lifted
Dialogue: 0,0:19:31.05,0:19:33.05,ch,,0,0,0,,这些MOVE/UP事件都遵循同样的路径\N{\ren}all of those events flows the same path
Dialogue: 0,0:19:33.14,0:19:37.25,ch,,0,0,0,,所有的移动事件,从MOVE到UP\N{\ren}all those other events from move to up to all that
Dialogue: 0,0:19:37.31,0:19:39.88,ch,,0,0,0,,或者说你再放几根手指在上面,其产生的事件\N{\ren}you stick multiple other fingers down whatever the cases
Dialogue: 0,0:19:39.88,0:19:41.88,ch,,0,0,0,,都是从Activity到ViewGroup再到View\N{\ren}activity,ViewGroup and View
Dialogue: 0,0:19:41.88,0:19:45.22,ch,,0,0,0,,一路传递下来,最后停在Button上\N{\ren}that goes all the way back down to that Button and stops there
Dialogue: 0,0:19:46.77,0:19:49.40,ch,,0,0,0,,这点我并没有在幻灯片上显示\N{\ren}yes,i'm not showing it at here
Dialogue: 0,0:19:49.51,0:19:52.60,ch,,0,0,0,,对于FrameLayout来说,当事件传递进来后\N{\ren} but on the FrameLayout side,onIntercept is
Dialogue: 0,0:19:52.60,0:19:55.85,ch,,0,0,0,,在onInterceptTouchEvent()中还是能监控到事件的\N{\ren}receiving these are still passing though there as well
Dialogue: 0,0:19:57.34,0:19:58.42,ch,,0,0,0,,对\N{\ren}correct
Dialogue: 0,0:19:58.48,0:20:00.51,ch,,0,0,0,,你的问题正好剧透了我下一个例子\N{\ren}so,you're really good showing my next example
Dialogue: 0,0:20:00.57,0:20:01.54,ch,,0,0,0,,你的问题正好剧透了我下一个例子\N{\ren}before i get there
Dialogue: 0,0:20:01.54,0:20:02.77,ch,,0,0,0,,接下来是我的另一个例子\N{\ren}cause the next one
Dialogue: 0,0:20:02.85,0:20:05.71,ch,,0,0,0,,当我把FrameLayout改成ScrollView时\N{\ren}is if i modified this to now has ScrollView
Dialogue: 0,0:20:05.71,0:20:07.71,ch,,0,0,0,,当我把FrameLayout改成ScrollView时\N{\ren}instead of a FrameLayout,ok
Dialogue: 0,0:20:07.85,0:20:08.94,ch,,0,0,0,,在这个例子中\N{\ren}so in this case
Dialogue: 0,0:20:08.94,0:20:10.94,ch,,0,0,0,,我们还是用同一种手势\N{\ren}we will gonna have the same gesture where
Dialogue: 0,0:20:10.94,0:20:12.94,ch,,0,0,0,,还是把手指按到Button上\N{\ren}that finger comes in and drops down
Dialogue: 0,0:20:12.94,0:20:14.94,ch,,0,0,0,,就Button本身来看,事件的传递一成不变\N{\ren}so this looks as same as the Button
Dialogue: 0,0:20:15.02,0:20:18.11,ch,,0,0,0,,触摸事件会从上往下传到Button里\N{\ren}the initial touch is gonna come down to the Button
Dialogue: 0,0:20:18.14,0:20:19.80,ch,,0,0,0,,Button就把事件给消费了\N{\ren}Button is gonna consuming it
Dialogue: 0,0:20:19.85,0:20:21.31,ch,,0,0,0,,事件中止于此\N{\ren}and it's gonna stop there
Dialogue: 0,0:20:21.45,0:20:24.34,ch,,0,0,0,,之后,当我们在按钮上摩擦摩擦时\N{\ren}but now when the finger moves the Button around
Dialogue: 0,0:20:24.37,0:20:25.94,ch,,0,0,0,,你刚也看到了,Button在ScrollView中上下滚动\N{\ren}as scrolling inside the container
Dialogue: 0,0:20:25.97,0:20:27.57,ch,,0,0,0,,之后,我们释放手指\N{\ren}and then let sit up
Dialogue: 0,0:20:27.62,0:20:30.34,ch,,0,0,0,,这里的ViewGroup当然就是指ScrollView\N{\ren}the ViewGroup which is the ScrollView
Dialogue: 0,0:20:30.40,0:20:33.22,ch,,0,0,0,,一旦监测到了带有滚动的手势\N{\ren}as soon as that gesture looks like a scroll
Dialogue: 0,0:20:33.28,0:20:34.88,ch,,0,0,0,,至于怎么监测我随后再讲\N{\ren}and we will talk about how does that
Dialogue: 0,0:20:35.00,0:20:37.11,ch,,0,0,0,,先说此时此刻\N{\ren}at that exact point
Dialogue: 0,0:20:37.14,0:20:41.40,ch,,0,0,0,,ScrollView的onInterceptTouchEvent()返回了true\N{\ren}the onInterceptTouch() of the ScrollView returns true
Dialogue: 0,0:20:41.51,0:20:44.02,ch,,0,0,0,,一旦它从onIntercept中返回true\N{\ren}and as soon as it return true from that method
Dialogue: 0,0:20:44.11,0:20:46.37,ch,,0,0,0,,这里的事件分发路线就完全改变了\N{\ren}this dispatch chains change completely
Dialogue: 0,0:20:46.42,0:20:48.97,ch,,0,0,0,,此时,发生的所有事件(MOVE_UP)\N{\ren}and now,all of this pieces
Dialogue: 0,0:20:49.00,0:20:52.00,ch,,0,0,0,,直接从ScrollView的dispatch方法中\N{\ren}goes straight from the dispatch method of ScrollView
Dialogue: 0,0:20:52.02,0:20:54.20,ch,,0,0,0,,传递到ScrollView的onTouchEvent()方法中\N{\ren}into the onTouchEvent() of ScrollView
Dialogue: 0,0:20:54.20,0:20:56.20,ch,,0,0,0,,事件就不会再跑到Button里面去了\N{\ren}they don't go anywhere near the Button
Dialogue: 0,0:20:56.20,0:20:58.20,ch,,0,0,0,,关于Button那部分就直接跳过去了\N{\ren}they just jump right over that piece
Dialogue: 0,0:21:12.08,0:21:12.54,ch,,0,0,0,,是\N{\ren}yes
Dialogue: 0,0:21:12.54,0:21:15.25,ch,,0,0,0,,ViewGroup能是把事件x,y坐标转换成\N{\ren}so the job of the ViewGroup is always translate the x,y
Dialogue: 0,0:21:15.25,0:21:16.88,ch,,0,0,0,,相对于本身的x,y坐标\N{\ren}to be relative to the parent
Dialogue: 0,0:21:17.85,0:21:20.60,ch,,0,0,0,,对,每一个都是,你说的对\N{\ren}for every single one.yes,that's correct.
Dialogue: 0,0:21:35.45,0:21:36.34,ch,,0,0,0,,当然\N{\ren}sure
Dialogue: 0,0:21:36.37,0:21:39.94,ch,,0,0,0,,事件还是会先送进ViewGroup的dispatch方法里\N{\ren}so they still go though the dispatch method of the ViewGroup
Dialogue: 0,0:21:39.97,0:21:43.60,ch,,0,0,0,,因为ViewGroup工作就是把事件分发给孩子视图\N{\ren}cause the ViewGroup's job is to dispatch them to the children
Dialogue: 0,0:21:43.65,0:21:46.40,ch,,0,0,0,,当Intercept返回true时,改变的仅仅是\N{\ren}so what changes when onIntercept() returns true
Dialogue: 0,0:21:46.40,0:21:47.57,ch,,0,0,0,,ViewGroup的dispatch\N{\ren}is that ViewGroup's dispatch
Dialogue: 0,0:21:47.57,0:21:50.71,ch,,0,0,0,,直接把事件发送给ViewGroup的onTouchEvent()\N{\ren}just simply deliver directly to onTouch() of the ViewGroup
Dialogue: 0,0:21:50.71,0:21:52.71,ch,,0,0,0,,而不是把事件分发给它的孩子们\N{\ren}not to the dispatch of any of the children
Dialogue: 0,0:22:13.68,0:22:16.51,ch,,0,0,0,,唯一跳过去的是这个方法\N{\ren}the only one that skipped is this function
Dialogue: 0,0:22:17.14,0:22:19.94,ch,,0,0,0,,这个方法仍然处于事件分发链上\N{\ren}this function is still part of the dispatch chain
Dialogue: 0,0:22:24.17,0:22:25.80,ch,,0,0,0,,好吧,我重申\N{\ren}while,so the,again
Dialogue: 0,0:22:25.88,0:22:27.08,ch,,0,0,0,,关于这方面我不想涉及太多\N{\ren}we don't like talk about this
Dialogue: 0,0:22:27.14,0:22:28.28,ch,,0,0,0,,dispatch的返回值\N{\ren}but the return value of dispatch
Dialogue: 0,0:22:28.28,0:22:30.28,ch,,0,0,0,,是基于下一层孩子中的dispatch返回值\N{\ren}is based on the return value of the child
Dialogue: 0,0:22:30.60,0:22:35.05,ch,,0,0,0,,dispatch是一个一环套一环的函数调用\N{\ren}right,this is all a nested call
Dialogue: 0,0:22:35.11,0:22:37.34,ch,,0,0,0,,dispatch调用孩子的dispatch,\N孩子的dispatch调用孙子的dispatch\N{\ren}so you know,dispatch calls dispatch calls dispatch
Dialogue: 0,0:22:37.40,0:22:39.62,ch,,0,0,0,,dispatch的返回值就一层一层的往上返回\N{\ren}and return values all bubble back up
Dialogue: 0,0:22:39.71,0:22:44.57,ch,,0,0,0,,dispatch的返回值取决于其内部调用的dispatch的返回值\N{\ren}what dispatch returns based on what that method is calling inside
Dialogue: 0,0:22:44.57,0:22:46.57,ch,,0,0,0,,在我们这个例子中\N{\ren}so in the first case
Dialogue: 0,0:22:46.65,0:22:50.51,ch,,0,0,0,,ViewGroup的dispatch在这里的返回值\N{\ren}the return value of ViewGroup.dispatch in this case
Dialogue: 0,0:22:50.51,0:22:54.31,ch,,0,0,0,,取决于这个View的onTouchEvent()的返回值\N{\ren}is based on what this view's onTouchEvent() returned
Dialogue: 0,0:22:54.37,0:22:57.80,ch,,0,0,0,,dispatchTouchEvent()要干的事儿是\N{\ren}the real work of dispatchTouchEvent()
Dialogue: 0,0:22:57.80,0:22:59.80,ch,,0,0,0,,把触摸事件给路由出去\N{\ren}is to route where the touch should go
Dialogue: 0,0:22:59.88,0:23:03.05,ch,,0,0,0,,因为View的dispatch是在上一层的\NViewGroup的dispatch中调用的\N{\ren}cause dispatch is what's called by the higher level of a View
Dialogue: 0,0:23:03.05,0:23:05.34,ch,,0,0,0,,就像这样一层一层往下调用\N{\ren}like this View calls dispatch on this View,and then
Dialogue: 0,0:23:05.40,0:23:07.31,ch,,0,0,0,,此方法做作用就像是在说\N{\ren}that method's job is to say
Dialogue: 0,0:23:07.31,0:23:09.31,ch,,0,0,0,,好了,我得到了这个事件,我要把它送哪呢\N{\ren}ok,now i've got this event,where do i put it
Dialogue: 0,0:23:09.31,0:23:10.91,ch,,0,0,0,,但是事件一旦被intercept的话\N{\ren}and once it has been intercepted
Dialogue: 0,0:23:10.97,0:23:13.62,ch,,0,0,0,,我就要把事件发给我自己而不发给我的孩子\N{\ren}i hand it directly to mine method,not to a child
Dialogue: 0,0:23:13.62,0:23:15.62,ch,,0,0,0,,这就是不同之处\N{\ren}that's the difference
Dialogue: 0,0:23:15.62,0:23:17.62,ch,,0,0,0,,我讲的够清楚么\N{\ren}does it make sense
Dialogue: 0,0:23:17.62,0:23:19.62,ch,,0,0,0,,好吧,问题来吧\N{\ren}ok,question
Dialogue: 0,0:23:24.05,0:23:25.14,ch,,0,0,0,,不,他们不会这么做\N{\ren}no,they do not
Dialogue: 0,0:23:25.20,0:23:28.45,ch,,0,0,0,,在任何视图中,这些参数都是分开的\N{\ren}they are separate parameters on Scroll.. on any View
Dialogue: 0,0:23:28.48,0:23:29.97,ch,,0,0,0,,我说的是scrollX和scrollY\N{\ren}for scrollX and scrollY
Dialogue: 0,0:23:29.97,0:23:32.20,ch,,0,0,0,,取决于你是怎么处理你的滚动的\N{\ren}so depending on how you do your scrolling
Dialogue: 0,0:23:32.20,0:23:34.62,ch,,0,0,0,,我们这里刚好也有个这样的例子\N{\ren}and we actually have scrolling example in the way
Dialogue: 0,0:23:34.68,0:23:35.88,ch,,0,0,0,,我会在此例中这样做\N{\ren}i will be doing it
Dialogue: 0,0:23:35.91,0:23:38.91,ch,,0,0,0,,我修改了scrollX和scrollY的值\N{\ren}there a modify a scrollX and scrollY parameter
Dialogue: 0,0:23:38.91,0:23:41.28,ch,,0,0,0,,因此这两个值是跟View的x,y值是分开的\N{\ren}separate from the individual x,y of the View
Dialogue: 0,0:24:04.97,0:24:07.82,ch,,0,0,0,,你是在讲相对于内容而言么\N{\ren}you mean like relative to the content
Dialogue: 0,0:24:09.11,0:24:11.88,ch,,0,0,0,,对,这就是那些参数的不同之处了,对么\N{\ren}sure.so that's the difference in those parameters,right?
Dialogue: 0,0:24:11.91,0:24:15.42,ch,,0,0,0,,当触摸事件被容器视图接收时\N{\ren}when touch events are received in that container View
Dialogue: 0,0:24:15.42,0:24:19.22,ch,,0,0,0,,这时的x,y值(注:不管是事件的x,y还是View的x,y)\N就是相对于FrameLayout的\N{\ren}the x,y value is relative to the FrameLayout itself
Dialogue: 0,0:24:19.22,0:24:22.72,ch,,0,0,0,,为了让你的内容进行偏移\N{\ren}and in order offset those for your content
Dialogue: 0,0:24:22.72,0:24:27.72,ch,,0,0,0,,你就要去计算好你所需的\NscrollX,scrollY,之后设置到View里\N{\ren}you need to essentially do the math of setting the scrollX,Y
Dialogue: 0,0:24:27.74,0:24:28.74,ch,,0,0,0,,但是\N{\ren}but the
Dialogue: 0,0:24:28.80,0:24:30.17,ch,,0,0,0,,这部分是系统帮你做好\N{\ren}the part of
Dialogue: 0,0:24:30.17,0:24:33.97,ch,,0,0,0,,那就是事件如何进行分发\N{\ren}having those routed to individual childViews is done  for you
Dialogue: 0,0:24:34.02,0:24:35.97,ch,,0,0,0,,例如,我有一个按钮\N{\ren}so for instance,if i have a Button
Dialogue: 0,0:24:35.97,0:24:37.97,ch,,0,0,0,,我先讲,之后你自己看例子\N{\ren}you'll see it work on an example
Dialogue: 0,0:24:38.02,0:24:38.85,ch,,0,0,0,,如果我现在有一个按钮\N{\ren}if i have a Button
Dialogue: 0,0:24:38.85,0:24:41.75,ch,,0,0,0,,本来其位置远离屏幕,之后我滚动了屏幕,\N使其显示到了屏幕的可视范围之内\N{\ren}that's way off the screen and i scroll it on the the screen
Dialogue: 0,0:24:41.76,0:24:43.88,ch,,0,0,0,,我并不需要给触摸事件规划路线\N{\ren}i don't have to (marsize) the touch events for them
Dialogue: 0,0:24:43.88,0:24:44.88,ch,,0,0,0,,使其能传递给Button\N{\ren}to get to the Button
Dialogue: 0,0:24:44.88,0:24:46.00,ch,,0,0,0,,这事儿框架已经帮我做好了\N{\ren}the framework does that for me
Dialogue: 0,0:24:46.00,0:24:48.31,ch,,0,0,0,,只要我用上了系统的滑动机制\N{\ren}as long as i use their scrolling mechanism
Dialogue: 0,0:24:48.38,0:24:51.28,ch,,0,0,0,,你看到我演示后你会更明白\N{\ren}that might make more sense when you see it
Dialogue: 0,0:24:54.77,0:24:57.77,ch,,0,0,0,,onIntercept只有在\N{\ren}yeah,onIntercept() is only recalled
Dialogue: 0,0:24:57.77,0:25:00.67,ch,,0,0,0,,其返回true的时候才能被再次调用\N{\ren}until it returns true,at the point is never called again
Dialogue: 0,0:25:00.67,0:25:02.67,ch,,0,0,0,,那很正确\N{\ren}that's absolutely true
Dialogue: 0,0:25:02.67,0:25:04.97,ch,,0,0,0,,好的,还回到这里\N{\ren}ok,move on here
Dialogue: 0,0:25:05.00,0:25:07.57,ch,,0,0,0,,这个幻灯片上还剩最后一个点没提,\N{\ren}so,the last thing on this slide,just real quick
Dialogue: 0,0:25:07.62,0:25:11.05,ch,,0,0,0,,这点很重要\N{\ren}the last piece that happens which is kind of important
Dialogue: 0,0:25:11.08,0:25:15.97,ch,,0,0,0,,其实在Button上也会收到事件,不过收到的是动作_取消\N{\ren}is that the Button receives an ACTION_CANCEL at this point
Dialogue: 0,0:25:16.02,0:25:16.80,ch,,0,0,0,,谨记\N{\ren}ok
Dialogue: 0,0:25:16.91,0:25:18.45,ch,,0,0,0,,其被给予一个取消事件的原因是\N{\ren}now the reason that is given a cancel
Dialogue: 0,0:25:18.45,0:25:21.05,ch,,0,0,0,,因为起初是用Button来处理手势的\N{\ren}is cause it was initially handling this gesture
Dialogue: 0,0:25:21.08,0:25:24.11,ch,,0,0,0,,当Button被按下时\N{\ren}but as soon as the Button was first touched
Dialogue: 0,0:25:24.11,0:25:26.41,ch,,0,0,0,,它除了收到了动作_按下外,由于进行了拖动,\N{\ren}it receives the ACTION_DOWN and maybe even the first
Dialogue: 0,0:25:26.45,0:25:28.20,ch,,0,0,0,,Button还会收到一些ACTION_MOVE\N{\ren}the first couple of those move events
Dialogue: 0,0:25:28.20,0:25:30.50,ch,,0,0,0,,但此时,拖拽的手势已经可以被检测到了,\N于是Button上的事件就被窃取了\N{\ren}but then all of sudden that touch was stolen away from it
Dialogue: 0,0:25:30.54,0:25:32.08,ch,,0,0,0,,系统为了让Button知道\N{\ren}so in order to notify the Button
Dialogue: 0,0:25:32.08,0:25:35.88,ch,,0,0,0,,它已经不能再接收到任何事件了\N{\ren}that is not gonna be getting any more events in this gesture
Dialogue: 0,0:25:35.88,0:25:37.88,ch,,0,0,0,,所以系统就会给Button发送一个ACTION_CANCEL\N{\ren}it sent an ACTION_CANCEL instead
Dialogue: 0,0:25:37.88,0:25:39.88,ch,,0,0,0,,因此,在很多情形下,取消和弹起\N{\ren}so in many cases,CANCEL and UP
Dialogue: 0,0:25:39.88,0:25:41.88,ch,,0,0,0,,会被放在一起进行处理\N{\ren}end up being handle together
Dialogue: 0,0:25:41.88,0:25:43.88,ch,,0,0,0,,至少两者都是在\N{\ren}at last for the purpose of
Dialogue: 0,0:25:43.88,0:25:46.60,ch,,0,0,0,,手势终结时被发送进来的\N{\ren}terminating what you're doing with your gesture detection
Dialogue: 0,0:25:46.60,0:25:49.50,ch,,0,0,0,,因此,大多数情况下,对你的View来说,两者的区别不大\N{\ren}because they tend to mean almost the same thing to your View
Dialogue: 0,0:25:49.50,0:25:51.50,ch,,0,0,0,,嗯,问题来吧\N{\ren}so,the question
Dialogue: 0,0:25:58.51,0:25:59.98,ch,,0,0,0,,是的\N{\ren}yes
Dialogue: 0,0:26:02.85,0:26:06.20,ch,,0,0,0,,严谨点,你可以说,按下意味着重新设置手势\N{\ren}technically,i guess you could say down is what really resets it.
Dialogue: 0,0:26:06.20,0:26:09.10,ch,,0,0,0,,弹起和取消就像两个堂兄弟一样,\N{\ren}and UP and CANCEL you kind of just look at as cousins
Dialogue: 0,0:26:09.10,0:26:12.60,ch,,0,0,0,,都是用来结束你当前手势的事件\N{\ren}of the same event to terminate whatever you're doing in the View
Dialogue: 0,0:26:15.57,0:26:16.25,ch,,0,0,0,,嗯\N{\ren}yeah
Dialogue: 0,0:26:35.42,0:26:36.71,ch,,0,0,0,,饿\N{\ren}uh
Dialogue: 0,0:26:38.42,0:26:40.34,ch,,0,0,0,,在Activity中的onTouchEvent()能收到事件么\N{\ren}onTouchEvent() in the activity
Dialogue: 0,0:26:40.42,0:26:44.08,ch,,0,0,0,,问的好.原因在于,不过这得分情况来看了\N{\ren}good question.the reason is,and this may not always be true
Dialogue: 0,0:26:44.14,0:26:47.22,ch,,0,0,0,,我们这里用到的就是一个ScrollView和一个Button\N{\ren}it just using a basic scrollView and a basic Button
Dialogue: 0,0:26:47.28,0:26:48.54,ch,,0,0,0,,所以事件的传递就正如上所述\N{\ren}that's what ends up happening
Dialogue: 0,0:26:48.54,0:26:52.34,ch,,0,0,0,,ScrollView来用滚动的手势去\N{\ren}because the ScrollView is using those events to
Dialogue: 0,0:26:52.34,0:26:53.65,ch,,0,0,0,,滚动它的内容\N{\ren}scroll content around
Dialogue: 0,0:26:53.65,0:26:57.15,ch,,0,0,0,,不过,它的onTouchEvent()中可没有返回true\N(不然的话,Button就永远不能被点击了)\N{\ren}but its onTouchEvent() does actually not returning true
Dialogue: 0,0:26:57.17,0:26:59.85,ch,,0,0,0,,因此事件还会走完整个流程\N{\ren}so the end up still flowing all the way though
Dialogue: 0,0:26:59.88,0:27:04.02,ch,,0,0,0,,ScrollView做的是监测事件,响应事件,但是并不消费事件\N{\ren}it just monitoring them and acting them but never consume them
Dialogue: 0,0:27:04.05,0:27:05.42,ch,,0,0,0,,你可以那样做\N{\ren}you could do that
Dialogue: 0,0:27:05.42,0:27:07.72,ch,,0,0,0,,你可以自己写个自定义视图\N{\ren}i mean you could inside of a custom View
Dialogue: 0,0:27:07.72,0:27:10.02,ch,,0,0,0,,在你自定义的onTouchEvent中返回真,\N来消耗掉事件,阻碍其往上返回\N{\ren}consume all those events to keep them from going up
Dialogue: 0,0:27:10.02,0:27:12.62,ch,,0,0,0,,不过咱们的框架并没有返回true来阻碍事件上传\N{\ren}but just the way the framework get implements.that's not the case
Dialogue: 0,0:27:12.62,0:27:14.62,ch,,0,0,0,,嗯\N{\ren}yes
Dialogue: 0,0:27:25.94,0:27:27.82,ch,,0,0,0,,所以\N{\ren}so
Dialogue: 0,0:27:27.88,0:27:29.88,ch,,0,0,0,,你的意思是分3个等级对吧\N{\ren}you're talking about like three levels here,so
Dialogue: 0,0:27:29.88,0:27:33.08,ch,,0,0,0,,如果中层的ViewGroup中断了其孩子的触摸事件\N{\ren}if the mid level ViewGroup intercepts touch from its child
Dialogue: 0,0:27:33.11,0:27:34.62,ch,,0,0,0,,那么ViewGroup本身的触摸事件可以被其父中断么\N{\ren}can the parent still intercept from it
Dialogue: 0,0:27:34.62,0:27:36.62,ch,,0,0,0,,答案是当然可以\N{\ren}Absolutely
Dialogue: 0,0:27:36.62,0:27:38.92,ch,,0,0,0,,随时都可以的\N{\ren}yeah,at any time
Dialogue: 0,0:27:38.92,0:27:40.62,ch,,0,0,0,,这是\N{\ren}uh,it's
Dialogue: 0,0:27:40.71,0:27:41.94,ch,,0,0,0,,这是个一锤定音的信号\N{\ren}it's a one shot signal
Dialogue: 0,0:27:41.94,0:27:44.24,ch,,0,0,0,,我们可以在此深究一下\N{\ren}we will talk a little bit more about that,because it's
Dialogue: 0,0:27:44.28,0:27:46.68,ch,,0,0,0,,父视图可以随时对其孩子做这件事\N{\ren}it's something that a parent can do it any time on a child
Dialogue: 0,0:27:46.68,0:27:48.98,ch,,0,0,0,,但是一旦其做了(onInterceptTouchEvent()返回true)\N就不要想着还能反悔\N{\ren}but once they make that decision,they can't go back on it
Dialogue: 0,0:27:48.98,0:27:51.28,ch,,0,0,0,,一会你就能顿悟\N{\ren}ok,and that might make more sense in a second
Dialogue: 0,0:27:53.45,0:27:54.00,ch,,0,0,0,,好的,看哥这张幻灯片吧\N{\ren}all right.
Dialogue: 0,0:27:54.08,0:27:58.17,ch,,0,0,0,,这里展示的是一些针对自定义事件处理的附加参考\N{\ren}just a couple additional pieces here about doing custom touch handling
Dialogue: 0,0:27:58.20,0:28:01.85,ch,,0,0,0,,首先,如果你想要对触摸事件一个一个的进行处理\N{\ren}so if you want to handle discrete motion events
Dialogue: 0,0:28:01.85,0:28:04.15,ch,,0,0,0,,在你自定义的View中\N{\ren}for all the touches that's going on in these Views
Dialogue: 0,0:28:04.22,0:28:06.31,ch,,0,0,0,,这里有两个方法供你选择\N{\ren}then you is really kind of two options for you
Dialogue: 0,0:28:06.31,0:28:08.61,ch,,0,0,0,,一方面你可以写个子类来继承View或者ViewGroup\N{\ren}you can either create a subclass of a View or ViewGroup
Dialogue: 0,0:28:08.62,0:28:11.51,ch,,0,0,0,,这样你就可以来重写onTouchEvent()\N{\ren}so that you can override the onTouchEvent()
Dialogue: 0,0:28:11.51,0:28:15.01,ch,,0,0,0,,如果你的子类是继承自ViewGroup的话,\N你还可以在onInterceptTouchEvent()中处理事件\N{\ren}or in some cases if a ViewGroup onIntercept does well
Dialogue: 0,0:28:15.02,0:28:16.65,ch,,0,0,0,,那么另一种方法呢\N{\ren}or
Dialogue: 0,0:28:16.65,0:28:20.15,ch,,0,0,0,,你可以给视图设置一个额外的监听器onTouchEvent()\N{\ren}you can simply provide externally and onTouchListener()
Dialogue: 0,0:28:20.15,0:28:22.75,ch,,0,0,0,,在这里你也可以进行事件处理\N{\ren}and do some of your touch event handling in there
Dialogue: 0,0:28:22.82,0:28:24.25,ch,,0,0,0,,onTouchEvent跟onTouchListener并不是完全相同的\N{\ren}they are not exactly equivalent
Dialogue: 0,0:28:24.31,0:28:26.17,ch,,0,0,0,,但是大多数情况下你可以放心地\N{\ren}but they're equivalent enough that in the most cases that
Dialogue: 0,0:28:26.17,0:28:28.17,ch,,0,0,0,,认为这两个方法是一样的\N{\ren}you can probably do one on the other unchangeably
Dialogue: 0,0:28:28.40,0:28:29.48,ch,,0,0,0,,好吧\N{\ren}ok
Dialogue: 0,0:28:29.48,0:28:31.48,ch,,0,0,0,,当你在消费事件时\N{\ren}as far as i consuming events
Dialogue: 0,0:28:31.54,0:28:33.25,ch,,0,0,0,,这点我之前提到过\N{\ren}we sort talked about this already but
Dialogue: 0,0:28:33.25,0:28:34.88,ch,,0,0,0,,但是再讲讲也不为过\N{\ren}just kind of hammer at home
Dialogue: 0,0:28:34.88,0:28:38.38,ch,,0,0,0,,如果你对某些特定的事件感兴趣\N{\ren}if you're interested in any action events
Dialogue: 0,0:28:38.42,0:28:41.68,ch,,0,0,0,,尽管事实上你对ACTION_DOWN并不关心\N{\ren}even if ACTION_DOWN isn't explicitly what you care about
Dialogue: 0,0:28:41.74,0:28:43.51,ch,,0,0,0,,但是你也得对其产生兴趣\N{\ren}you do care about ACTION_DOWN
Dialogue: 0,0:28:43.57,0:28:45.34,ch,,0,0,0,,在对ACTION_DOWN处理时,你要返回true\N{\ren}you wanna return true from that event
Dialogue: 0,0:28:45.34,0:28:48.24,ch,,0,0,0,,这样你才有机会对随后的事件有接收权\N{\ren}so that subsequent events will be given to your View
Dialogue: 0,0:28:48.24,0:28:50.24,ch,,0,0,0,,饿\N{\ren}uh
Dialogue: 0,0:28:50.24,0:28:54.64,ch,,0,0,0,,当你在开发一个ViewGroup时,这点也是适用的\N{\ren}right.this is even true.if,say,you're developing a ViewGroup
Dialogue: 0,0:28:54.71,0:28:56.31,ch,,0,0,0,,因为如果\N{\ren}because if
Dialogue: 0,0:28:56.34,0:28:58.25,ch,,0,0,0,,如果你开发的ViewGroup对\N{\ren}if you're developing a ViewGroup that isn't truly
Dialogue: 0,0:28:58.25,0:29:00.25,ch,,0,0,0,,单一的触摸事件不感兴趣\N{\ren}interested in the individual touch event
Dialogue: 0,0:29:00.34,0:29:03.54,ch,,0,0,0,,可能此ViewGroup关心的是滚动或者是其他类型的监测\N{\ren}maybe it's doing scrolling or some other type of monitoring
Dialogue: 0,0:29:03.54,0:29:05.91,ch,,0,0,0,,你不能依赖你的某个孩子视图\N{\ren}you can't rely on one of your childViews
Dialogue: 0,0:29:05.97,0:29:08.08,ch,,0,0,0,,一方面来为你消费事件\N{\ren}to consume the event for you
Dialogue: 0,0:29:08.08,0:29:10.54,ch,,0,0,0,,另一方面还期待你的ViewGroup能接收事件\N{\ren}to expect you continue to get the rest of them
Dialogue: 0,0:29:10.54,0:29:14.34,ch,,0,0,0,,打个比方说,如果你在你的ViewGroup\N中的onTouchEvent()监测到了事件\N{\ren}so like as a ViewGroup,if you see that event in onTouch()
Dialogue: 0,0:29:14.37,0:29:16.60,ch,,0,0,0,,但是此ViewGroup中没有孩子视图对此事件感兴趣\N{\ren}is because no other child Views (double) with it
Dialogue: 0,0:29:16.60,0:29:19.20,ch,,0,0,0,,你就要在ViewGroup中至少把ACTION_DOWN消耗掉\N{\ren}and you're probably gonna have to least consume ACTION_DOWN
Dialogue: 0,0:29:19.20,0:29:22.10,ch,,0,0,0,,这样以来,你才能把这整个触摸事件链就收过来\N{\ren}or this whole chain is gonna be over for you as well
Dialogue: 0,0:29:22.10,0:29:24.10,ch,,0,0,0,,嗯\N{\ren}yes
Dialogue: 0,0:29:33.68,0:29:35.45,ch,,0,0,0,,不对,那将返回false(此处应为onTouchEvent的返回值)\N{\ren}no,it's gonna return false
Dialogue: 0,0:29:35.45,0:29:38.20,ch,,0,0,0,,返回true只可能是ScrollView之类的或者\N{\ren}the only ones that will,will be things like ScrollView or
Dialogue: 0,0:29:38.20,0:29:40.80,ch,,0,0,0,,某些视图,其定义的行为中会使触摸事件身涉其中\N{\ren}something that has some behavior where touches involved
Dialogue: 0,0:29:40.80,0:29:43.70,ch,,0,0,0,,要是一般的视图容器的话,那返回的就是false了\N{\ren}but just a general container gets gonna return false
Dialogue: 0,0:29:43.74,0:29:44.91,ch,,0,0,0,,就跟平常的View一样(ViewGroup是View的子类嘛)\N{\ren}just like a dumb View.
Dialogue: 0,0:29:44.91,0:29:46.91,ch,,0,0,0,,ok\N{\ren}ok
Dialogue: 0,0:29:47.02,0:29:49.20,ch,,0,0,0,,好的,那么..\N{\ren}all right.so..
Dialogue: 0,0:29:49.28,0:29:51.88,ch,,0,0,0,,关于事件传递机制我就言尽于此了.我们的下一个话题是\N{\ren}those pieces are there,next thing i wanna talk to you about
Dialogue: 0,0:29:51.88,0:29:54.48,ch,,0,0,0,,这里有人对ViewConfiguration类熟悉么\N{\ren}does anybody familiar with the ViewConfiguration class
Dialogue: 0,0:29:56.48,0:29:58.82,ch,,0,0,0,,噢,居然没有一个人知道啊\N{\ren}oh,nobody
Dialogue: 0,0:29:58.91,0:30:00.51,ch,,0,0,0,,好吧,我来教你吧.视图配置类\N{\ren}ok,cool.ViewConfiguration
Dialogue: 0,0:30:00.51,0:30:04.01,ch,,0,0,0,,会是你的朋友当你在做自定义手势时\N{\ren}is your friend when you doing custom touch handling
Dialogue: 0,0:30:04.01,0:30:06.61,ch,,0,0,0,,视图配置类里面有着\N{\ren}ViewConfiguration (holds)
Dialogue: 0,0:30:06.61,0:30:08.61,ch,,0,0,0,,很多\N{\ren}a large number and growing
Dialogue: 0,0:30:08.68,0:30:11.62,ch,,0,0,0,,常量.这些常量供框架使用\N{\ren}of constants that are used by the framework
Dialogue: 0,0:30:11.62,0:30:13.92,ch,,0,0,0,,而当你在做自定义手势时,\N{\ren}and you should be using in your applications
Dialogue: 0,0:30:13.92,0:30:17.72,ch,,0,0,0,,你也需要在你的程序中把这些常量拿来用\N来使你的事件处理跟系统的体验一致\N{\ren}to create a consistent behavior with handling touch
Dialogue: 0,0:30:17.74,0:30:18.14,ch,,0,0,0,,ok\N{\ren}ok
Dialogue: 0,0:30:18.20,0:30:20.80,ch,,0,0,0,,这里的大多数常量是跟触摸事件有关的,但不全是\N{\ren}most this have to do with touch there is couple of in there
Dialogue: 0,0:30:20.80,0:30:22.80,ch,,0,0,0,,有些也会跟画图或其他方面相关\N{\ren}that are for drawing and different things but
Dialogue: 0,0:30:22.80,0:30:25.70,ch,,0,0,0,,就大部分而言,这些常量是基于触摸的\N{\ren}for the most part,these are touch based constants
Dialogue: 0,0:30:25.74,0:30:27.31,ch,,0,0,0,,接下来我来讲几个非常重要的常量\N{\ren}so just a couple of the more important ones
Dialogue: 0,0:30:27.31,0:30:29.20,ch,,0,0,0,,除此之外,你要学会自己去采矿\N{\ren}but this is by no means all of them
Dialogue: 0,0:30:29.20,0:30:33.00,ch,,0,0,0,,首先,我要介绍的是getScaledTouchSlop()\N("获取规模化触摸面积系数")\N{\ren}the first one that i want point out to you is getScaledTouchSlop()
Dialogue: 0,0:30:33.08,0:30:36.51,ch,,0,0,0,,我谈的这些方法都是在ViewConfiguration类中调用的\N{\ren}so these are all methods that you call onViewConfiguration
Dialogue: 0,0:30:36.54,0:30:40.25,ch,,0,0,0,,你可以传给视图配置类一个context来构造一个对象\N{\ren}ViewConfiguration has a accessary instance takes context
Dialogue: 0,0:30:40.25,0:30:42.25,ch,,0,0,0,,然后,你就能调用此对象的各种方法了\N{\ren}then you can call all these methods from there
Dialogue: 0,0:30:42.25,0:30:44.25,ch,,0,0,0,,获取规模化触摸面积系数\N{\ren}but getScaledTouchSlop()
Dialogue: 0,0:30:44.31,0:30:46.85,ch,,0,0,0,,这个方法的名字起的真好,我最喜欢了\N{\ren}is probably one of my favorite names for a method
Dialogue: 0,0:30:46.85,0:30:49.45,ch,,0,0,0,,实际上,touch slop是个什么样的东西呢\N{\ren}but effectively,touch slop is
Dialogue: 0,0:30:49.48,0:30:51.37,ch,,0,0,0,,它是一个被定义的值\N{\ren}a defined value
Dialogue: 0,0:30:51.37,0:30:54.57,ch,,0,0,0,,此值用于跟触摸事件作比\N{\ren}that you should compare touch event against
Dialogue: 0,0:30:54.60,0:30:56.40,ch,,0,0,0,,来决定触摸事件\N{\ren}to make a determination of when
Dialogue: 0,0:30:56.42,0:31:00.60,ch,,0,0,0,,是否能从轻触转换为拖拽\N{\ren}the touch event has gone from a simple tap to a drag
Dialogue: 0,0:31:00.60,0:31:01.57,ch,,0,0,0,,理解否?\N{\ren}ok
Dialogue: 0,0:31:01.60,0:31:04.45,ch,,0,0,0,,你可以亲自动手体验一下此值的作用\N{\ren}so this is one of the things where you can play around with this
Dialogue: 0,0:31:04.45,0:31:05.88,ch,,0,0,0,,剧透下,咱这儿就有一个这样的例子\N{\ren}there even an example in here
Dialogue: 0,0:31:05.94,0:31:07.65,ch,,0,0,0,,你可以在你的设备上亲身体会到touch slop的作用\N{\ren}if you wanna play ... on your device
Dialogue: 0,0:31:07.68,0:31:08.45,ch,,0,0,0,,不过\N{\ren}but
Dialogue: 0,0:31:08.48,0:31:12.65,ch,,0,0,0,,通常,如果你对每一个流经某个特定View\N的触摸事件都做Log输出的话\N{\ren}in general,if you were to log every motion event
Dialogue: 0,0:31:12.71,0:31:14.40,ch,,0,0,0,,通常,如果你对每一个流经某个特定View\N的触摸事件都做Log输出的话\N{\ren}that went though your View
Dialogue: 0,0:31:14.40,0:31:16.28,ch,,0,0,0,,当你的手指停留在屏幕上时,\N{\ren}just by putting your finger on the screen and
Dialogue: 0,0:31:16.28,0:31:18.28,ch,,0,0,0,,即使你尽可能的让手指不乱动\N{\ren}trying to hold it as still as you possibly can
Dialogue: 0,0:31:18.54,0:31:19.74,ch,,0,0,0,,你会发现\N{\ren}you'll notice that
Dialogue: 0,0:31:19.80,0:31:21.74,ch,,0,0,0,,不管你的手指有多么的静止\N{\ren}even as still as you can be
Dialogue: 0,0:31:21.74,0:31:24.94,ch,,0,0,0,,你还是会看到有相当多的ACTION_MOVE流进View中\N{\ren}you'll get a ton of move events coming though
Dialogue: 0,0:31:24.97,0:31:27.42,ch,,0,0,0,,因为你的手指是个很容易颤动的东西\N{\ren}because your finger is a very (blent) object
Dialogue: 0,0:31:27.42,0:31:31.22,ch,,0,0,0,,当用于将其转换为在屏幕上表示位置的一个像素点时\N{\ren}compare to trying to turn that into a single pixel location on the screen
Dialogue: 0,0:31:31.28,0:31:32.60,ch,,0,0,0,,因此,即使仅仅\N{\ren}so even just
Dialogue: 0,0:31:32.60,0:31:36.70,ch,,0,0,0,,一点点的振动,系统为了探知你的手指的位置\N{\ren}some vibration and then trying to figure out where your finger actually is
Dialogue: 0,0:31:36.74,0:31:38.51,ch,,0,0,0,,就会产生大量的ACTION_MOVE事件\N{\ren}the move events will jump around like crazy
Dialogue: 0,0:31:38.51,0:31:41.14,ch,,0,0,0,,就连手指最轻的抽搐也不例外\N{\ren}just from them..the slightest twitch in your finger
Dialogue: 0,0:31:41.14,0:31:41.82,ch,,0,0,0,,\N{\ren}ok
Dialogue: 0,0:31:41.91,0:31:45.14,ch,,0,0,0,,因此touchSlop就要发挥作用了.系统内部会使用touchSlop\N{\ren}so the touchSlop is used and it used internally
Dialogue: 0,0:31:45.14,0:31:46.28,ch,,0,0,0,,来决定什么时候\N{\ren}this is how they determine when
Dialogue: 0,0:31:46.31,0:31:48.91,ch,,0,0,0,,ScrollView应该开始滚动或者类似的事情\N{\ren}ScrollView should start scrolling and things like that
Dialogue: 0,0:31:48.94,0:31:54.08,ch,,0,0,0,,系统会将手指移动的距离跟touchSlop常量相比\N{\ren}is they compare those distances traveled against the touchSlop constant
Dialogue: 0,0:31:54.11,0:31:57.25,ch,,0,0,0,,如果你在做滚动手势或者一些\N{\ren}if you doing scrolling or something
Dialogue: 0,0:31:57.31,0:31:59.31,ch,,0,0,0,,一些由数学计算来设计的手势时\N{\ren}were you having to do all the math yourself
Dialogue: 0,0:31:59.31,0:32:01.31,ch,,0,0,0,,就是当我们对View进行完全自定义时\N{\ren}like we were doing everything fully custom
Dialogue: 0,0:32:01.31,0:32:04.81,ch,,0,0,0,,你就能用touchSlop这个常量来对手势进行检查了\N{\ren}then touchSlop is something you're gonna wanna use that check
Dialogue: 0,0:32:04.81,0:32:07.11,ch,,0,0,0,,系统还给我们提供了用于检查Fling的常量\N{\ren}there are fling velocity checks
Dialogue: 0,0:32:07.11,0:32:10.31,ch,,0,0,0,,最小Fling速度常量和最大Fling速度常量\N{\ren}so there is actually a minimum and a maximum fling velocity
Dialogue: 0,0:32:10.31,0:32:12.97,ch,,0,0,0,,Fling是什么意思呢,Fling是\N{\ren}a fling is,this idea of
Dialogue: 0,0:32:12.97,0:32:15.40,ch,,0,0,0,,你的手指在屏幕上飞快的一划\N{\ren}your finger scrolling across the screen
Dialogue: 0,0:32:15.40,0:32:17.70,ch,,0,0,0,,当你手指离开屏幕时,屏幕的滚动还没有停止\N{\ren}and lifting quickly before stopping
Dialogue: 0,0:32:17.70,0:32:20.60,ch,,0,0,0,,Fling手势其实就是\N{\ren}is how you,you know,fling gesture is how you do
Dialogue: 0,0:32:20.65,0:32:21.62,ch,,0,0,0,,自动化的滚动\N{\ren}animate scrolling
Dialogue: 0,0:32:21.62,0:32:25.12,ch,,0,0,0,,当你"飞划"了一个能滚动的列表时,\N手指离开屏幕以后,列表还能滚动一会\N{\ren}you know,you fling the scroll list and continues to animate for a while
Dialogue: 0,0:32:25.20,0:32:26.85,ch,,0,0,0,,因为这个手势\N{\ren}that's because the gesture
Dialogue: 0,0:32:26.85,0:32:29.75,ch,,0,0,0,,在你使手指离开屏幕之前,你并没有让你的手指停下\N{\ren}you didn't stop your finger before you lifted
Dialogue: 0,0:32:29.77,0:32:32.88,ch,,0,0,0,,框架就会把此手势认为是Fling\N{\ren}and the framework considers that as a fling
Dialogue: 0,0:32:32.88,0:32:36.68,ch,,0,0,0,,前提是系统检测到的手指速度\N要大于其定义的最小"飞划"速度\N{\ren}and there is a minimum velocity that you need to check against
Dialogue: 0,0:32:36.68,0:32:39.28,ch,,0,0,0,,为了跟系统保持一致性\N{\ren}if.. to be consistent with the platform
Dialogue: 0,0:32:39.28,0:32:43.38,ch,,0,0,0,,你就要根据手势达到的速度,来让滚动滚得自然一些\N{\ren}you start animating scrolling when the gesture goes certain velocity
Dialogue: 0,0:32:43.40,0:32:45.14,ch,,0,0,0,,这里还有个最大飞划速度\N{\ren}this is also a maximum velocity
Dialogue: 0,0:32:45.20,0:32:47.45,ch,,0,0,0,,当手势的速度超过这个速度时,就不是飞划了\N{\ren}so that if it's above something
Dialogue: 0,0:32:47.45,0:32:49.45,ch,,0,0,0,,尽管我的手指飞划起来\N{\ren}although i don't think i ever has been able to that
Dialogue: 0,0:32:49.45,0:32:51.45,ch,,0,0,0,,并不能次次超过这个速度\N{\ren}effectively triggered myself
Dialogue: 0,0:32:51.45,0:32:54.05,ch,,0,0,0,,但是这点你也要考虑到,你应该将其设置为飞划的上届\N{\ren}that you should also check for the upper bound
Dialogue: 0,0:32:54.08,0:32:57.98,ch,,0,0,0,,下一次常量是scaledPagingTouchSlop\N{\ren}the next one is scaledPagingTouchSlop
Dialogue: 0,0:32:58.04,0:32:59.85,ch,,0,0,0,,此常量在ViewPager中有被用到\N{\ren}this is what they use in ViewPager
Dialogue: 0,0:32:59.85,0:33:02.45,ch,,0,0,0,,这个常量跟刚谈的touchSlop是分开的\N{\ren}so there is actually a separate slop constant
Dialogue: 0,0:33:02.45,0:33:05.95,ch,,0,0,0,,这个touch slop指的是横向滑动翻页的touch slop\N{\ren}for what they refer to is horizontal paging touch
Dialogue: 0,0:33:05.95,0:33:09.15,ch,,0,0,0,,而不是,我们常见的用于滚动的touch slop\N{\ren}as opposed to,you know,standard just regular scrolling touch
Dialogue: 0,0:33:09.17,0:33:12.45,ch,,0,0,0,,这也不是说所有横向的slop都用这个常量\N{\ren}and that doesn't mean everything horizontal uses this
Dialogue: 0,0:33:12.45,0:33:15.35,ch,,0,0,0,,比方说横向的ScrollView用的还是第一种slop来做检查\N{\ren}cause horizontal ScrollView uses regular slop checks
Dialogue: 0,0:33:15.35,0:33:18.85,ch,,0,0,0,,因此此处的slop仅仅用于ViewPager之类的视图中\N{\ren}this is really only used in paging cases like ViewPager
Dialogue: 0,0:33:18.85,0:33:22.05,ch,,0,0,0,,起初设计这两个不同的常量的主要原因是\N{\ren}and the primary reason that they have two different constants
Dialogue: 0,0:33:22.08,0:33:23.62,ch,,0,0,0,,当把ScrollView放到ViewPager中时\N{\ren}it's to allow basic things
Dialogue: 0,0:33:23.65,0:33:27.28,ch,,0,0,0,,怎样才能使两者都工作的好\N{\ren}like a ScrollView inside of a ViewPager to work well
Dialogue: 0,0:33:27.28,0:33:31.85,ch,,0,0,0,,在x轴跟y轴上,分别有两种不同的slop检查\N{\ren}there is,on the two axes,there basically a different slop check so that
Dialogue: 0,0:33:31.85,0:33:35.55,ch,,0,0,0,,这样就很容易判断出哪个轴胜出,\N以便决定你是上划还是侧滑\N{\ren}it's easier to for one of those to win when you're going up versus side ways
Dialogue: 0,0:33:35.65,0:33:39.34,ch,,0,0,0,,就不同的手机屏幕而言,\N用这些预定义的常量另外一个好处就是\N{\ren}ok,and on most platforms,the other nice thing about these constants
Dialogue: 0,0:33:39.34,0:33:41.34,ch,,0,0,0,,这些常量都是像dp之类的,其值是跟分辨率无关的\N{\ren}is these all scaled for you
Dialogue: 0,0:33:41.37,0:33:43.97,ch,,0,0,0,,所以你不用自己去找一些随机的像素点数\N{\ren}so you don't have to trying pick some random set of pixels
Dialogue: 0,0:33:44.00,0:33:45.48,ch,,0,0,0,,来充当你自己的slop检查了\N{\ren}to use as your slop check
Dialogue: 0,0:33:45.48,0:33:47.48,ch,,0,0,0,,比方说在这个屏幕上的slop检查是16像素\N{\ren}which is obviously 16px on
Dialogue: 0,0:33:47.48,0:33:50.68,ch,,0,0,0,,而在我手机上的slop检查肯定不会有16像素这么多吧\N{\ren}this screen as a lot different in 16px on my phone
Dialogue: 0,0:33:50.68,0:33:53.45,ch,,0,0,0,,因此这些常量就跟你在UI中用到的\N其他与屏幕分辨率无关的常量一样(比如说dp)\N{\ren}these are just like any other density independent things
Dialogue: 0,0:33:53.45,0:33:55.17,ch,,0,0,0,,因此这些常量就跟你在UI中用到的\N其他与屏幕分辨率无关的常量一样(比如说dp)\N{\ren} that you're trying to do in your UI
Dialogue: 0,0:33:55.17,0:33:57.60,ch,,0,0,0,,这些常量都会根据不同屏幕的密度来按比例缩放的\N{\ren}these are all scaled for you by device's densities
Dialogue: 0,0:33:57.60,0:33:59.60,ch,,0,0,0,,以使其跟你的屏幕相配\N{\ren}so that they match the screen you own
Dialogue: 0,0:34:04.25,0:34:05.08,ch,,0,0,0,,好了,看下一张幻灯片把\N{\ren}all right
Dialogue: 0,0:34:05.08,0:34:07.68,ch,,0,0,0,,这里列举了一些其他的跟自定义事件处理有关的东西\N{\ren}so then just a couple of other things
Dialogue: 0,0:34:07.68,0:34:11.18,ch,,0,0,0,,如果你想达到的目的是把事件往前传递\N{\ren}if what you trying to achieve is touch forwarding
Dialogue: 0,0:34:11.18,0:34:13.78,ch,,0,0,0,,这句话我用一个例子来解释吧\N{\ren}so let me give you an example
Dialogue: 0,0:34:13.80,0:34:15.00,ch,,0,0,0,,这个例子在实际中用处不大\N{\ren}that's probably not a good one,but
Dialogue: 0,0:34:15.00,0:34:17.00,ch,,0,0,0,,现在我有两个按钮\N{\ren}let's say you have two Buttons
Dialogue: 0,0:34:17.00,0:34:19.00,ch,,0,0,0,,并排摆着\N{\ren}side by side in a layout and
Dialogue: 0,0:34:19.05,0:34:20.48,ch,,0,0,0,,你的目的是\N{\ren}your objective goal was
Dialogue: 0,0:34:20.51,0:34:23.14,ch,,0,0,0,,每次用户按到左边的按钮时\N{\ren}every time the user touches this Button on the left
Dialogue: 0,0:34:23.20,0:34:25.80,ch,,0,0,0,,实际上,我们是想要把触摸事件传递到右边的按钮上\N{\ren}we want the events to actually go to the this Button on the right
Dialogue: 0,0:34:25.80,0:34:28.70,ch,,0,0,0,,我按到了这儿,但是那儿发生了点击事件\N{\ren}so you know,i am touching here,but i am clicking over here
Dialogue: 0,0:34:28.71,0:34:30.60,ch,,0,0,0,,肯定有比我这个更能说明问题的例子\N{\ren}there's probably a better use case for that
Dialogue: 0,0:34:30.65,0:34:32.11,ch,,0,0,0,,但是为了简单起见,咱就用这个来分析吧\N{\ren}but that's easiest one i described
Dialogue: 0,0:34:32.11,0:34:34.11,ch,,0,0,0,,达到这个目的的最佳的方法是\N{\ren}the best way to do this
Dialogue: 0,0:34:34.22,0:34:36.91,ch,,0,0,0,,虽然大多数的时候,人们\N{\ren}i mention this cause often times people
Dialogue: 0,0:34:36.91,0:34:39.81,ch,,0,0,0,,会觉得最佳的方法是当触摸事件传递到左边按钮上时\N{\ren}will think the easiest way is to take the touch events from one
Dialogue: 0,0:34:39.81,0:34:42.71,ch,,0,0,0,,在左边按钮的事件处理函数中(dispatch或者onTouchEvent)\N去调用右边按钮的onTouchEvent()来处理事件\N{\ren}and just manually call onTouchEvent() on the other Button
Dialogue: 0,0:34:42.71,0:34:45.31,ch,,0,0,0,,从技术性的角度来看,这样做是可以的\N{\ren}technically,that works a little bit,but
Dialogue: 0,0:34:45.34,0:34:48.94,ch,,0,0,0,,但是这样做的话,整个事件响应链\N的剩余部分就被你在此处给避开了\N{\ren}you're kind of circumventing all the rest of this respond chain stuff
Dialogue: 0,0:34:48.94,0:34:53.04,ch,,0,0,0,,View本身的dispatch方法除了\N{\ren}the dispatch methods of these Views do a lot more
Dialogue: 0,0:34:53.11,0:34:56.25,ch,,0,0,0,,能判断本身是否被按下之外\N{\ren}than just process internally whether the View is pressed
Dialogue: 0,0:34:56.25,0:34:58.55,ch,,0,0,0,,以及他们是否消费的事件之外,还干了许多其他的事情\N{\ren}and whether they consume the event and stuff like that
Dialogue: 0,0:34:58.60,0:35:00.28,ch,,0,0,0,,就算是一个白板View\N{\ren}i mean even just in a basic View
Dialogue: 0,0:35:00.28,0:35:03.78,ch,,0,0,0,,它的dispatch也会检查本身是否被设置了监听器,等等\N{\ren}dispatch also handles whether there is a listener there and things like that
Dialogue: 0,0:35:03.78,0:35:07.28,ch,,0,0,0,,因此如果你需要让事件隔山打牛\N{\ren}so if you're gonna forward events from one View to another
Dialogue: 0,0:35:07.28,0:35:09.88,ch,,0,0,0,,那么你的最佳做法就是按照系统的做法去做\N{\ren}which you really wanna do is do the same thing the framework does
Dialogue: 0,0:35:09.88,0:35:13.68,ch,,0,0,0,,当事件传进来的时候,调用另一个View的dispatch方法\N{\ren}take that motion event and call dispatch on the other View
Dialogue: 0,0:35:13.68,0:35:15.68,ch,,0,0,0,,这样你就能\N{\ren}and that will allow you to
Dialogue: 0,0:35:15.68,0:35:18.28,ch,,0,0,0,,有效的对事件分发链进行路由了\N{\ren}effectively reroute the dispatch chain
Dialogue: 0,0:35:18.28,0:35:20.28,ch,,0,0,0,,而且是以一种很适当的方法做到的\N{\ren}but in a more proper way
Dialogue: 0,0:35:20.28,0:35:22.28,ch,,0,0,0,,这点讲完了\N{\ren}ok
Dialogue: 0,0:35:22.28,0:35:26.08,ch,,0,0,0,,接下来是讲一点关于onIntercept的额外的东西\N{\ren}all right,then just some additional things about onIntercept
Dialogue: 0,0:35:26.14,0:35:27.71,ch,,0,0,0,,这点之前有提到过\N{\ren}we sort of talked these already,but
Dialogue: 0,0:35:27.71,0:35:30.31,ch,,0,0,0,,如果你要做自己的中断事件处理\N{\ren}you know,if you wanna do your own intercepts
Dialogue: 0,0:35:30.31,0:35:34.11,ch,,0,0,0,,你就要书写ViewGroup的子类,以至于你可以重写此方法\N{\ren}then your subclass ViewGroup so that you can override this method
Dialogue: 0,0:35:34.14,0:35:36.62,ch,,0,0,0,,onIntercept的机制是\N{\ren}and the way that onIntercept() worked is effectively
Dialogue: 0,0:35:36.62,0:35:39.52,ch,,0,0,0,,对于每个要分发给ViewGroup的事件\N{\ren}for every event that's dispatched to the ViewGroup
Dialogue: 0,0:35:39.52,0:35:42.12,ch,,0,0,0,,被分发下去之前都会检查onIntercept的返回值\N{\ren}it'll be passed into onIntercept first
Dialogue: 0,0:35:42.12,0:35:45.62,ch,,0,0,0,,只要此方法一直返回false\N{\ren}and as long as that method continues to return false
Dialogue: 0,0:35:45.66,0:35:48.16,ch,,0,0,0,,这些事件们才会走正常的传递链\N{\ren}those events will just flow though the normal chain and
Dialogue: 0,0:35:48.16,0:35:50.92,ch,,0,0,0,,由ViewGroup分发到childView里面,等等\N{\ren}be dispatched on the child views and all that stuff
Dialogue: 0,0:35:50.92,0:35:52.92,ch,,0,0,0,,一旦此方法\N{\ren}the moment that
Dialogue: 0,0:35:52.94,0:35:54.45,ch,,0,0,0,,返回true\N{\ren}returns true
Dialogue: 0,0:35:54.45,0:35:56.97,ch,,0,0,0,,那些触摸事件就停止向其孩子视图传递\N{\ren}those Events stop going down to child views
Dialogue: 0,0:35:56.97,0:36:01.67,ch,,0,0,0,,转而把关于此手势的当前事件以及后续事件\N直接分发给ViewGroup自身的onTouchEvent\N{\ren}and are immediately delivered into the onTouchEvent() for the remainder of the gesture
Dialogue: 0,0:36:01.67,0:36:04.27,ch,,0,0,0,,这个过程是不可逆转的\N{\ren}ok,and that's not something you can go back on
Dialogue: 0,0:36:04.31,0:36:08.94,ch,,0,0,0,,作为一个ViewGroup而言的话,\N一旦决定对孩子视图进行事件屏蔽\N{\ren}so as a ViewGroup,if you decide you wanna start intercepting touch events from your children
Dialogue: 0,0:36:08.97,0:36:10.85,ch,,0,0,0,,你就要对手势的后续事件全部接收\N{\ren}you're doing it for the rest of the gesture
Dialogue: 0,0:36:10.85,0:36:13.45,ch,,0,0,0,,你不能只处理一部分事件,然后再把事件还回去\N{\ren}you can't just take a couple of them and hand them back
Dialogue: 0,0:36:13.45,0:36:16.65,ch,,0,0,0,,因此做这件事儿之前,你要仔细斟酌\N{\ren}so you have to commit to that decision once you do it
Dialogue: 0,0:36:16.65,0:36:18.95,ch,,0,0,0,,你是不是需要对剩下的手势也进行处理\N{\ren}for the remainder of the gesture
Dialogue: 0,0:36:21.34,0:36:22.57,ch,,0,0,0,,好的\N{\ren}ok
Dialogue: 0,0:36:22.57,0:36:24.57,ch,,0,0,0,,这又是一些你要知道的东西\N{\ren}so just a couple things to be aware of
Dialogue: 0,0:36:25.74,0:36:27.40,ch,,0,0,0,,无论何时,..你的问题\N{\ren}when never possible,oh,your question
Dialogue: 0,0:36:27.42,0:36:31.91,ch,,0,0,0,,我的问题是关于触摸事件的处理的\N{\ren}yeah my question is about for dealing the touch event
Dialogue: 0,0:36:31.91,0:36:32.42,ch,,0,0,0,,嗯\N{\ren}sure
Dialogue: 0,0:36:32.42,0:36:36.02,ch,,0,0,0,,我们必须要把事件的坐标进行转换么\N{\ren}we have to translate the coordinate of the touch
Dialogue: 0,0:36:36.02,0:36:40.88,ch,,0,0,0,,当事件传递到下一个View时\N{\ren}to be able to actually pass it to be other...
Dialogue: 0,0:36:40.88,0:36:43.40,ch,,0,0,0,,我貌似只听到了不得不\N{\ren}i am only  (inaudible..) on the words have to
Dialogue: 0,0:36:43.45,0:36:46.74,ch,,0,0,0,,大多数情况下,你应该这么做\N{\ren}you can and probably should in most cases
Dialogue: 0,0:36:46.77,0:36:52.00,ch,,0,0,0,,...自己理解吧...亲\N{\ren}do i should go to bubble back to the View,the View its if you  (inaudible..) in parent
Dialogue: 0,0:36:52.02,0:36:52.45,ch,,0,0,0,,耶\N{\ren}yeah
Dialogue: 0,0:36:52.48,0:36:56.51,ch,,0,0,0,,...自己理解吧...(推荐:Android内核剖析)\N{\ren}(inaudible..) because the coordinates point to your location
Dialogue: 0,0:36:56.54,0:36:59.20,ch,,0,0,0,,在我那个做事件前进的例子中\N{\ren}so in the example that i have that does forwarding
Dialogue: 0,0:36:59.20,0:37:01.20,ch,,0,0,0,,我的确把视图的坐标给转换了\N{\ren}i am translating the View's coordinates
Dialogue: 0,0:37:01.20,0:37:04.40,ch,,0,0,0,,你拿着我的源码看的话,应该能看懂其所起到的作用\N{\ren}and you'll see how the..what the behavior effects
Dialogue: 0,0:37:04.40,0:37:07.00,ch,,0,0,0,,但是其效果可能不是你所期待的\N{\ren}but that may not be what you want to happen
Dialogue: 0,0:37:07.00,0:37:10.20,ch,,0,0,0,,如果你不转换其坐标的话\N{\ren}if you,but i can also describe to you at that time
Dialogue: 0,0:37:10.22,0:37:12.25,ch,,0,0,0,,会发生什么事情呢\N{\ren}what would happen if you didn't translate them
Dialogue: 0,0:37:12.25,0:37:15.15,ch,,0,0,0,,这就会导致产生一些有点不同的行为了,\N这可能是你所期待的也可能不是\N{\ren}cause this is slightly different behavior that may or may not be desirable
Dialogue: 0,0:37:15.15,0:37:19.85,ch,,0,0,0,,因此我不确定转换坐标这件事一定是必须的\N{\ren}so that's why i say i'm not sure but have to,but we'll talk about that a minute
Dialogue: 0,0:37:19.94,0:37:21.28,ch,,0,0,0,,懂否?\N{\ren}ok
Dialogue: 0,0:37:21.31,0:37:22.51,ch,,0,0,0,,装懂总会吧- -.谈下一个话题\N{\ren}so uh...
Dialogue: 0,0:37:22.51,0:37:25.41,ch,,0,0,0,,当你在你的View中重写onTouchEvent方法时\N{\ren}when you overwriting the onTouchEvent() in a View
Dialogue: 0,0:37:25.48,0:37:26.94,ch,,0,0,0,,我给你的建议是\N{\ren}my recommendation to you
Dialogue: 0,0:37:26.94,0:37:30.40,ch,,0,0,0,,你这么做的原因仅仅是由于你想处理\N{\ren}is that if you're only doing this because you want to handle
Dialogue: 0,0:37:30.40,0:37:32.40,ch,,0,0,0,,一到两个特定的事件时\N{\ren}maybe one or two specific events
Dialogue: 0,0:37:32.40,0:37:35.30,ch,,0,0,0,,你可能会对触摸事件什么时候到来感到好奇\N{\ren}may be you're curious about when the touch comes in
Dialogue: 0,0:37:35.40,0:37:38.28,ch,,0,0,0,,抑或你仅仅想要计算一下手指移动的距离\N{\ren}or may be you just wanna see when it moves a certain distance
Dialogue: 0,0:37:38.34,0:37:39.22,ch,,0,0,0,,等等一些基本的东西\N{\ren}or some of that basic stuff
Dialogue: 0,0:37:39.28,0:37:41.80,ch,,0,0,0,,你并不是要去处理所有的事件\N{\ren}that you're not really trying to handle everything
Dialogue: 0,0:37:41.80,0:37:43.51,ch,,0,0,0,,这样的话,尽可能的\N{\ren}whenever possible
Dialogue: 0,0:37:43.57,0:37:44.37,ch,,0,0,0,,调用一下父类的onTouchEvent()\N{\ren}call though the super
Dialogue: 0,0:37:44.37,0:37:47.57,ch,,0,0,0,,而不是把所有事件都交给自己\N{\ren}rather trying to handle all of these action events yourself
Dialogue: 0,0:37:47.57,0:37:49.57,ch,,0,0,0,,然后自己想出个十全十美的办法来处理\N{\ren}and coming up a right way to do that
Dialogue: 0,0:37:49.57,0:37:51.57,ch,,0,0,0,,具体来说,对于一个View\N{\ren}specifically with a View
Dialogue: 0,0:37:51.57,0:37:52.77,ch,,0,0,0,,自身的onTouchEvent()方法\N{\ren}the onTouchEvent()
Dialogue: 0,0:37:52.77,0:37:56.27,ch,,0,0,0,,其中做了很多事情来维护View的状态\N{\ren}internally does a lot of stuff maintaining state
Dialogue: 0,0:37:56.28,0:37:58.64,ch,,0,0,0,,你看,View中那些用来标记状态的标识了\N{\ren}you know all of the view flags that are set for
Dialogue: 0,0:37:58.68,0:38:02.37,ch,,0,0,0,,例如有,不可按下的标识啦,不可更改可绘制对象啦\N等等其他的标识\N{\ren}this is no pressed,the changes of the Drawable of view and all of those things
Dialogue: 0,0:38:02.40,0:38:03.80,ch,,0,0,0,,这些表示都会被设置到View的\N{\ren}that's done inside View
Dialogue: 0,0:38:03.80,0:38:07.30,ch,,0,0,0,,如果你不调用父类的方法的话,你就失去了这些特性\N{\ren}and if you don't call super,you're gonna lose that functionality
Dialogue: 0,0:38:07.30,0:38:09.60,ch,,0,0,0,,你大有可能不太高兴,像个丈二和尚,摸不着头脑\N{\ren}and you probably not gonna be very happy when you don't know why
Dialogue: 0,0:38:09.60,0:38:11.60,ch,,0,0,0,,因此,通常\N{\ren}so in general
Dialogue: 0,0:38:11.68,0:38:15.05,ch,,0,0,0,,因此我的建议是,当你处理事件时\N{\ren}what i kind of recommend is does you sort of have just a basic check for
Dialogue: 0,0:38:15.05,0:38:17.05,ch,,0,0,0,,如果你只针对2,3个事件感兴趣,\N那你就依据你的需求对其进行处理\N{\ren}maybe the two or three event types you're interested in
Dialogue: 0,0:38:17.05,0:38:19.05,ch,,0,0,0,,一旦你遇到你不想处理的事件时\N{\ren}and if it's not one of those events
Dialogue: 0,0:38:19.05,0:38:21.95,ch,,0,0,0,,与其明确的返回一个true或者false\N{\ren}rather than returning true of false explicitly
Dialogue: 0,0:38:21.95,0:38:24.55,ch,,0,0,0,,不如返回一个对父类的调用\N{\ren}just return a call though the super
Dialogue: 0,0:38:24.62,0:38:29.20,ch,,0,0,0,,处理ACTION_MOVE的时候,你要用slop对其进行检查\N{\ren}ACTION_MOVE we talked about protect those was slop checks
Dialogue: 0,0:38:29.20,0:38:31.50,ch,,0,0,0,,如果你对移动事件感兴趣\N{\ren}you know if you're interested in moves
Dialogue: 0,0:38:31.54,0:38:34.88,ch,,0,0,0,,或者说你监测到了你的手指真的是在移动\N{\ren}or actually detecting when a finger is truly moving
Dialogue: 0,0:38:34.88,0:38:38.38,ch,,0,0,0,,你需要用slop来检查这些移动事件来判断是否让其有效\N{\ren}then you need to evaluate those move events against to slop check
Dialogue: 0,0:38:38.38,0:38:40.38,ch,,0,0,0,,一会我就会给你演示\N{\ren}and i will show what's look like
Dialogue: 0,0:38:40.45,0:38:43.37,ch,,0,0,0,,你要时常考虑如何处理ACTION_CANCEL这种情况\N{\ren}and always handle ACTION_CANCEL
Dialogue: 0,0:38:43.37,0:38:48.07,ch,,0,0,0,,大多数情况下,取消跟弹起是放在一起处理的\N{\ren}in most cases,handle ACTION_CANCEL and ACTION_UP exactly the same way
Dialogue: 0,0:38:48.07,0:38:50.07,ch,,0,0,0,,但是一旦由于某些原因\N{\ren}but if for whatever reason
Dialogue: 0,0:38:50.11,0:38:53.20,ch,,0,0,0,,造成了两个之间存在着不同时\N比方说,ACTION_UP是由于用户手指弹起引起的\N{\ren}there is a difference between when the user lifts their finger
Dialogue: 0,0:38:53.20,0:38:56.10,ch,,0,0,0,,而ACTION_CANCEL是由于你的\NView中的事件被窃取时产生的\N{\ren}and when those events are stolen away from your View
Dialogue: 0,0:38:56.14,0:38:57.54,ch,,0,0,0,,那么你就要把他俩分开处理了\N{\ren}you can handle them separately
Dialogue: 0,0:38:57.54,0:38:59.48,ch,,0,0,0,,但是大多数情况下,我是把他俩放一起处理的\N{\ren}but in most cases,i usually just have them almost...
Dialogue: 0,0:38:59.48,0:39:00.74,ch,,0,0,0,,看我的手,如果你就像敲键盘一样在屏幕上乱点的话\N{\ren}if it's (inaudible) this
Dialogue: 0,0:39:00.74,0:39:03.64,ch,,0,0,0,,那你就把取消跟弹起放一起处理好了,反正此时,\N你要做的无非就是重新设置View,等等\N{\ren}cancel up,reset the View,all that stuff
Dialogue: 0,0:39:03.64,0:39:06.54,ch,,0,0,0,,最后一点,除非你要全权处理事件,否则不要屏蔽事件\N{\ren}and don't intercept events until you ready to take them all
Dialogue: 0,0:39:09.08,0:39:09.68,ch,,0,0,0,,下一张\N{\ren}all right
Dialogue: 0,0:39:09.68,0:39:12.28,ch,,0,0,0,,这些是针对多点触控的建议\N{\ren}just a couple of additional notes on multi-touch
Dialogue: 0,0:39:12.28,0:39:14.42,ch,,0,0,0,,如果你\N{\ren}so if you
Dialogue: 0,0:39:14.48,0:39:15.82,ch,,0,0,0,,如果你在做自定义事件处理\N{\ren}if you're doing custom handling
Dialogue: 0,0:39:15.82,0:39:18.12,ch,,0,0,0,,以及你要针对的是多点触摸事件\N{\ren}and you want to deal specifically with multi-touch events
Dialogue: 0,0:39:18.12,0:39:20.72,ch,,0,0,0,,这里写的这几点\N{\ren}just some additional pieces
Dialogue: 0,0:39:20.77,0:39:22.51,ch,,0,0,0,,在你处理多点移动事件时可以用得到\N{\ren}that are available on motion events
Dialogue: 0,0:39:22.51,0:39:26.91,ch,,0,0,0,,其实,不管是处理多点触控还是单点触控\N{\ren}so there is nothing really special about dealing with multi-touch over single-touch
Dialogue: 0,0:39:26.91,0:39:30.41,ch,,0,0,0,,就系统所调用的方法而言,等等,两者并无任何不同\N{\ren}in turn of the methods called by the framework or anything like that
Dialogue: 0,0:39:30.41,0:39:35.41,ch,,0,0,0,,每一个跟多点触摸有关事件的元数据,你都是能获取的\N{\ren}that additional meta data just available to you on each one of the motion events
Dialogue: 0,0:39:35.41,0:39:38.61,ch,,0,0,0,,因此这些多点移动事件同样会流经\N{\ren}so the motion events themselves will still come through
Dialogue: 0,0:39:38.61,0:39:41.51,ch,,0,0,0,,dispatch,onTouch,onIntercept等等\N{\ren}dispatch,onTouch,onIntercept all that
Dialogue: 0,0:39:41.51,0:39:45.91,ch,,0,0,0,,不同之处仅仅在于系统报告的触摸点的数量会超过1\N{\ren}the difference will be the pointer count that's reported will be greater than one
Dialogue: 0,0:39:45.94,0:39:49.02,ch,,0,0,0,,当我在屏幕上加入更多的手指时\N{\ren}so,as i bring more fingers on to the screen
Dialogue: 0,0:39:49.05,0:39:51.77,ch,,0,0,0,,MotionEvent.getPointerCount()就会根据每个事件\N{\ren}the getPointerCount() for each event will
Dialogue: 0,0:39:51.77,0:39:55.27,ch,,0,0,0,,读出当前有几个触摸点被设备跟踪记录\N{\ren}read however many of those are currently being tracked by the device
Dialogue: 0,0:39:55.31,0:39:55.71,ch,,0,0,0,,然后\N{\ren}and then
Dialogue: 0,0:39:55.71,0:39:57.71,ch,,0,0,0,,不过有时设备记录的手指数可能有限\N{\ren}that you may at some point hit a limit
Dialogue: 0,0:39:57.74,0:40:00.62,ch,,0,0,0,,拿大多数设备来说,特别是像Nexus这样的设备\N{\ren}you know,most of the devices,especially like the Nexus devices
Dialogue: 0,0:40:00.62,0:40:03.82,ch,,0,0,0,,这样的设备有能力处理\N{\ren}that we're carrying and stuff like that are able to handle
Dialogue: 0,0:40:03.82,0:40:07.02,ch,,0,0,0,,你一只手上的所有手指,可能还不止\N{\ren}you know,basically all the touch points on your finger and may be more
Dialogue: 0,0:40:07.02,0:40:10.52,ch,,0,0,0,,那么getPointerCount的返回值就有可能达到5或者6等等\N{\ren}so you can get that value up to 5 or 6 whatever
Dialogue: 0,0:40:10.52,0:40:13.12,ch,,0,0,0,,当然市场上也有些设备\N{\ren}but there may still be devices in the market that
Dialogue: 0,0:40:13.12,0:40:15.12,ch,,0,0,0,,不能监测到2个或3个以上的触摸点\N{\ren}can't really get you more than 2 or 3
Dialogue: 0,0:40:15.12,0:40:18.92,ch,,0,0,0,,要是在这样的设备上操作的话,\N随着你手指数增加到不能再增加\N{\ren}so you may start getting to the point where as you add more fingers
Dialogue: 0,0:40:18.92,0:40:22.72,ch,,0,0,0,,你再放进来的手指所激发的触摸事件\N就会有点像事件瞬移,因为事件激发数大于可监测手指数\N{\ren}it just reports events like the last finger you touched is now moved over here
Dialogue: 0,0:40:22.77,0:40:23.71,ch,,0,0,0,,而不是像我们刚才所说的新增一个触摸监测点\N{\ren}rather than adding a new one
Dialogue: 0,0:40:23.71,0:40:27.21,ch,,0,0,0,,其原因就在于你达到了设备所能监测到的触摸点的最大值\N{\ren}cause you hit the maximum number pointer they can actually detect
Dialogue: 0,0:40:27.28,0:40:29.05,ch,,0,0,0,,如何规避这样的限制呢,其实有种叫市场过滤器的东西\N{\ren}and there are market filters for that
Dialogue: 0,0:40:29.05,0:40:32.85,ch,,0,0,0,,这玩意儿我没有写在PPT上,\N但是这些东西在安卓开发网站上有定义\N{\ren}i don't have them on the slides but there is a define on the developer site
Dialogue: 0,0:40:32.85,0:40:35.75,ch,,0,0,0,,有一种市场过滤器是针对触摸屏类型来过滤的\N{\ren}there are market filters for touch screen type
Dialogue: 0,0:40:35.77,0:40:38.94,ch,,0,0,0,,用其可以过滤多点触摸屏支持的触摸点数\N{\ren}that have to do with the number of multi-touch points
Dialogue: 0,0:40:38.94,0:40:41.84,ch,,0,0,0,,用其可以过滤多点触摸屏支持的触摸点数\N{\ren}that device can support,so for whatever reason,if
Dialogue: 0,0:40:41.84,0:40:45.64,ch,,0,0,0,,比如,你有个手势,此手势需要五个手指来参与\N{\ren}you wanna to have a gesture that required for all five fingers
Dialogue: 0,0:40:45.71,0:40:48.17,ch,,0,0,0,,此时,你就可以给你的程序里面设置一个过滤器\N{\ren}then you could pass a filter
Dialogue: 0,0:40:48.17,0:40:50.17,ch,,0,0,0,,来挑选特定的触摸屏\N{\ren}that particular device touch screen
Dialogue: 0,0:40:50.22,0:40:53.40,ch,,0,0,0,,以便能够支持此种手势,\N这样的过滤器我记得好像叫"爵士乐手过滤器"吧\N{\ren}supports the (what i believe is the jazz hands filter)
Dialogue: 0,0:40:53.40,0:40:57.20,ch,,0,0,0,,意思是其能够过滤出支持这么多触摸点的触摸屏\N{\ren}meaning that it has the ability to handle that many touch points
Dialogue: 0,0:40:57.20,0:40:58.05,ch,,0,0,0,,\N{\ren}ok
Dialogue: 0,0:40:58.11,0:40:59.60,ch,,0,0,0,,\N{\ren}
Dialogue: 0,0:40:59.62,0:41:01.51,ch,,0,0,0,,如果你对何时\N{\ren}multi-touch,if you are interested in when
Dialogue: 0,0:41:01.51,0:41:04.17,ch,,0,0,0,,事件会按下以及何时事件会弹起感兴趣的话\N{\ren}those events actually come down and come back up
Dialogue: 0,0:41:04.17,0:41:07.67,ch,,0,0,0,,你就要用到ACTION_POINTER_DOWN和UP了\N{\ren}that's what that ACTION_POINTER up and down come from
Dialogue: 0,0:41:07.67,0:41:11.77,ch,,0,0,0,,由前面可以知道ACTION_DOWN跟UP\N发生在第一根手指按下和弹起时\N{\ren}so ACTION_UP and DOWN will always be fired when the first finger hit the screen
Dialogue: 0,0:41:11.82,0:41:14.74,ch,,0,0,0,,但是当我将第2,第3,第4根手指按在屏幕上时\N{\ren}but as soon as i hit number 2,3,4
Dialogue: 0,0:41:14.74,0:41:19.14,ch,,0,0,0,,每根手指按下都会产生POINTER_DOWN,手指弹起是UP\N{\ren}each of those events will fire of with POINTER_DOWN or POINTER_UP
Dialogue: 0,0:41:19.14,0:41:21.11,ch,,0,0,0,,直到我们在屏幕上的手指只剩下一根\N{\ren}until we were back to one finger
Dialogue: 0,0:41:21.11,0:41:23.11,ch,,0,0,0,,当这最后一根手指也释放时,那就是ACTION_UP了\N{\ren}and the last one will be ACTION_UP
Dialogue: 0,0:41:23.11,0:41:23.97,ch,,0,0,0,,\N{\ren}ok
Dialogue: 0,0:41:24.05,0:41:25.48,ch,,0,0,0,,作为关于这个知识点的一部分\N{\ren}and as part of this
Dialogue: 0,0:41:25.51,0:41:30.02,ch,,0,0,0,,按在屏幕上的每根手指或者说屏幕上的每个触摸点\N都会有一个index跟id\N{\ren}each individual finger or pointer will be given an index and an id
Dialogue: 0,0:41:30.02,0:41:33.22,ch,,0,0,0,,你可以用其来对整个手势每个触点做跟踪记录\N{\ren}that you can use to track them though out the gesture
Dialogue: 0,0:41:33.25,0:41:33.80,ch,,0,0,0,,\N{\ren}ok
Dialogue: 0,0:41:33.82,0:41:36.25,ch,,0,0,0,,index跟id的不同之处在于\N{\ren}the difference between the two
Dialogue: 0,0:41:36.25,0:41:39.15,ch,,0,0,0,,触摸点的id是固定的,但是其索引就不是的\N{\ren}is pointer id is stable and index is not
Dialogue: 0,0:41:39.15,0:41:41.75,ch,,0,0,0,,我还是举个例子吧\N{\ren}ok.in that example where
Dialogue: 0,0:41:41.77,0:41:42.85,ch,,0,0,0,,要是我有\N{\ren}i have
Dialogue: 0,0:41:42.91,0:41:45.22,ch,,0,0,0,,3个手指放在了屏幕上\N{\ren}3 fingers that i push down on my screen here
Dialogue: 0,0:41:45.25,0:41:46.94,ch,,0,0,0,,那么这3个触摸点的id依次是0,1,2\N{\ren}those are pointer 0 1 and 2
Dialogue: 0,0:41:46.94,0:41:48.94,ch,,0,0,0,,同样其index也是0,1,2\N{\ren}and also index 0 1 and 2
Dialogue: 0,0:41:48.94,0:41:52.44,ch,,0,0,0,,但是一旦我让第二根放下的手指离开\N{\ren}but as soon as i lift that second finger i put down
Dialogue: 0,0:41:52.44,0:41:55.94,ch,,0,0,0,,那么屏幕上剩下的触摸点的id还是0跟2\N{\ren}now,these pointers are still 0 and 2 for their id
Dialogue: 0,0:41:55.94,0:41:57.94,ch,,0,0,0,,但是其相对应的index就会变成0跟1\N{\ren}but the indexes between 0 and 1
Dialogue: 0,0:41:57.94,0:42:02.34,ch,,0,0,0,,index更多的是在讲,这儿还有多少POINTER在啊,\N以及我可以迭代多少POINTER啊\N{\ren}so that the index is more related to how many are there and iterating though them
Dialogue: 0,0:42:02.34,0:42:07.04,ch,,0,0,0,,而id就是个稳定的值,用于对按下的触摸点进行跟踪记录\N{\ren}the id is the stable value for as that pointer is tracking around the screen
Dialogue: 0,0:42:07.04,0:42:10.54,ch,,0,0,0,,这样你就能据此决定当释放一根手指时,应该做什么事情\N{\ren}so that you can determine if they lift up a finger what i should do now
Dialogue: 0,0:42:10.54,0:42:13.74,ch,,0,0,0,,通常,你会看到系统这么干\N{\ren}and often times,what you will see with the framework,cause
Dialogue: 0,0:42:13.74,0:42:15.45,ch,,0,0,0,,当你从3根手指减少到2根时\N{\ren}if you go to 3 fingers and then down to 2
Dialogue: 0,0:42:15.45,0:42:18.35,ch,,0,0,0,,这有点像个缩放的手势或者与其类似的\N{\ren}and it's like a scale gesture or something along those lines
Dialogue: 0,0:42:18.37,0:42:20.94,ch,,0,0,0,,此时系统就会把你离开的那个手指的index后面的事件\N{\ren}it will just transfer for the events that we were on the latest pointer
Dialogue: 0,0:42:20.94,0:42:24.74,ch,,0,0,0,,转换到这个index下,后面的以此类推,等等\N{\ren}to whatever the next one is in that index,something along those lines
Dialogue: 0,0:42:24.74,0:42:26.74,ch,,0,0,0,,但是这种转换不是绝对的\N{\ren}but it could be application's specific
Dialogue: 0,0:42:26.74,0:42:28.74,ch,,0,0,0,,\N{\ren}ok
Dialogue: 0,0:42:31.08,0:42:33.34,ch,,0,0,0,,这又是一件你要知道的事情\N{\ren}another thing to be aware of
Dialogue: 0,0:42:33.34,0:42:36.54,ch,,0,0,0,,这点可能跟你的应用没有什么关系,这点叫成批事件混合\N{\ren}which may or may not effect to application is event batching
Dialogue: 0,0:42:37.80,0:42:39.31,ch,,0,0,0,,默认地\N{\ren}so by default
Dialogue: 0,0:42:39.31,0:42:44.31,ch,,0,0,0,,当你在你的程序中从View中得到触摸事件时\N{\ren}when you get all of these motion events into your Views in your application
Dialogue: 0,0:42:44.31,0:42:46.91,ch,,0,0,0,,实际上,你并没有监测到每一个单独的事件\N{\ren}you're not actually getting every singe one
Dialogue: 0,0:42:46.91,0:42:50.41,ch,,0,0,0,,其实关于这一点,就仅仅是ACTION_MOVE这个事件了\N{\ren}and this is really only true for ACTION_MOVE
Dialogue: 0,0:42:50.41,0:42:53.61,ch,,0,0,0,,当你的手指在屏幕上划来划去时\N{\ren}but as the finger is moving around the screen
Dialogue: 0,0:42:53.61,0:42:56.21,ch,,0,0,0,,虽然移动事件的确分发给了你\N{\ren}the move events that are actually delivered to you
Dialogue: 0,0:42:56.31,0:42:58.00,ch,,0,0,0,,但是这些事件是成批处理过之后的事件\N{\ren}are happening in batches
Dialogue: 0,0:42:58.08,0:43:01.08,ch,,0,0,0,,实际上,系统中的移动事件比你想象中的多很多\N{\ren}so there are significantly more events being generated by
Dialogue: 0,0:43:01.08,0:43:03.68,ch,,0,0,0,,当然这些事件是由硬件以及内核驱动产生的\N{\ren}the hardware and the kernel driver and all those pieces
Dialogue: 0,0:43:03.74,0:43:06.51,ch,,0,0,0,,而当这些事件跑进\N{\ren}then what,actually get bubbled up into calls
Dialogue: 0,0:43:06.51,0:43:08.51,ch,,0,0,0,,dispatch跟onTouchEvent这些函数中时,\N事件以及被成批处理过了\N{\ren}in dispatch,onTouchEvent
Dialogue: 0,0:43:08.51,0:43:10.81,ch,,0,0,0,,不过这并不是说这些触摸点信息就丢失了\N{\ren}but it doesn't mean those pointers are lost
Dialogue: 0,0:43:10.81,0:43:13.41,ch,,0,0,0,,那么,这点在你的程序中是如何体现的呢\N{\ren}so effectively the way that this looks to your application
Dialogue: 0,0:43:13.41,0:43:17.51,ch,,0,0,0,,体现在每次有事件到来时,你在你的事件回调中\N{\ren}is every time a motion event is fired,and you get that callback
Dialogue: 0,0:43:17.51,0:43:20.41,ch,,0,0,0,,关于事件成批处理中的最近发生的事件\N{\ren}the most recent of that event batch
Dialogue: 0,0:43:20.48,0:43:21.85,ch,,0,0,0,,就是你事件回调中得到的事件\N{\ren}is what you're looking at
Dialogue: 0,0:43:21.85,0:43:25.35,ch,,0,0,0,,当你请求获取此次触摸事件中X,Y的位置时\N{\ren}when you make a request of give me the x and y location of this touch
Dialogue: 0,0:43:25.37,0:43:26.54,ch,,0,0,0,,或者其他请求时\N{\ren}and all of those things
Dialogue: 0,0:43:26.54,0:43:29.44,ch,,0,0,0,,最终你得到的结果都是从成批事件处理中\N的最后一个事件中得到的\N{\ren}what you're looking like is the latest event in the batch
Dialogue: 0,0:43:29.57,0:43:31.05,ch,,0,0,0,,但是,如果基于某种原因,你需要\N{\ren}but if for whatever reason,you need
Dialogue: 0,0:43:31.08,0:43:34.37,ch,,0,0,0,,你需要对系统生成的每一个事件都做监测的话\N{\ren}every single event that was generated by the hardware
Dialogue: 0,0:43:34.40,0:43:36.37,ch,,0,0,0,,可能你要用这些来构建一个路径\N{\ren}you know,maybe you're trying to construct the path
Dialogue: 0,0:43:36.40,0:43:37.37,ch,,0,0,0,,或者些其他的原因\N{\ren}or whatever the cases
Dialogue: 0,0:43:37.37,0:43:41.17,ch,,0,0,0,,反正你就是想要得到每一个单独的事件,然后拿来用\N{\ren}you wanna make sure that every single point is available to you you can use
Dialogue: 0,0:43:41.17,0:43:45.11,ch,,0,0,0,,那么,你就可以运用这些在MotionEvent类中\N提供的与历史有关的方法\N{\ren}you can these historical methods on MotionEvent
Dialogue: 0,0:43:45.17,0:43:48.42,ch,,0,0,0,,这些方法有返回x,y的,还有返回事件发生时间的\N{\ren}and it will return to you the x,y event time,you know
Dialogue: 0,0:43:48.42,0:43:51.02,ch,,0,0,0,,每一个单独事件的所有元数据都能获取得到\N{\ren}all the meta data that's available for the single event
Dialogue: 0,0:43:51.02,0:43:54.52,ch,,0,0,0,,不过得到的都是成批处理事件中的\N{\ren}but for every single previous event in that batch
Dialogue: 0,0:43:54.57,0:43:57.57,ch,,0,0,0,,这些方法还会告诉你,此次成批处理中一共有多少事件\N{\ren}and it will also tell you for each motion event how many there are
Dialogue: 0,0:43:57.57,0:43:59.57,ch,,0,0,0,,这样你就可以知道你一共要检索多少事件了\N{\ren}so that you know how far you have to look back
Dialogue: 0,0:43:59.57,0:44:01.57,ch,,0,0,0,,谈下一个话题\N{\ren}ok
Dialogue: 0,0:44:03.82,0:44:06.05,ch,,0,0,0,,这里要讲的是悬停事件\N{\ren}just a little about hover events
Dialogue: 0,0:44:06.08,0:44:07.31,ch,,0,0,0,,这些事件不是\N{\ren}these are not
Dialogue: 0,0:44:07.31,0:44:10.60,ch,,0,0,0,,超级有用,以及超级常用.但是了解一下没坏处\N{\ren}super useful and general,but just be aware of they exist there
Dialogue: 0,0:44:10.60,0:44:13.20,ch,,0,0,0,,它们跟触摸事件没有显著不同\N{\ren}they're not significantly different from touch events
Dialogue: 0,0:44:13.22,0:44:15.05,ch,,0,0,0,,这些可能是在\N{\ren}they've been around since
Dialogue: 0,0:44:15.08,0:44:16.74,ch,,0,0,0,,冰激凌三明治(4.0)之后才加入的吧\N{\ren}IceCreamSandwitch i think
Dialogue: 0,0:44:16.74,0:44:18.48,ch,,0,0,0,,API等级是14,那么就是ICS之后才有的了\N{\ren}the slide's 14,so we will trust that
Dialogue: 0,0:44:18.48,0:44:21.98,ch,,0,0,0,,基本上,这些算是\N{\ren}they're basically just additional events
Dialogue: 0,0:44:22.00,0:44:24.34,ch,,0,0,0,,你能在MotionEvent里面看到的一些额外事件了\N{\ren}that you might see inside of motion events
Dialogue: 0,0:44:24.34,0:44:27.24,ch,,0,0,0,,对于悬停来讲有3个事件,进入悬停,停止悬停,\N{\ren}so the actions for hover,ENTER and EXIT
Dialogue: 0,0:44:27.28,0:44:28.28,ch,,0,0,0,,悬停移动\N{\ren}and MOVE
Dialogue: 0,0:44:28.34,0:44:31.22,ch,,0,0,0,,你看,这些都是带有ACTION前缀的\N{\ren}as what you might see is the action value
Dialogue: 0,0:44:31.28,0:44:33.60,ch,,0,0,0,,因此他们也属于移动事件的\N{\ren}of one of these motion event objects
Dialogue: 0,0:44:33.60,0:44:36.80,ch,,0,0,0,,由于都是MotionEvent类的对象,因此\N悬停事件也会被传入到相同的函数回调中\N{\ren}but it's the same object (otherwise) they gets passed into the callback
Dialogue: 0,0:44:36.80,0:44:39.70,ch,,0,0,0,,悬停事件跟普通的触摸事件不同之处在于\N{\ren}the difference between a hover and a traditional touch event
Dialogue: 0,0:44:39.70,0:44:44.40,ch,,0,0,0,,悬停事件其实...他们是为那些点击设备而设计的\N{\ren}hover events are..think them as they're designed for things like a pointing device
Dialogue: 0,0:44:44.40,0:44:47.90,ch,,0,0,0,,可能是个智能笔之类的东西吧\N{\ren}maybe like a smart pen device or something along those lines
Dialogue: 0,0:44:47.90,0:44:50.80,ch,,0,0,0,,好吧,我能想到的最好的例子就是鼠标了\N{\ren}if...my best example is a mouse
Dialogue: 0,0:44:50.80,0:44:53.70,ch,,0,0,0,,如果你给你的Android平板上插个鼠标的话\N{\ren}if you were to plug a mouse into your android tablet
Dialogue: 0,0:44:53.70,0:44:58.70,ch,,0,0,0,,当鼠标的指针悬停到某个视图上时,\N尽管你没有点击此视图\N{\ren}then as that pointing device hovers over the View even though you didn't click on it
Dialogue: 0,0:44:58.70,0:45:01.00,ch,,0,0,0,,但此时悬停事件已经被触发了\N{\ren}those were generally hover events
Dialogue: 0,0:45:01.00,0:45:03.60,ch,,0,0,0,,这里点击设备实际上是盖住了View的一部分\N{\ren}so the pointing devices is actually over the View
Dialogue: 0,0:45:03.60,0:45:06.80,ch,,0,0,0,,这种情况下既不能认为它是触摸也不能认为它是按下\N{\ren}but it's not the same as you would consider a touch or press
Dialogue: 0,0:45:06.82,0:45:08.40,ch,,0,0,0,,所以,此时被认为是\N{\ren}and so at that point
Dialogue: 0,0:45:08.40,0:45:11.30,ch,,0,0,0,,HOVER_ENTER或EXIT如果你没有移动鼠标的话\N{\ren}those ENTER and EXIT doesn't moves over
Dialogue: 0,0:45:11.30,0:45:14.20,ch,,0,0,0,,也可以被认为是HOVER_MOVE,\N当你在View的边界内移动时\N{\ren}or MOVE as it's moving around inside those bounds
Dialogue: 0,0:45:14.20,0:45:17.10,ch,,0,0,0,,这些HOVER事件就会由系统产生,\N然后被传递到回调函数中\N{\ren}will be generated and called back to your application
Dialogue: 0,0:45:17.10,0:45:19.10,ch,,0,0,0,,这里需要额外说明一点的是\N{\ren}now,the only additional piece here
Dialogue: 0,0:45:19.10,0:45:21.40,ch,,0,0,0,,这些事件的回调函数跟普通触摸事件的回调函数不一样\N{\ren}is they won't go through the same callback methods
Dialogue: 0,0:45:21.40,0:45:23.70,ch,,0,0,0,,这些事件不会在onTouchEvent中监测的到\N{\ren}so you won't get these through onTouchEvent
Dialogue: 0,0:45:23.70,0:45:27.20,ch,,0,0,0,,而是会跑到另一种回调函数中onGenericMotionEvent()\N{\ren}you'll get them through a separate method call onGenericMotionEvent
Dialogue: 0,0:45:27.20,0:45:31.20,ch,,0,0,0,,除此之外,Hover回调函数中给的对象与Touch的并无二致\N{\ren}but other than that,the object you're given is exactly the same
Dialogue: 0,0:45:31.25,0:45:35.05,ch,,0,0,0,,都是MotionEvent类对象,里面存有x,y坐标等等\N{\ren}it's motion event with x,y,you know,that stuff
Dialogue: 0,0:45:35.05,0:45:37.05,ch,,0,0,0,,正确\N{\ren}correct
Dialogue: 0,0:45:37.05,0:45:40.25,ch,,0,0,0,,再次注意,这两个回调函数是分开的,\NonTouchEvent是为点按服务的\N{\ren}so there're two separate callbacks onTouchEvent for the taps
Dialogue: 0,0:45:40.25,0:45:43.15,ch,,0,0,0,,onGenericMotionEvent()就是对这些移动事件做服务的\N{\ren}and onMotionEvent for these motions
Dialogue: 0,0:45:43.15,0:45:45.45,ch,,0,0,0,,让我们再会到那个鼠标的例子\N{\ren}let's go back to the example of the mouse
Dialogue: 0,0:45:45.45,0:45:48.05,ch,,0,0,0,,当我把鼠标悬停在按钮上时\N{\ren}let's say as i hover the mouse over the Button
Dialogue: 0,0:45:48.05,0:45:50.95,ch,,0,0,0,,这些悬停事件就由onGenericMotion产生\N{\ren}those hover events are generated to onGenericMotion
Dialogue: 0,0:45:50.95,0:45:54.45,ch,,0,0,0,,但是我一旦用鼠标点击了按钮的话,\N这时事件就会交给onTouchEvent处理了\N{\ren}as soon as i click the Button,that's gonna be onTouchEvent() just like a finger
Dialogue: 0,0:45:54.45,0:45:57.05,ch,,0,0,0,,在某些时候\N{\ren}ok,at some point
Dialogue: 0,0:45:57.05,0:45:59.05,ch,,0,0,0,,关于触摸事件的行为是具有一致性的\N{\ren}that way that behaviors are consisted
Dialogue: 0,0:45:59.05,0:46:01.05,ch,,0,0,0,,仅仅是当这些特殊的动作到来时\N{\ren}just for these additions actions there
Dialogue: 0,0:46:01.05,0:46:04.55,ch,,0,0,0,,在你用到这玩意儿的时候,我还要给你的忠告\N{\ren}ok,and just another thing to keep in mind if you're playing around with this stuff
Dialogue: 0,0:46:04.62,0:46:08.60,ch,,0,0,0,,默认地,在holo主题下,所有的可绘制对象\N{\ren}by default,none of the drawables in the holo theme
Dialogue: 0,0:46:08.60,0:46:10.60,ch,,0,0,0,,(holo主题也是系统框架的一部分)\N{\ren}the another piece is a part of the framework
Dialogue: 0,0:46:10.60,0:46:12.60,ch,,0,0,0,,是没有悬停状态的\N{\ren}have hover states
Dialogue: 0,0:46:12.65,0:46:13.74,ch,,0,0,0,,因此,当你切换\N{\ren}so as you toggling
Dialogue: 0,0:46:13.74,0:46:17.54,ch,,0,0,0,,当你在按钮上切换到悬停状态时\N{\ren}as you may be playing around and trying to toggle hover states on you Buttons
Dialogue: 0,0:46:17.57,0:46:20.34,ch,,0,0,0,,你就不要期望按钮本身的可视性会变化等等\N{\ren}don't expect to change visibility or anything like that
Dialogue: 0,0:46:20.34,0:46:21.88,ch,,0,0,0,,比如当你按下按钮时,你会发现按钮被点击了.\N但是当你悬停时,你就不要期待类似的事情会发生\N{\ren}like it does when you press it
Dialogue: 0,0:46:21.88,0:46:24.78,ch,,0,0,0,,因为框架里面并没有预设任何的悬停状态的可视化对象\N{\ren}the framework doesn't add any visual states for the stuff
Dialogue: 0,0:46:24.80,0:46:27.40,ch,,0,0,0,,因此,这事儿系统就会交给你来干了\N{\ren}it does have the ability for you to do so
Dialogue: 0,0:46:27.40,0:46:30.30,ch,,0,0,0,,系统定义了一种状态state_action_hover\N{\ren}there is a state action_hover
Dialogue: 0,0:46:30.31,0:46:34.51,ch,,0,0,0,,你可以在你的selector文件中给这个状态设置图片\N就跟你对state_pressed或者selected或者focused设置一样\N{\ren}that you could put it in a selector just like state_pressed,selected or focused
Dialogue: 0,0:46:34.60,0:46:35.51,ch,,0,0,0,,等等诸如此类的\N{\ren}something like that
Dialogue: 0,0:46:35.51,0:46:39.01,ch,,0,0,0,,但是默认地,系统主题没有给可绘制对象设置这些\N{\ren}but by default,those are unset to anything on the system themes
Dialogue: 0,0:46:39.01,0:46:41.01,ch,,0,0,0,,是\N{\ren}yes
Dialogue: 0,0:46:47.08,0:46:48.37,ch,,0,0,0,,不是\N{\ren}no
Dialogue: 0,0:46:48.37,0:46:51.27,ch,,0,0,0,,框架没有把那种信息曝漏出来\N{\ren}no,that type of information is not exposed to the framework
Dialogue: 0,0:46:51.31,0:46:54.20,ch,,0,0,0,,老实讲,就连我刚说的\N{\ren}and to be honest,even the capabilities of the screen
Dialogue: 0,0:46:54.20,0:46:57.10,ch,,0,0,0,,触摸屏所能支持的触摸点数\N{\ren}as far as,say,how many touch points that supports
Dialogue: 0,0:46:57.10,0:47:00.60,ch,,0,0,0,,在程序的运行时也是获取不到的\N{\ren}is not something that's available at runtime to the application
Dialogue: 0,0:47:00.60,0:47:03.80,ch,,0,0,0,,充其量,你只能做到\N{\ren}at best,the only capabilities you have is to
Dialogue: 0,0:47:03.88,0:47:05.45,ch,,0,0,0,,把过滤条件放到你的manifest中\N{\ren}put inside of your manifest
Dialogue: 0,0:47:05.45,0:47:08.95,ch,,0,0,0,,设定好你要求的是哪种触摸屏的类型\N{\ren}a filter defining what type of touch screen you're require
Dialogue: 0,0:47:09.05,0:47:11.62,ch,,0,0,0,,这些仅仅\N{\ren}and those are even at the level of (capacity resist)
Dialogue: 0,0:47:11.68,0:47:14.37,ch,,0,0,0,,基于触摸点的东西都处于manifest的级别了\N{\ren}they're simply based on touch point
Dialogue: 0,0:47:14.42,0:47:19.42,ch,,0,0,0,,manifest会问系统你能支持1个触点么,2个?或者5个,等等\N{\ren}can i only support 1,can i support,i think 1,2 and 5 or 5 more,something like that
Dialogue: 0,0:47:19.42,0:47:20.54,ch,,0,0,0,,因此如果你想得到\N{\ren}so if you need
Dialogue: 0,0:47:20.54,0:47:24.94,ch,,0,0,0,,如果你的程序需要设备达到某个最大的触摸点数时,\N你可以把这个需求放到你的manifest中\N{\ren}if you need the capability based on maximum of pointers you can put that in your manifest
Dialogue: 0,0:47:24.94,0:47:29.04,ch,,0,0,0,,但是对系统任何关于悬停的能力要求,API并没有提供\N{\ren}but any other meta data of about the hover capability,is not in the API
Dialogue: 0,0:47:29.04,0:47:31.04,ch,,0,0,0,,起码目前没有\N{\ren}at least not today
Dialogue: 0,0:47:31.04,0:47:33.04,ch,,0,0,0,,\N{\ren}ok
Dialogue: 0,0:47:33.11,0:47:34.31,ch,,0,0,0,,\N{\ren}so
Dialogue: 0,0:47:34.34,0:47:36.48,ch,,0,0,0,,自定义事件处理很有趣\N{\ren}custom handling is interesting
Dialogue: 0,0:47:36.48,0:47:39.08,ch,,0,0,0,,其中涉及很多数学,可能会变得非常有趣,\N这也许就是你想要的\N{\ren}it's a lot of math,and it can be a lot fun and maybe what you need
Dialogue: 0,0:47:39.17,0:47:39.91,ch,,0,0,0,,但是\N{\ren}but
Dialogue: 0,0:47:39.91,0:47:42.21,ch,,0,0,0,,系统为我们提供了更简单的方法来干这事儿\N{\ren}there are simpler ways to do a lot of stuff
Dialogue: 0,0:47:42.21,0:47:44.81,ch,,0,0,0,,我们当然有兴趣来研究这些方法\N{\ren}and we would like to look at those because that may
Dialogue: 0,0:47:44.81,0:47:47.41,ch,,0,0,0,,因为用这些方法来写应用程序时可以省时省力\N{\ren}that maybe a smarter approach for many applications,ok
Dialogue: 0,0:47:47.41,0:47:52.41,ch,,0,0,0,,框架里面已经为我们内建了很多触摸处理器\N{\ren}so there are a lot of touch handler that already built into the framework for us
Dialogue: 0,0:47:52.45,0:47:54.65,ch,,0,0,0,,有些我们已经用了不下N遍了\N{\ren}you know,some of these we probably use a million times over
Dialogue: 0,0:47:54.65,0:47:56.95,ch,,0,0,0,,比方说onClickListener()\N{\ren}right,how many of us haven't use an onClickListener()
Dialogue: 0,0:47:56.95,0:47:59.25,ch,,0,0,0,,或者OnLongClickListener()\N{\ren}or an OnLongClickListener()
Dialogue: 0,0:47:59.28,0:48:02.17,ch,,0,0,0,,还有一些我们提到过的触摸事件监听器\N{\ren}we talked a little bit about touch listener already being
Dialogue: 0,0:48:02.17,0:48:05.37,ch,,0,0,0,,你可以用于监测或者消费掉触摸事件\N{\ren}something you could use to monitor or consume touch events
Dialogue: 0,0:48:05.37,0:48:07.37,ch,,0,0,0,,而不用重写一个子类\N{\ren}without having to subclass
Dialogue: 0,0:48:07.37,0:48:10.57,ch,,0,0,0,,比方说View的ScrollListener或者onScrollChange()\N{\ren}ScrollListeners or the onScrollChange() of a View's
Dialogue: 0,0:48:10.57,0:48:14.97,ch,,0,0,0,,如果你仅仅关心的就是这些基本的特性的话\N{\ren}if you just interested in some of these more common basic features
Dialogue: 0,0:48:14.97,0:48:18.17,ch,,0,0,0,,你真的不用从从头到脚地监测\N{\ren}you probably don't have to go all the way down to start monitoring
Dialogue: 0,0:48:18.17,0:48:20.47,ch,,0,0,0,,onIntercept()或者onTouchEvent()中的事件\N{\ren}onIntercept() and onTouchEvent()
Dialogue: 0,0:48:20.47,0:48:22.47,ch,,0,0,0,,利用复杂的数学计算,去得到你想要的信息\N{\ren}just to get that information
Dialogue: 0,0:48:22.47,0:48:25.67,ch,,0,0,0,,那你说我该怎么办?\N不怕,我们这儿有GestureDetectors()\N{\ren}in addition to that,we have these things called GestureDetectors()
Dialogue: 0,0:48:25.67,0:48:28.27,ch,,0,0,0,,这些手势监听器可以让我们\N{\ren}that allow us to monitor some
Dialogue: 0,0:48:28.27,0:48:31.17,ch,,0,0,0,,监测到像滚动或者"飞划"等这些常用的手势\N{\ren}additional more common things like scroll and flings
Dialogue: 0,0:48:31.20,0:48:32.77,ch,,0,0,0,,因此\N{\ren}so that
Dialogue: 0,0:48:32.82,0:48:36.14,ch,,0,0,0,,如果我们要做的仅仅是自定义一个滚动视图的话\N{\ren}if all we're doing is implementing a custom scrolling view or something along those lines
Dialogue: 0,0:48:36.20,0:48:38.97,ch,,0,0,0,,我们的确不需要自己来给触摸事件做数学计算\N{\ren}we again don't have to do all the math of the touches
Dialogue: 0,0:48:38.97,0:48:41.14,ch,,0,0,0,,我们大可以把这难题丢给框架来做\N{\ren}we can let the framework do that for us
Dialogue: 0,0:48:41.14,0:48:44.34,ch,,0,0,0,,额外的,我们还有监测缩放手势监听器\N{\ren}additionally,there is a scale gesture detector
Dialogue: 0,0:48:44.42,0:48:49.28,ch,,0,0,0,,这类监听器就是指用来监测缩放手势的监听器\N{\ren}which they refer to it as the detector for the scale gesture
Dialogue: 0,0:48:49.28,0:48:50.71,ch,,0,0,0,,缩放手势包含了捏合跟张开\N{\ren}but it's a pinch zoom
Dialogue: 0,0:48:50.71,0:48:52.71,ch,,0,0,0,,只不过系统不这么叫而已\N{\ren}they just can't call (inaudible) that
Dialogue: 0,0:48:52.77,0:48:55.94,ch,,0,0,0,,当你把两根手指放到屏幕上时\N{\ren}but it's effectively when you put two fingers on the screen
Dialogue: 0,0:48:55.94,0:48:58.54,ch,,0,0,0,,来监测它们是越来越近还是越来越远\N{\ren}and monitor whether they get closer together or farther apart
Dialogue: 0,0:48:58.54,0:49:01.44,ch,,0,0,0,,getScaledDetector就是用于此目的的\N{\ren}that just the detector's for that specific purpose
Dialogue: 0,0:49:08.71,0:49:09.94,ch,,0,0,0,,\N{\ren}so
Dialogue: 0,0:49:09.94,0:49:11.77,ch,,0,0,0,,所有的这些手势监测器都是一个很大的进步\N{\ren}all these it is a great leaden
Dialogue: 0,0:49:11.77,0:49:15.27,ch,,0,0,0,,因为基本上,这些侦听器都是数学引擎\N{\ren}because basically all these (inaudible..) these detector are,are math engines
Dialogue: 0,0:49:15.27,0:49:19.37,ch,,0,0,0,,这些侦听器怎么用在你的应用中呢?\N首先,你要初始化一个侦听器对象\N{\ren}the way that they work,cause in your application,you instantiate one
Dialogue: 0,0:49:19.42,0:49:22.22,ch,,0,0,0,,然后你要想办法把在onTouchEvent中把事件取出\N{\ren}and then it's your job from the onTouchEvent()
Dialogue: 0,0:49:22.22,0:49:24.52,ch,,0,0,0,,或者在你自定义视图中进行事件处理的地方把事件取出\N{\ren}or however you're doing in your custom view
Dialogue: 0,0:49:24.52,0:49:27.72,ch,,0,0,0,,从而将每次到来的事件都送到侦听器的里面\N{\ren}to feed the detector with these events as they come in
Dialogue: 0,0:49:27.82,0:49:31.85,ch,,0,0,0,,手势监听器会把你程序中所有的基础事件都拿来处理\N{\ren}the gesture detector is simply hand it every motion event
Dialogue: 0,0:49:31.85,0:49:33.85,ch,,0,0,0,,手势监听器会把你程序中所有的基础事件都拿来处理\N{\ren}that you get inside of application
Dialogue: 0,0:49:33.88,0:49:37.17,ch,,0,0,0,,之后,当手势侦听器侦听到要侦听的手势时,\N侦听器就会把此信息发给你\N{\ren}and then it tell you when one of these other events occur
Dialogue: 0,0:49:37.17,0:49:40.37,ch,,0,0,0,,此时,这就由你来决定是否处理这个特定的手势了\N{\ren}and at that point,it's up to you what you do with that information
Dialogue: 0,0:49:40.45,0:49:43.20,ch,,0,0,0,,简而言之就是,侦听器把触摸事件当输入\N{\ren}so these are simply taking the input in
Dialogue: 0,0:49:43.20,0:49:45.50,ch,,0,0,0,,然后经过计算后,告诉你\N{\ren}doing the computation and saying oh..
Dialogue: 0,0:49:45.50,0:49:48.70,ch,,0,0,0,,现在的手势是滚动或者飞划或者是什么什么手势\N{\ren}we were now scrolling or we're now fling or we're now doing this
Dialogue: 0,0:49:48.80,0:49:52.65,ch,,0,0,0,,此时,如果你想基于侦听到的手势来使\N一个按钮做动画时,或者干些别的事儿时\N{\ren}and then if you wanna to animate a Button based on that or whatever the case may be
Dialogue: 0,0:49:52.65,0:49:55.55,ch,,0,0,0,,你就可以把要干的事情写到侦听器提供的回调函数中\N{\ren}inside these callback methods you could write the code to do that
Dialogue: 0,0:49:55.55,0:49:58.15,ch,,0,0,0,,但是侦听事件跟事件处理之间没有直接的联系\N{\ren}but there is no direct link between those
Dialogue: 0,0:50:02.57,0:50:04.82,ch,,0,0,0,,是的,你只需要重写回调方法\N{\ren}yeah,you need to override the method
Dialogue: 0,0:50:04.85,0:50:07.74,ch,,0,0,0,,而不是根据各种动作事件来自己做数学计算\N{\ren}but rather than checking all the actions and doing all the math
Dialogue: 0,0:50:07.74,0:50:10.34,ch,,0,0,0,,你只需把事件给侦听器,然后等待侦听器回调即可\N{\ren}you just hand it off to this and listen for the callback
Dialogue: 0,0:50:10.34,0:50:12.34,ch,,0,0,0,,侦听器就做了计算方面的事情\N{\ren}so they're just the computation in a piece
Dialogue: 0,0:50:13.28,0:50:15.25,ch,,0,0,0,,耶,差不多啊\N{\ren}yeah basically
Dialogue: 0,0:50:16.02,0:50:16.82,ch,,0,0,0,,好的\N{\ren}ok
Dialogue: 0,0:50:16.82,0:50:20.02,ch,,0,0,0,,但是用侦听器也有几个缺点\N{\ren}some the other disadvantages of this
Dialogue: 0,0:50:20.62,0:50:23.05,ch,,0,0,0,,你发现这里给出了很多方法来侦听各种常用的手势\N{\ren}you see there is a lot of methods here for common things
Dialogue: 0,0:50:23.05,0:50:25.05,ch,,0,0,0,,就连按下方法也有\N{\ren}like even just basic onDown
Dialogue: 0,0:50:25.05,0:50:27.65,ch,,0,0,0,,还有像轻点一下,滚动,以及飞划\N{\ren}as well as a single taps,and scrolls and flings
Dialogue: 0,0:50:27.68,0:50:31.57,ch,,0,0,0,,但是手势侦听唯独没有弹起跟取消\N{\ren}there is no method on GestureDetector for onUp or onCancel
Dialogue: 0,0:50:31.74,0:50:33.57,ch,,0,0,0,,这就会给你增加一些难度\N{\ren}and this can be a little bit difficulty
Dialogue: 0,0:50:33.60,0:50:37.54,ch,,0,0,0,,如果你需要在你的自定义视图中用到\N弹起和取消事件来干一些事情时\N{\ren}if you need the up and cancel event to do something with whatever your custom view in
Dialogue: 0,0:50:37.54,0:50:40.74,ch,,0,0,0,,我之前提到过,如果你手动地\N{\ren}you know,i mention before that if you manually say
Dialogue: 0,0:50:40.77,0:50:45.74,ch,,0,0,0,,直接基于触摸事件来改变你的视图的可视状态时\N{\ren}changing the visual state of your view based on direct touch event interaction
Dialogue: 0,0:50:45.77,0:50:47.65,ch,,0,0,0,,你就依赖于弹起或者取消事件\N{\ren}and you're relying on getting up or cancel
Dialogue: 0,0:50:47.65,0:50:51.75,ch,,0,0,0,,来根据视图的状态重新设置视图上的绘制对象\N使其看起来并不像被按下去的样子\N{\ren}to say reset the drawable state to make it look like it's not pressed any more
Dialogue: 0,0:50:51.80,0:50:55.31,ch,,0,0,0,,如果你用手势侦听器来处理的话,\N你就不能得到弹起或者取消的回调\N{\ren}if you're using gesture detector,they're not gonna give you those callbacks
Dialogue: 0,0:50:55.31,0:50:58.81,ch,,0,0,0,,弹起和取消被用于侦听器的内部来判断手势何时结束\N{\ren}they're using all that information internally to know when gesture's end
Dialogue: 0,0:50:58.85,0:51:02.22,ch,,0,0,0,,但是系统并不会给你提供一个回调\N来告知你取消或者弹起事件来了\N{\ren}but they're not going to provide that to you as a method call
Dialogue: 0,0:51:02.25,0:51:05.85,ch,,0,0,0,,我再强调一次,是你做了给侦听器传递事件的工作\N{\ren}so again,because we mention that it's your job to feed the detector
Dialogue: 0,0:51:05.91,0:51:09.68,ch,,0,0,0,,因此你可以在传递事件给侦听器之前,\N对某些你感兴趣的事件进行处理\N{\ren}you may have to check some of those specific edge cases outside of it
Dialogue: 0,0:51:09.68,0:51:12.28,ch,,0,0,0,,因此你可以在传递事件给侦听器之前,\N对某些你感兴趣的事件进行处理\N{\ren}before you feed the events in
Dialogue: 0,0:51:15.00,0:51:17.54,ch,,0,0,0,,你是说可以监测这样子的旋转么\N{\ren}you mean like this kind of rotation
Dialogue: 0,0:51:17.54,0:51:19.84,ch,,0,0,0,,不行,不过我有一个例子,可以告诉你如何去做\N{\ren}no,although i have an example of how you can do it
Dialogue: 0,0:51:19.94,0:51:21.08,ch,,0,0,0,,不要迷恋哥\N{\ren}hehe
Dialogue: 0,0:51:21.08,0:51:25.48,ch,,0,0,0,,你看我的例子应该能看懂基本的原理,\N但是系统中是没这个手势的侦听器的\N{\ren}so,you'll see kind of the basic idea,there is no one built into the framework
Dialogue: 0,0:51:25.48,0:51:30.18,ch,,0,0,0,,但是这个手势可以不难,\N你可以用自定义事件处理来实现它\N{\ren}but it's a simple enough gesture to implement with custom handling
Dialogue: 0,0:51:30.18,0:51:32.78,ch,,0,0,0,,ok,问题来吧\N{\ren}so ok,good questions
Dialogue: 0,0:51:32.78,0:51:35.38,ch,,0,0,0,,是的,你说的对\N{\ren}yeah,ok,so that's the piece
Dialogue: 0,0:51:35.38,0:51:37.98,ch,,0,0,0,,好吧,这是最后一个要谈的东西\N{\ren}already the last thing that i wanna talk to you about
Dialogue: 0,0:51:37.98,0:51:39.98,ch,,0,0,0,,在我们看demo之前\N{\ren}before we go look some of the demos
Dialogue: 0,0:51:40.00,0:51:42.28,ch,,0,0,0,,这玩意儿叫做触摸代理\N{\ren}is this guy call touchDelegate
Dialogue: 0,0:51:42.28,0:51:46.38,ch,,0,0,0,,屋里有没有人之前听说过触摸代理啊\N{\ren}does anybody in the room heard of touchDelegate before (inaudible..) used it
Dialogue: 0,0:51:46.38,0:51:48.98,ch,,0,0,0,,哎呦,还不错哦.通常一个屋子里有2人就不错了\N{\ren}oh,that's pretty good.usually i get two
Dialogue: 0,0:51:49.68,0:51:52.48,ch,,0,0,0,,触摸代理在框架中一直是整洁的小秘密\N{\ren}so,TouchDelegate is a neat little secret in the framework
Dialogue: 0,0:51:52.48,0:51:54.78,ch,,0,0,0,,因为1.0的时候就存在了\N{\ren}that has been around since 1.0
Dialogue: 0,0:51:54.88,0:51:56.11,ch,,0,0,0,,但是\N{\ren}but
Dialogue: 0,0:51:56.17,0:51:59.20,ch,,0,0,0,,这玩意儿有很多不同的用处\N{\ren}it's kind of had vary in degrees of use over time
Dialogue: 0,0:51:59.25,0:52:00.77,ch,,0,0,0,,是个能放到你背后口袋里的好东西\N{\ren}but it's a good thing to have in your back pocket
Dialogue: 0,0:52:00.77,0:52:04.27,ch,,0,0,0,,关于触摸代理,大致上只有一个函数而已\N{\ren}TouchDelegate basically has one single function
Dialogue: 0,0:52:04.27,0:52:06.87,ch,,0,0,0,,此函数的作用是允许让\N{\ren}it's job is to allow
Dialogue: 0,0:52:06.88,0:52:10.45,ch,,0,0,0,,一个父视图...这玩意儿也只能在父视图中使用\N{\ren}a parent view,in a (inaudible) say,this is the only way you could use it
Dialogue: 0,0:52:10.48,0:52:12.14,ch,,0,0,0,,好吧.我对着PPT念吧\N{\ren}but there really words designed for.(not clear)
Dialogue: 0,0:52:12.14,0:52:15.04,ch,,0,0,0,,触摸代理设计的目的是允许父视图\N{\ren}it's to design to allow a parent View
Dialogue: 0,0:52:15.04,0:52:17.64,ch,,0,0,0,,来定义一个特定的触摸区域\N{\ren}to define a specific touch zone
Dialogue: 0,0:52:17.64,0:52:22.64,ch,,0,0,0,,在此触摸区域中,所接收的所有事件\N都会向前传递给某个孩子视图\N{\ren}and inside of that zone,forward all touch events to a child view
Dialogue: 0,0:52:22.64,0:52:24.64,ch,,0,0,0,,这个..\N{\ren}the
Dialogue: 0,0:52:24.65,0:52:26.31,ch,,0,0,0,,这玩意儿的设计哲学是...\N{\ren}the reason behind it
Dialogue: 0,0:52:26.31,0:52:30.85,ch,,0,0,0,,想象一下,一个ListView的数据项,\N其中包含了一个非常小的图标\N{\ren}was think of the idea like a ListView item that has a very small icon
Dialogue: 0,0:52:30.85,0:52:34.95,ch,,0,0,0,,由于此图标太小以至于很难触摸的到\N{\ren}it's too small to actually have a touchable area
Dialogue: 0,0:52:34.95,0:52:37.55,ch,,0,0,0,,但是你希望人们能点击这个图标\N{\ren}but you want people to be able to tap on it
Dialogue: 0,0:52:37.55,0:52:39.85,ch,,0,0,0,,因此,怎么在这种情况下用触摸代理呢\N{\ren}so the concept was
Dialogue: 0,0:52:39.85,0:52:42.75,ch,,0,0,0,,在ListView的Item中的父视图\N{\ren}as the parent at that ListView item
Dialogue: 0,0:52:42.82,0:52:44.34,ch,,0,0,0,,可以指定一片区域当做触摸代理\N{\ren}could define a touch Delegate
Dialogue: 0,0:52:44.34,0:52:47.84,ch,,0,0,0,,此区域可以是一个比视图本身更大一点的矩形\N{\ren}that was a larger rectangle around the view itself
Dialogue: 0,0:52:47.88,0:52:48.74,ch,,0,0,0,,以及\N{\ren}and
Dialogue: 0,0:52:48.77,0:52:50.28,ch,,0,0,0,,把此区域中的所有触摸事件都传给那个很小的视图\N{\ren}forward all of those events
Dialogue: 0,0:52:50.28,0:52:53.18,ch,,0,0,0,,把此区域中的所有触摸事件都传给那个很小的视图\N{\ren}from that rectangle into that teeny tiny view
Dialogue: 0,0:52:53.25,0:52:57.00,ch,,0,0,0,,对于父视图和孩子视图之间,可能存在一些其他的原因\N{\ren}there may be other reasons even inside of a parent child relationship
Dialogue: 0,0:52:57.00,0:53:01.10,ch,,0,0,0,,要用到这样的功能或者是认为这样的功能很有意义\N{\ren}where it makes use of and make sense to do that
Dialogue: 0,0:53:01.10,0:53:05.50,ch,,0,0,0,,但是我刚讲的东西是其最初被加入到框架里的设计意图\N{\ren}but that's kind of reason it was added to the framework in the original design
Dialogue: 0,0:53:05.51,0:53:09.00,ch,,0,0,0,,在多数情况下,你可能会规避走到这一步\N{\ren}there,in a lot cases you can sometimes get away with doing the same thing
Dialogue: 0,0:53:09.00,0:53:11.00,ch,,0,0,0,,比方说那把视图设置的大一点好了\N{\ren}by just making the view itself larger
Dialogue: 0,0:53:11.08,0:53:13.25,ch,,0,0,0,,尽管视图本身的内容并没有那么大\N{\ren}even though the view display isn't larger
Dialogue: 0,0:53:13.28,0:53:16.02,ch,,0,0,0,,就像是ImageView视图本事可以\N设置得比其内容更大一样\N{\ren}like an ImageView can be bigger than its actual content
Dialogue: 0,0:53:16.02,0:53:17.80,ch,,0,0,0,,但是不是所有的视图都能做到这一点\N{\ren}but not all views can do that
Dialogue: 0,0:53:17.85,0:53:19.65,ch,,0,0,0,,因此要解决此问题还有考虑到视图的类型\N{\ren}so it may depend what the view type is
Dialogue: 0,0:53:19.65,0:53:22.55,ch,,0,0,0,,还有就是你不想用这种蹩脚的解决方案\N{\ren}and you may not be able to use that kind of solution
Dialogue: 0,0:53:22.62,0:53:26.54,ch,,0,0,0,,为了让你对如何使用触摸代理,我这里还写了一些伪代码\N{\ren}just to give you kind of basic idea,there some pseudocode down here
Dialogue: 0,0:53:26.65,0:53:28.91,ch,,0,0,0,,我一会演示例子的时候,你还能看到类似的代码\N{\ren}you'll see it again in the example
Dialogue: 0,0:53:28.91,0:53:31.94,ch,,0,0,0,,首先,你要有个父视图跟子视图\N{\ren}but the basic idea is you have a parent view and a child view
Dialogue: 0,0:53:31.94,0:53:34.24,ch,,0,0,0,,以及被定义成一个矩形的触摸区域\N{\ren}and some touch area that's defined as a rect
Dialogue: 0,0:53:34.24,0:53:37.74,ch,,0,0,0,,你只需调用父视图的setTouchDelegate方法\N{\ren}and the parent view you just simply say setTouchDelegate
Dialogue: 0,0:53:37.82,0:53:41.22,ch,,0,0,0,,传入一个用矩形区域和孩子视图初始化的触摸代理对象\N{\ren}and you initialize one of these delegates with that area
Dialogue: 0,0:53:41.25,0:53:43.02,ch,,0,0,0,,传入一个用矩形区域和孩子视图初始化的触摸代理对象\N{\ren}and the reference the child view
Dialogue: 0,0:53:43.02,0:53:45.37,ch,,0,0,0,,那么在触摸代理内部,它干了什么事儿呢\N{\ren}and inside of it,what touchDelegate does
Dialogue: 0,0:53:45.37,0:53:47.67,ch,,0,0,0,,它会对每一个进入到父视图的事件进行检查\N{\ren}is for every touch event that comes in to that view
Dialogue: 0,0:53:47.74,0:53:49.71,ch,,0,0,0,,判断此事件的位置是否落在了定义的矩形区域内\N{\ren}it checked to see if it's in the bounds of the rect
Dialogue: 0,0:53:49.74,0:53:50.57,ch,,0,0,0,,是的话\N{\ren}and it does
Dialogue: 0,0:53:50.57,0:53:53.47,ch,,0,0,0,,那就把事件的坐标稍作处理,\N然后将事件向下传递给孩子视图\N{\ren}it (inaudible) the coordinates a little bit and forwards down to the view
Dialogue: 0,0:53:53.47,0:53:55.47,ch,,0,0,0,,讲完了.问题来吧\N{\ren}ok,yes
Dialogue: 0,0:53:55.72,0:54:10.96,ch,,0,0,0,,(注:此处的问题听得不是很清楚,\N而且根据回答的内容也不太好猜,\N我就只按字面意思边猜边翻译了,\N反正此问题跟本文内容关系不大)\N \N
Dialogue: 0,0:54:11.02,0:54:13.65,ch,,0,0,0,,我们这里所讨论的\N{\ren}so i mean,all were we really talking about here
Dialogue: 0,0:54:13.65,0:54:15.65,ch,,0,0,0,,仅仅是怎样使得处理触摸事件的过程变得更好\N{\ren}is how we is helping process the touch
Dialogue: 0,0:54:15.74,0:54:18.05,ch,,0,0,0,,就我们谈论的过程来看\N{\ren}so if it's all used in this processing
Dialogue: 0,0:54:18.05,0:54:22.45,ch,,0,0,0,,这里会把从手指下接收到的事件\N{\ren}might be to forward the events from the finger
Dialogue: 0,0:54:22.45,0:54:24.45,ch,,0,0,0,,用触摸代理传送到那个按钮中\N{\ren}to be picked up by that Button
Dialogue: 0,0:54:24.51,0:54:25.71,ch,,0,0,0,,至于此处按钮会有怎样的反应\N{\ren}what the reaction of that is
Dialogue: 0,0:54:25.71,0:54:27.71,ch,,0,0,0,,那就要看按钮自身的触摸事件处理过程了\N{\ren}as far as displaying any (inaudible) view content
Dialogue: 0,0:54:27.71,0:54:28.74,ch,,0,0,0,,因此事件截取很处理是分开的\N{\ren}is complete separate
Dialogue: 0,0:54:31.00,0:54:33.00,ch,,0,0,0,,终于把PPT过完了\N{\ren}all right
Dialogue: 0,0:54:33.00,0:54:35.00,ch,,0,0,0,,大家一起来看demo吧\N{\ren}let's go look the demo
Dialogue: 0,0:54:43.65,0:54:44.82,ch,,0,0,0,,好的\N{\ren}ok
Dialogue: 0,0:54:44.82,0:54:46.82,ch,,0,0,0,,我们得看看我能不能\N{\ren}we gonna see if i can be
Dialogue: 0,0:54:46.82,0:54:50.32,ch,,0,0,0,,将我的平板投到这个大屏幕上\N{\ren}really cool can put my device on the display
Dialogue: 0,0:55:03.20,0:55:04.40,ch,,0,0,0,,看吧,是不是很酷\N{\ren}hey,look at that
Dialogue: 0,0:55:07.91,0:55:08.62,ch,,0,0,0,,\N{\ren}ok
Dialogue: 0,0:55:09.00,0:55:11.88,ch,,0,0,0,,现在大家看到的就是我的demo程序了\N{\ren}so this is the example application that
Dialogue: 0,0:55:11.88,0:55:15.98,ch,,0,0,0,,我有Github账号,你可以在Github找哥的代码细看\N{\ren}that i have my Github and we'll be looking though the sample code(inaudible)
Dialogue: 0,0:55:15.98,0:55:17.98,ch,,0,0,0,,如果你也有Github账号的话,你可以follow哥\N{\ren}if you have it.you can follow on our case
Dialogue: 0,0:55:18.05,0:55:19.34,ch,,0,0,0,,这样哥又多粉了\N{\ren}that's fine with me
Dialogue: 0,0:55:19.37,0:55:20.51,ch,,0,0,0,,好吧,看哥的demo\N{\ren}so the
Dialogue: 0,0:55:20.54,0:55:23.08,ch,,0,0,0,,先看第1个:移动事件日志打印.哥来带你飞\N{\ren}the Move Logger Example,i might go though the end
Dialogue: 0,0:55:23.11,0:55:26.02,ch,,0,0,0,,我没有必要带你把例子吃透.我只挑重点讲\N{\ren}cause i can't really have to show you that on screen here
Dialogue: 0,0:55:26.08,0:55:28.45,ch,,0,0,0,,这里的第一个例子\N{\ren}but this first example here
Dialogue: 0,0:55:28.45,0:55:31.05,ch,,0,0,0,,大体上就定义了两个触摸区域\N{\ren}basically just defines two touch zones
Dialogue: 0,0:55:31.05,0:55:32.42,ch,,0,0,0,,在其视图容器中\N{\ren}inside this view
Dialogue: 0,0:55:32.42,0:55:37.42,ch,,0,0,0,,上边的区域会Log输入其收到的所有触摸事件\N{\ren}the top zone will log every touch event that receives
Dialogue: 0,0:55:37.42,0:55:39.42,ch,,0,0,0,,并且不过问事件的类型\N{\ren}and does no checking of any kind
Dialogue: 0,0:55:39.42,0:55:41.42,ch,,0,0,0,,我可以在这个区域上\N{\ren}ok,this is the one where
Dialogue: 0,0:55:41.42,0:55:44.68,ch,,0,0,0,,把我的手指放下,然后尽可能的不让手指颤动\N{\ren}i can put my finger down,i can try and hold this as steady as i can
Dialogue: 0,0:55:44.71,0:55:47.11,ch,,0,0,0,,或者手指就自然的放在那儿\N{\ren}or just kind of look at what's going one
Dialogue: 0,0:55:47.11,0:55:50.61,ch,,0,0,0,,然后你会发现,LogCat中的移动事件会不停的被打印\N{\ren}then the log you will see just move events go like crazy
Dialogue: 0,0:55:50.68,0:55:52.71,ch,,0,0,0,,而当我的手指放在下面的这个区域时\N{\ren}where i on this bottom piece here
Dialogue: 0,0:55:52.71,0:55:54.05,ch,,0,0,0,,这里我按下的区域\N{\ren}if i touch down here
Dialogue: 0,0:55:54.05,0:55:56.05,ch,,0,0,0,,就会进行slop检查\N{\ren}that has protected by a slop check
Dialogue: 0,0:55:56.05,0:55:58.05,ch,,0,0,0,,你可以看出\N{\ren}so you can see that
Dialogue: 0,0:55:58.11,0:56:00.28,ch,,0,0,0,,此处不同于上面,当我让我的手指静止不动时\N{\ren}the difference being when i hold my finger still
Dialogue: 0,0:56:00.34,0:56:02.08,ch,,0,0,0,,我是不会得到任何触摸事件的\N{\ren}i won't be getting any events
Dialogue: 0,0:56:02.08,0:56:05.58,ch,,0,0,0,,直到我试着将手指移动一点点,此时移动事件才开始出现\N{\ren}until i kind start to move it a little bit,and they'll start to show up
Dialogue: 0,0:56:05.65,0:56:06.37,ch,,0,0,0,,\N{\ren}ok
Dialogue: 0,0:56:06.37,0:56:09.57,ch,,0,0,0,,这就是我们第一个例子实现的功能\N{\ren}so that's what's going on here on the first example
Dialogue: 0,0:56:09.57,0:56:11.87,ch,,0,0,0,,现在我要切换一下屏幕\N{\ren}and if i switch
Dialogue: 0,0:56:12.68,0:56:16.45,ch,,0,0,0,,让我们回到我们Log界面,\N这样你就能看到Log的打印效果的\N{\ren}back to the log you can sort see that in action
Dialogue: 0,0:56:31.77,0:56:33.40,ch,,0,0,0,,显示我的Log啊\N{\ren}pick up my log
Dialogue: 0,0:56:33.51,0:56:37.25,ch,,0,0,0,,喔,我的设备没连到电脑上.这样我就只好分开做展示了\N{\ren}oh,i don't have this device connected,so i have to show you that one separately
Dialogue: 0,0:56:37.25,0:56:40.15,ch,,0,0,0,,因为我不能同时连着HDMI跟USB,不过无所谓了\N{\ren}cause i can't be on HDMI and USB at the same time,never mind
Dialogue: 0,0:56:44.31,0:56:46.77,ch,,0,0,0,,好吧.咱们看个更有趣的例子吧\N{\ren}all right.let's look a more interesting one
Dialogue: 0,0:56:52.60,0:56:56.28,ch,,0,0,0,,下个例子是讲触摸监听器的,这个例子很一般\N{\ren}this next example which is the TouchListener is fairly basic
Dialogue: 0,0:56:56.28,0:56:59.18,ch,,0,0,0,,顶端放的是一个复选框\N{\ren}what i have here at the top is just basic checkbox
Dialogue: 0,0:56:59.18,0:57:01.18,ch,,0,0,0,,还有一组单选框\N{\ren}and in a radio group
Dialogue: 0,0:57:01.18,0:57:03.48,ch,,0,0,0,,我在此例中要做的是\N{\ren}what i'm gonna do in the example as i'm going to take
Dialogue: 0,0:57:03.48,0:57:06.68,ch,,0,0,0,,用一个触摸监听器取到复选框的状态值\N{\ren}the value of the checkbox and using a TouchListener
Dialogue: 0,0:57:06.77,0:57:09.14,ch,,0,0,0,,我要根据复选框是否被选中来决定\N{\ren}i'm going to determine whether or not the box is checked
Dialogue: 0,0:57:09.14,0:57:12.94,ch,,0,0,0,,我是否应该把单选框组进行锁定\N{\ren}whether i should lock out touches from coming into my radio group
Dialogue: 0,0:57:13.00,0:57:13.85,ch,,0,0,0,,\N{\ren}ok
Dialogue: 0,0:57:13.85,0:57:17.40,ch,,0,0,0,,这里实现的功能仅仅是动态控制单选框组的功能\N{\ren}so just sort of a dynamic way of controlling the response of the radio group
Dialogue: 0,0:57:17.40,0:57:19.70,ch,,0,0,0,,比如说,\N{\ren}as the way it is here
Dialogue: 0,0:57:19.74,0:57:21.22,ch,,0,0,0,,此时我可以点击任何是一个单选框\N{\ren}i can touch on any these elements
Dialogue: 0,0:57:21.22,0:57:23.22,ch,,0,0,0,,任何一个被点击的都会被选中\N{\ren}and they get selected
Dialogue: 0,0:57:23.28,0:57:24.82,ch,,0,0,0,,情况就是跟你期望的一样\N{\ren}you know,behavior you'd expect
Dialogue: 0,0:57:24.82,0:57:26.82,ch,,0,0,0,,但是一旦我把复选框选中了\N{\ren}and as soon as i check that box
Dialogue: 0,0:57:27.57,0:57:30.68,ch,,0,0,0,,现在,我再去点按这些单选框时\N{\ren}i can now go though and press all of these
Dialogue: 0,0:57:30.74,0:57:32.97,ch,,0,0,0,,这些单选框的状态就不能被改变了\N{\ren}and they will not change at all
Dialogue: 0,0:57:33.00,0:57:34.20,ch,,0,0,0,,实际上,我在这儿干的事儿是\N{\ren}what's actually happening
Dialogue: 0,0:57:34.20,0:57:36.20,ch,,0,0,0,,我给单选框组增加了一个触摸监听器\N{\ren}is i've set a TouchListener
Dialogue: 0,0:57:36.20,0:57:38.94,ch,,0,0,0,,我给单选框组增加了一个触摸监听器\N{\ren}on the radio group there
Dialogue: 0,0:57:38.97,0:57:41.62,ch,,0,0,0,,然后在里面判断,复选框是否被选中,\N无论何时复选框被选中\N{\ren}and whenever the boxes is checked
Dialogue: 0,0:57:41.68,0:57:44.68,ch,,0,0,0,,此触摸监听器就会返回true来把事件给消耗掉\N{\ren}it's returning true to consume those events
Dialogue: 0,0:57:44.68,0:57:48.18,ch,,0,0,0,,这样就屏蔽了单选框按钮自身的事件处理逻辑了\N{\ren}before the radio group has an opportunity to process them
Dialogue: 0,0:57:48.18,0:57:50.18,ch,,0,0,0,,\N{\ren}ok
Dialogue: 0,0:57:55.80,0:57:57.14,ch,,0,0,0,,我要找的那个是..\N{\ren}that one is
Dialogue: 0,0:57:59.20,0:57:59.94,ch,,0,0,0,,触摸屏蔽...\N{\ren}touch intercept
Dialogue: 0,0:58:01.34,0:58:03.48,ch,,0,0,0,,你看,就是很一般的Activity\N{\ren}so just very basic activity
Dialogue: 0,0:58:04.54,0:58:05.57,ch,,0,0,0,,唉,找错地方了哦\N{\ren}no that's not it
Dialogue: 0,0:58:06.45,0:58:07.25,ch,,0,0,0,,终于找到了,触摸监听器\N{\ren}TouchListener
Dialogue: 0,0:58:08.85,0:58:10.57,ch,,0,0,0,,看这里的复选框\N{\ren}with that checkbox
Dialogue: 0,0:58:10.88,0:58:13.60,ch,,0,0,0,,我的单选框组在这儿\N{\ren}and then my selection is here
Dialogue: 0,0:58:13.60,0:58:18.60,ch,,0,0,0,,我做的是,我把每个单选框的触摸监听器\N都设置到了Activity中的触摸监听器里\N{\ren}so what i've done is i've set the TouchListener of each those elements to be this activity here
Dialogue: 0,0:58:18.60,0:58:20.90,ch,,0,0,0,,你看,我并没有重写一个控件的子类什么的\N来完成对触摸事件的监测\N{\ren}so i didn't have to subclass anything to work with this
Dialogue: 0,0:58:20.90,0:58:24.10,ch,,0,0,0,,触摸监听器里就一个回调函数onTouch()\N{\ren}and the TouchListener just has this onTouch()
Dialogue: 0,0:58:24.11,0:58:27.40,ch,,0,0,0,,onTouch会告诉我与发生事件有关的视图以及\N{\ren}that will tell me the view that this event associated with
Dialogue: 0,0:58:27.40,0:58:29.40,ch,,0,0,0,,当然发生的事件\N{\ren}and the event itself
Dialogue: 0,0:58:29.40,0:58:34.10,ch,,0,0,0,,在onTouch中我们仅仅是返回了复选框的当前状态\N{\ren}and all we were doing here is simply returning whether or  not the lock box is checked
Dialogue: 0,0:58:34.10,0:58:36.40,ch,,0,0,0,,因此当复选框被选中\N{\ren}so when that value is checked
Dialogue: 0,0:58:36.51,0:58:39.62,ch,,0,0,0,,我的触摸监听器就会对任何事件返回true\N{\ren}my TouchListener returns true for every event
Dialogue: 0,0:58:39.65,0:58:41.14,ch,,0,0,0,,不论是什么事件\N{\ren}regardless of what it is
Dialogue: 0,0:58:41.20,0:58:43.25,ch,,0,0,0,,由于单选框身上触摸监听器总是会被优先检查\N{\ren}and since the listener is always checked before
Dialogue: 0,0:58:43.25,0:58:46.44,ch,,0,0,0,,相较于单选框自身的onTouchEvent而言\N{\ren}the local onTouchEvent() of that view
Dialogue: 0,0:58:46.44,0:58:49.04,ch,,0,0,0,,因此对有任何设定过此监听器的视图来说\N{\ren}for every view that has this listener attached
Dialogue: 0,0:58:49.04,0:58:51.64,ch,,0,0,0,,这些视图永远都不会得到触摸事件\N{\ren}those views will never see those events
Dialogue: 0,0:58:51.64,0:58:54.84,ch,,0,0,0,,或者说最起码在事件处理的函数中,是看不到触摸事件的\N{\ren}or at least never see them in the method to which they can process them
Dialogue: 0,0:58:54.84,0:58:59.84,ch,,0,0,0,,因此这实际上是一个快速将触摸事件暂时\N排出View之外的一种锁定事件的方法\N{\ren}so it's effectively a quick way of locking these touch events temporarily out the view
Dialogue: 0,0:58:59.84,0:59:01.84,ch,,0,0,0,,\N{\ren}ok
Dialogue: 0,0:59:03.84,0:59:05.20,ch,,0,0,0,,好了\N{\ren}all right
Dialogue: 0,0:59:09.31,0:59:11.11,ch,,0,0,0,,接下来我要把两个demo放一起讲了\N{\ren}so i will do the next two together
Dialogue: 0,0:59:11.11,0:59:13.11,ch,,0,0,0,,第一个就是触摸代理\N{\ren}this first one is a TouchDelegate
Dialogue: 0,0:59:13.11,0:59:15.41,ch,,0,0,0,,这里大家看到的只是个很一般的\N{\ren}so what i have here is just a very basic
Dialogue: 0,0:59:15.45,0:59:19.88,ch,,0,0,0,,这里你看到的其实是个自定义的布局,在整个屏幕上\N{\ren}it's gonna be a custom layout but the entire screen here
Dialogue: 0,0:59:19.97,0:59:22.37,ch,,0,0,0,,就仅仅放了一个大到占满屏的自定义布局视图而已\N{\ren}is a large single layout that
Dialogue: 0,0:59:22.37,0:59:24.88,ch,,0,0,0,,布局里面就放了一个孩子视图,此孩子视图是个复选框\N{\ren}has one child view inside of it which is that checkbox
Dialogue: 0,0:59:24.88,0:59:27.18,ch,,0,0,0,,如果我点击复选框,复选框就会被选中\N{\ren}and if clicked the checkbox,it will check
Dialogue: 0,0:59:27.18,0:59:29.78,ch,,0,0,0,,不过除此之外,如果我点击任何一个地方\N{\ren}but in addition,if i click anywhere else
Dialogue: 0,0:59:29.80,0:59:31.34,ch,,0,0,0,,只要是在大的布局视图中的\N{\ren}on this view
Dialogue: 0,0:59:31.34,0:59:33.64,ch,,0,0,0,,同样起到了点击复选框的效果\N{\ren}it will also check and uncheck the checkbox
Dialogue: 0,0:59:33.68,0:59:37.85,ch,,0,0,0,,我在这儿干的事儿就是我找了个\N其大小跟ViewGroup本身大小一样大的矩形\N{\ren}so what i have here is i've set up a rectangle for the entire size
Dialogue: 0,0:59:37.91,0:59:39.37,ch,,0,0,0,,我在这儿干的事儿就是我找了个\N其大小跟ViewGroup本身大小一样大的矩形\N{\ren}of the ViewGroup
Dialogue: 0,0:59:39.37,0:59:42.00,ch,,0,0,0,,然后我把此矩形区域构造了复选框的触摸代理对象\N{\ren}and set that as the TouchDelegate for the checkbox
Dialogue: 0,0:59:42.00,0:59:45.50,ch,,0,0,0,,因此不论我点击哪里,只要点在矩形里面\N{\ren}so that no matter where i touch as long as in that rect
Dialogue: 0,0:59:45.50,0:59:48.10,ch,,0,0,0,,复选框仍然会接收到我的点击信息\N{\ren}the checkbox will get that information
Dialogue: 0,0:59:48.25,0:59:49.02,ch,,0,0,0,,\N{\ren}ok
Dialogue: 0,0:59:49.05,0:59:50.02,ch,,0,0,0,,除了用触摸代理之外\N{\ren}in addition
Dialogue: 0,0:59:50.02,0:59:53.82,ch,,0,0,0,,我还有再给你看个关于事件往下传递的例子\N{\ren}i'll show you at the same,this touch forwarding example
Dialogue: 0,0:59:53.82,0:59:55.82,ch,,0,0,0,,此例与触摸代理那个例子采取的基本思路是一样\N{\ren}which is the same basic idea
Dialogue: 0,0:59:55.85,0:59:57.71,ch,,0,0,0,,差别是没有用到触摸代理这个类\N{\ren}for rather than using TouchDelegate
Dialogue: 0,0:59:57.74,1:00:00.88,ch,,0,0,0,,我是手动了修改了事件的坐标\N{\ren}i manually receiving those events changing their coordinates
Dialogue: 0,1:00:00.88,1:00:04.38,ch,,0,0,0,,然后手动的调用dispatch将事件往下传递给按钮\N{\ren}and passing them forward to the Button by just manually calling dispatch
Dialogue: 0,1:00:04.45,1:00:05.25,ch,,0,0,0,,\N{\ren}ok
Dialogue: 0,1:00:05.31,1:00:06.80,ch,,0,0,0,,其达到的效果是一样的\N{\ren}so it's the same behavior
Dialogue: 0,1:00:06.82,1:00:07.80,ch,,0,0,0,,你懂得,你可以\N{\ren}you know,you can
Dialogue: 0,1:00:07.80,1:00:11.00,ch,,0,0,0,,KitKat之前是蓝色的\N{\ren}(inaudible) see with the...without KitKat because it was blue before
Dialogue: 0,1:00:11.00,1:00:12.34,ch,,0,0,0,,但是\N{\ren}but
Dialogue: 0,1:00:12.37,1:00:17.02,ch,,0,0,0,,不管我的手指点按屏幕上的哪些地方,\N这个按钮都会做出被点击时的高亮显示效果\N{\ren}the Button highlights with each individual touch no matter where i put my finger
Dialogue: 0,1:00:17.02,1:00:19.62,ch,,0,0,0,,这里有趣之处在于我可以开始\N{\ren}you know the interesting thing about there and it starts to
Dialogue: 0,1:00:19.62,1:00:23.12,ch,,0,0,0,,解释转换坐标跟不转换坐标之间的不同了\N{\ren}explain the difference between moving the coordinates and not moving them
Dialogue: 0,1:00:23.12,1:00:25.72,ch,,0,0,0,,举个例子来说,如果我把手指按在这儿\N{\ren}for instance,if i put my finger here
Dialogue: 0,1:00:25.85,1:00:27.51,ch,,0,0,0,,随着我手指的滑动\N{\ren}as i slide my finger
Dialogue: 0,1:00:27.54,1:00:30.45,ch,,0,0,0,,这个按钮还会认为它应该被高亮起来\N{\ren}it's still looks like or the Button still thinks it's highlighted
Dialogue: 0,1:00:30.48,1:00:35.77,ch,,0,0,0,,因为它认为手指并没有偏移出按钮本身的长度\N{\ren}because as i move that it thinks the finger is you know relatively off to the side off (the) side
Dialogue: 0,1:00:35.82,1:00:37.62,ch,,0,0,0,,除非我偏移的的距离足够的远\N{\ren}util i go far enough away
Dialogue: 0,1:00:37.62,1:00:40.52,ch,,0,0,0,,当我点击屏幕上任何一点时,Button做出的行为\N就跟我直接点击Button时的行为一样\N{\ren}which is the same behavior what i have if i actually click the Button
Dialogue: 0,1:00:40.57,1:00:41.88,ch,,0,0,0,,\N{\ren}uh
Dialogue: 0,1:00:41.88,1:00:46.08,ch,,0,0,0,,如果你的目的是只对按下和弹起感兴趣\N{\ren}if you're trying to get more of just a touch down and touch up approach
Dialogue: 0,1:00:46.08,1:00:49.28,ch,,0,0,0,,你不想当你手指像我刚刚那样滑动时,\N按钮还会被高亮显示\N{\ren}and you don't wanna it to still detect when you move around like that
Dialogue: 0,1:00:49.28,1:00:52.18,ch,,0,0,0,,如果你不对坐标进行偏移转换的话\N{\ren}if you don't (inaudible) the coordinates,
Dialogue: 0,1:00:52.25,1:00:53.88,ch,,0,0,0,,你直接就把事件从父视图中发给按钮的话\N{\ren}and you just leave them as they are
Dialogue: 0,1:00:53.91,1:00:56.65,ch,,0,0,0,,那么当你按下手指的时候,按钮仍然会被高亮\N{\ren}then the initial down will still highlight the Button
Dialogue: 0,1:00:56.65,1:01:00.45,ch,,0,0,0,,因为响应ACTION_DOWN并不需要检查事件的位置\N{\ren}because it..the ACTION_DOWN it doesn't check where it is
Dialogue: 0,1:01:00.45,1:01:03.95,ch,,0,0,0,,按钮只知道接收到了一个按下事件,\N然后应该对此事件进行响应\N{\ren}it just assumes that if down was delivered to it,you should do something with it
Dialogue: 0,1:01:04.02,1:01:06.42,ch,,0,0,0,,但是一旦你的手指开始移动从而产生移动事件时\N{\ren}but as soon as they gets the first move event
Dialogue: 0,1:01:06.45,1:01:08.34,ch,,0,0,0,,按钮马上就不高亮了\N{\ren}it will immediately unhighlight
Dialogue: 0,1:01:08.34,1:01:11.24,ch,,0,0,0,,因为按钮认为你传来的移动事件的坐标离按钮本身很远\N{\ren}because it thinks that first move it way off in somewhere else
Dialogue: 0,1:01:11.24,1:01:14.14,ch,,0,0,0,,因此你可以根据你想要达到的效果\N{\ren}so depending on what you're looking for
Dialogue: 0,1:01:14.14,1:01:17.74,ch,,0,0,0,,对事件的坐标按需求进行转换\N{\ren}you may or may not..you may wanna do something different with the coordinates too
Dialogue: 0,1:01:17.74,1:01:19.20,ch,,0,0,0,,实际上,在触摸代理内部所做的是\N{\ren}what TouchDelegate actually does
Dialogue: 0,1:01:19.25,1:01:20.85,ch,,0,0,0,,不论是什么样的事件\N{\ren}is regardless of the event
Dialogue: 0,1:01:20.85,1:01:24.05,ch,,0,0,0,,它都会把事件的坐标设置到(被)代理视图的中心点上\N{\ren}it always sets the x,y to the dead center of the delegate view
Dialogue: 0,1:01:24.05,1:01:25.57,ch,,0,0,0,,因此,即使你在屏幕上用手指长时间滑动\N{\ren}so you can move around all day long
Dialogue: 0,1:01:25.57,1:01:27.87,ch,,0,0,0,,从你的(被)代理的视图上来看,你的移动并不起作用\N(因为ACTION_MOVE的坐标总是中心点嘛)\N{\ren}and it looks to the view like you're not moving at all
Dialogue: 0,1:01:28.05,1:01:29.54,ch,,0,0,0,,因此触摸代理也是一种选择\N{\ren}so that's another option
Dialogue: 0,1:01:29.54,1:01:33.04,ch,,0,0,0,,你可以把事件的坐标设置成任何你想要的坐标,\N之后怎么做就看你了\N{\ren}you can set them to whatever you want but that's a couple different things(inaudible)
Dialogue: 0,1:01:39.11,1:01:40.25,ch,,0,0,0,,\N{\ren}uh
Dialogue: 0,1:01:58.14,1:02:00.60,ch,,0,0,0,,好吧,让我换一种方式描述\N{\ren}well,here,let me describe that this way
Dialogue: 0,1:02:00.60,1:02:03.20,ch,,0,0,0,,因为改变坐标的任务是交由父视图来实现的\N{\ren}because it's the parent's job to change the coordinates
Dialogue: 0,1:02:03.62,1:02:06.94,ch,,0,0,0,,所以唯一的不同之处在于父视图应该让哪个按钮知道\N{\ren}so the only difference is whether one Button versus the other knows
Dialogue: 0,1:02:06.94,1:02:09.24,ch,,0,0,0,,事件是处于其边界之中的\N{\ren}that event is inside its bounds
Dialogue: 0,1:02:09.28,1:02:10.91,ch,,0,0,0,,但是...\N{\ren}ok,this is
Dialogue: 0,1:02:10.91,1:02:13.81,ch,,0,0,0,,我们还是先看这个事件向前传递的例子,\N再回头看触摸代理的例子吧\N{\ren}we'll do the forwarding one first and then go back to the Delegate
Dialogue: 0,1:02:13.81,1:02:17.01,ch,,0,0,0,,这里我们自定义一个很平常的继承自帧布局的ViewGroup\N{\ren}but..so this just basic ViewGroup that extends FrameLayout
Dialogue: 0,1:02:17.01,1:02:19.31,ch,,0,0,0,,这里面没有太多的东西\N{\ren}but doesn't really have a whole lot in it
Dialogue: 0,1:02:19.31,1:02:22.21,ch,,0,0,0,,我让onIntercept方法总是返回true\N{\ren}i'm returning true all the time for onIntercept
Dialogue: 0,1:02:22.25,1:02:24.88,ch,,0,0,0,,这样做的目的仅仅是为了确保\N{\ren}is not really much purpose for that but just so that
Dialogue: 0,1:02:24.88,1:02:26.88,ch,,0,0,0,,如果我的任何一个孩子视图\N{\ren}if any of my child views
Dialogue: 0,1:02:26.91,1:02:30.82,ch,,0,0,0,,还是换个说法,onIntercept的目的就是\N不给任何孩子视图获取触摸事件的机会\N{\ren}basically,do not give any child view the opportunity to get the touch first
Dialogue: 0,1:02:30.82,1:02:32.82,ch,,0,0,0,,因为所有的事件要由我这个ViewGroup向前传递过去\N{\ren}i'm gonna forward them all myself,ok
Dialogue: 0,1:02:32.82,1:02:35.72,ch,,0,0,0,,因此在onTouchEvent()中\N{\ren}and so then in the onTouchEvent()
Dialogue: 0,1:02:35.72,1:02:38.02,ch,,0,0,0,,我先取得孩子视图的引用\N{\ren}we get reference to that child view
Dialogue: 0,1:02:39.22,1:02:41.74,ch,,0,0,0,,然后对每一个触摸事件\N{\ren}and then for each touch event
Dialogue: 0,1:02:42.45,1:02:45.11,ch,,0,0,0,,换个说法...先对手势的开始:ACTION_DOWN事件\N{\ren}we take the... for the initial event
Dialogue: 0,1:02:45.11,1:02:48.61,ch,,0,0,0,,我们先保存好ACTION_DOWN所发生的位置\N{\ren}we figure out where that is and we just save that value off
Dialogue: 0,1:02:48.94,1:02:51.22,ch,,0,0,0,,对ACTION_DOWN和之后的事件\N{\ren}and then for each subsequent event
Dialogue: 0,1:02:51.22,1:02:55.08,ch,,0,0,0,,调用事件中的offsetLocation()方法\N{\ren}there is this method called offsetLocation() on the touch event
Dialogue: 0,1:02:55.08,1:02:58.28,ch,,0,0,0,,此方法会将触摸事件的当前位置进行偏移\N{\ren}that we just take what current touch coordinate it is
Dialogue: 0,1:02:58.34,1:03:00.80,ch,,0,0,0,,偏移量就是传入的deltaX,deltaY参数\N{\ren}change it by the delta between that on initial event
Dialogue: 0,1:03:00.82,1:03:04.47,ch,,0,0,0,,这样事件每次偏移都是相对于第一次按下的位置的\N{\ren}so that the offset is always look the same relative to the first down
Dialogue: 0,1:03:04.47,1:03:06.77,ch,,0,0,0,,这就是我不管在哪按下手指\N{\ren}and that's why no matter where i go
Dialogue: 0,1:03:06.77,1:03:09.97,ch,,0,0,0,,按钮都觉得我是从其中心点开始偏移的\N{\ren}it's relative to where i start so the Button thinks it still in there
Dialogue: 0,1:03:09.97,1:03:11.57,ch,,0,0,0,,不过干这事儿的是父视图\N{\ren}but this is done by the parent view
Dialogue: 0,1:03:11.57,1:03:13.57,ch,,0,0,0,,子视图本身啥也没有变\N{\ren}as nothing to do with the views themselves
Dialogue: 0,1:03:15.00,1:03:16.20,ch,,0,0,0,,嗯哼\N{\ren}en,uh
Dialogue: 0,1:03:17.74,1:03:21.28,ch,,0,0,0,,我们来看看触摸代理是怎么做的吧\N{\ren}ok,and then the TouchDelegate look the way that works
Dialogue: 0,1:03:21.28,1:03:24.78,ch,,0,0,0,,这里所用到的基本思路跟刚讲的差不多,\N自定义ViewGroup还是继承自帧布局\N{\ren}it's the same basic idea,we got this FrameLayout here this custom view
Dialogue: 0,1:03:24.78,1:03:26.78,ch,,0,0,0,,还有\N{\ren}and
Dialogue: 0,1:03:26.78,1:03:30.58,ch,,0,0,0,,在此例子中,我们并没有\N{\ren}when the view starts ..in this case..we are not like
Dialogue: 0,1:03:30.65,1:03:33.17,ch,,0,0,0,,在XML文件中添加一个视图\N{\ren}adding the child view though XML or anything like that
Dialogue: 0,1:03:33.17,1:03:36.67,ch,,0,0,0,,我只是新建了一个复选框对象,然后将其\N作为一个孩子视图添加到了布局中\N{\ren}i just make this checkbox and add it as a child view
Dialogue: 0,1:03:36.67,1:03:39.27,ch,,0,0,0,,这里有意思的事情是\N{\ren}you know,the interest thing here is
Dialogue: 0,1:03:39.27,1:03:43.37,ch,,0,0,0,,为了确定触摸代理区域矩形的大小\N{\ren}in order to determine what size i want that rect to be
Dialogue: 0,1:03:43.37,1:03:47.17,ch,,0,0,0,,我需要等到ViewGroup大小被测量过后,再初始化矩形\N{\ren}i have to wait until the view actually has a measured size
Dialogue: 0,1:03:47.17,1:03:50.80,ch,,0,0,0,,因为当我View被初始化后是没有大小的\N{\ren}when i instantiate this view,it  has no size
Dialogue: 0,1:03:50.80,1:03:55.20,ch,,0,0,0,,Android会在特定的时机下去测量视图,布局视图等等\N{\ren}cause Android measures,and layouts views later on in the process
Dialogue: 0,1:03:55.22,1:03:58.31,ch,,0,0,0,,尽管我已经在这儿把复选框添加到ViewGroup中了\N{\ren}so even now,i've added the view here
Dialogue: 0,1:03:58.31,1:04:00.91,ch,,0,0,0,,但是我还不能马上去设置触摸代理\N{\ren}i can't do any the TouchDelegate stuff right away
Dialogue: 0,1:04:00.91,1:04:02.91,ch,,0,0,0,,因为我要等到\N{\ren}so instead,what i'm waiting to do
Dialogue: 0,1:04:02.91,1:04:06.71,ch,,0,0,0,,ViewGroup大小确定以后才行\N一般要等到onSizeChanged被回调\N{\ren}and i could this in two places i typically do this onSizeChanged
Dialogue: 0,1:04:06.71,1:04:08.71,ch,,0,0,0,,或者是onMeasure被回调\N{\ren}but you could do it onMeasure as well
Dialogue: 0,1:04:08.71,1:04:11.61,ch,,0,0,0,,在onMeasure的回调中\N{\ren}but inside of the onMeasure callback
Dialogue: 0,1:04:11.62,1:04:14.20,ch,,0,0,0,,ViewGroup会收到\N{\ren}which is what the ViewGroup will receive
Dialogue: 0,1:04:14.20,1:04:18.60,ch,,0,0,0,,系统给它的传话,"你在屏幕上到底能够有多大"\N{\ren}when the framework wants to give it a size and say how big should you be on screen
Dialogue: 0,1:04:18.60,1:04:20.40,ch,,0,0,0,,此时\N{\ren}so,at that point
Dialogue: 0,1:04:20.42,1:04:22.57,ch,,0,0,0,,一旦super.onMeasure执行完毕\N{\ren}once the super implementation measures
Dialogue: 0,1:04:22.57,1:04:26.07,ch,,0,0,0,,你就能获知视图在显示屏上所占的大小了\N{\ren}where it's gonna be as the size of my display screen there
Dialogue: 0,1:04:26.07,1:04:30.17,ch,,0,0,0,,这样以来,我就可以获取代理区域矩形的边界参数了\N{\ren}then i can generate this rectangle for the bounds of my touch forwarding
Dialogue: 0,1:04:30.17,1:04:34.20,ch,,0,0,0,,左0,上0,右measuredWidth,下measuredHeight\N{\ren}which is really just from 0,0 to the measuredWidth and Height of this view
Dialogue: 0,1:04:34.20,1:04:36.20,ch,,0,0,0,,这些值是在测量之后用的,因此有效\N{\ren}now that i've measured myself
Dialogue: 0,1:04:36.25,1:04:39.22,ch,,0,0,0,,接着我就能初始化一个触摸代理对象了\N{\ren}and then i can instantiate that TouchDelegate to say
Dialogue: 0,1:04:39.22,1:04:42.42,ch,,0,0,0,,这样在矩形区域中的任何触摸事件就能传给按钮了\N{\ren}inside the bounds for what everything to that Button
Dialogue: 0,1:04:42.42,1:04:45.62,ch,,0,0,0,,最后一步,调用父视图的设置触摸代理就可以打完收工了\N{\ren}and then call setTouchDelegate on the parent
Dialogue: 0,1:04:46.08,1:04:46.77,ch,,0,0,0,,\N{\ren}ok
Dialogue: 0,1:04:46.85,1:04:50.31,ch,,0,0,0,,最后一步是在父视图跟孩子视图之间设置了一层关系\N{\ren}so this is setting up that relationship between the parent child view
Dialogue: 0,1:04:50.31,1:04:52.91,ch,,0,0,0,,通过使用一个触摸代理来帮我做事件向前传递\N{\ren}using a touch delegate to do all the forwarding for me
Dialogue: 0,1:04:52.97,1:04:54.82,ch,,0,0,0,,使用触摸代理的不同之处在于\N{\ren}and the only difference here is that
Dialogue: 0,1:04:54.82,1:04:58.62,ch,,0,0,0,,不论我在屏幕哪个地方触摸或者拖拽\N{\ren}it doesn't matter where i touch or how i drag my finger
Dialogue: 0,1:04:58.62,1:05:01.22,ch,,0,0,0,,这里复选框收到的\N{\ren}the coordinates that the checkbox receives
Dialogue: 0,1:05:01.25,1:05:05.22,ch,,0,0,0,,每个事件的坐标都会是视图本身的中心点\N{\ren}will always be for every event dead center that view
Dialogue: 0,1:05:05.31,1:05:08.11,ch,,0,0,0,,中心点大体都是视图宽度/2,视图高度/2\N{\ren}basically just whatever the width and height that be with divided by 2
Dialogue: 0,1:05:08.14,1:05:11.54,ch,,0,0,0,,这就是触摸代理对事件坐标所做的转换\N{\ren}and that's how delegate changes it's location before it does it
Dialogue: 0,1:05:11.54,1:05:14.44,ch,,0,0,0,,其实,触摸代理做的跟我们刚才\N手动做事件向前传递所做的并无二致\N{\ren}so delegate is actually doing the same things as we did here
Dialogue: 0,1:05:14.44,1:05:17.94,ch,,0,0,0,,触摸代理只不过把过程封装起来了而已\N{\ren}just you know special case,under the hood.ok
Dialogue: 0,1:05:22.54,1:05:23.37,ch,,0,0,0,,谈下一个话题\N{\ren}all right
Dialogue: 0,1:05:30.94,1:05:33.80,ch,,0,0,0,,接下来的话,我还是会把两个例子放在一起讲\N{\ren}so the next show i'll show you together as well
Dialogue: 0,1:05:33.80,1:05:37.60,ch,,0,0,0,,这个例子说的是一个二维的滚动视图\N{\ren}this is an example of a two dimensional ScrollView
Dialogue: 0,1:05:37.74,1:05:40.65,ch,,0,0,0,,此例中我创建的ViewGroup是干啥的呢\N{\ren}so,what i basically created here is a ViewGroup
Dialogue: 0,1:05:40.65,1:05:42.97,ch,,0,0,0,,我们可以在其中放孩子视图\N{\ren}so that we can stick child views inside of
Dialogue: 0,1:05:42.97,1:05:45.57,ch,,0,0,0,,但是这些孩子视图是非常非常大的\N{\ren}and those views are just completely huge
Dialogue: 0,1:05:45.62,1:05:47.74,ch,,0,0,0,,你看,我可以在ViewGroup中上下左右滑动\N{\ren}we can scroll in both directions
Dialogue: 0,1:05:47.74,1:05:49.74,ch,,0,0,0,,来把视图里面的内容看个究竟\N{\ren}(depend) all the way around the content,right
Dialogue: 0,1:05:49.74,1:05:52.94,ch,,0,0,0,,你看我小指一飞划,它就在做滚动动画了\N{\ren}you can see that i can fling this and animates
Dialogue: 0,1:05:53.05,1:05:57.65,ch,,0,0,0,,当其滑动到两边的边界时,就停止滑动等等\N{\ren}and i can scroll it stops the bounds in both directions and all that stuff
Dialogue: 0,1:05:57.65,1:05:59.37,ch,,0,0,0,,除此之外,你要注意到这些视图项全是按钮\N{\ren}but these are all Buttons
Dialogue: 0,1:05:59.37,1:06:01.97,ch,,0,0,0,,如果我点击它们,这些按钮还是可以响应的,神奇么?\N{\ren}and if i tap them,the Button is still clickable,right
Dialogue: 0,1:06:01.97,1:06:04.87,ch,,0,0,0,,你看,我在这儿并没有屏蔽事件,除非当我需要的时候\N{\ren}so i am not stealing all the events just when necessary
Dialogue: 0,1:06:04.87,1:06:06.87,ch,,0,0,0,,\N{\ren}ok
Dialogue: 0,1:06:06.87,1:06:10.37,ch,,0,0,0,,另外我还有个类似效果的例子\N{\ren}then i have a second example that's very similar to that
Dialogue: 0,1:06:10.37,1:06:14.17,ch,,0,0,0,,这里的视觉行为是相同的,不过只用一张很大的图片\N{\ren}that's the same visual behavior using just a single large image
Dialogue: 0,1:06:14.25,1:06:16.91,ch,,0,0,0,,尽管行为差不多,但其实现机制\N{\ren}but in this case what we are implementing
Dialogue: 0,1:06:16.91,1:06:20.41,ch,,0,0,0,,是由手势侦听器来实现的\N{\ren}is we were doing all the same code with the gesture detector
Dialogue: 0,1:06:20.57,1:06:24.57,ch,,0,0,0,,因此两个例子中达到的效果都是一样的\N{\ren}so it's the same basic functionality that we end up with in both cases
Dialogue: 0,1:06:24.60,1:06:27.97,ch,,0,0,0,,但是你会看到自己手动写代码跟使用手势监听器\N{\ren}but you can see how much more less code is required to do that
Dialogue: 0,1:06:27.97,1:06:31.77,ch,,0,0,0,,两者之间,相差了多少的代码量\N{\ren}with you do it all yourself or you do with the gesture detector,ok
Dialogue: 0,1:06:39.31,1:06:41.71,ch,,0,0,0,,好了,咱们先看这个\N{\ren}go back to this one
Dialogue: 0,1:06:41.71,1:06:43.71,ch,,0,0,0,,咱们先看这个手势侦听器的版本\N{\ren}let's do the gesture version first
Dialogue: 0,1:06:44.05,1:06:46.00,ch,,0,0,0,,我会快速的带领大家过一遍\N{\ren}ok,i'm gonna quickly walk you though it
Dialogue: 0,1:06:46.05,1:06:48.80,ch,,0,0,0,,有些东西可能跟触摸关系不大,\N但我还会给你解释说明一下\N{\ren}it's not really relevant to touch but i want you to know what you're looking at
Dialogue: 0,1:06:48.88,1:06:50.57,ch,,0,0,0,,这样当你去看我的源码时,就能看得通了\N{\ren}if you go back over the sample code later
Dialogue: 0,1:06:50.57,1:06:54.34,ch,,0,0,0,,这个视图中有一大堆代码是关于滚动的\N{\ren}there is a bunch code in this view to do the scrolling piece
Dialogue: 0,1:06:54.45,1:06:55.71,ch,,0,0,0,,这些代码\N{\ren}which is
Dialogue: 0,1:06:55.77,1:06:59.05,ch,,0,0,0,,可能跟触摸交互的联系不太大\N{\ren}only loosely coupled to the touch interaction (sob)
Dialogue: 0,1:06:59.05,1:07:00.57,ch,,0,0,0,,稍后你就能看到\N{\ren}we'll see what that is
Dialogue: 0,1:07:00.57,1:07:03.47,ch,,0,0,0,,先从这儿看起,首先我干的事儿是\N{\ren}as we're going down here,notice the first thing i do
Dialogue: 0,1:07:03.47,1:07:05.47,ch,,0,0,0,,获取slop常量\N{\ren}is get that slop constant
Dialogue: 0,1:07:05.48,1:07:08.48,ch,,0,0,0,,当视图被初始化后,我就能获取此值来检验拖拽了\N{\ren}when the view is initialized so that i can do those checks for the dragging
Dialogue: 0,1:07:08.77,1:07:09.65,ch,,0,0,0,,\N{\ren}ok
Dialogue: 0,1:07:11.88,1:07:17.31,ch,,0,0,0,,随后的这些方法就是针对滚动那部分的了\N{\ren}these..the next few methods are specifically related to the scrolling piece
Dialogue: 0,1:07:17.37,1:07:20.34,ch,,0,0,0,,我在此ViewGroup中重写了这两个方法\N{\ren}so i'm overwriting these two methods on ViewGroup
Dialogue: 0,1:07:20.34,1:07:22.64,ch,,0,0,0,,一个是measureChild,一个是measureChildWithMargins\N{\ren}called measureChild and measureChildWithMargins
Dialogue: 0,1:07:22.74,1:07:24.71,ch,,0,0,0,,在大多数的ViewGroup中\N{\ren}in most ViewGroups
Dialogue: 0,1:07:24.71,1:07:27.31,ch,,0,0,0,,比方我们在这儿用到的帧布局之类的\N{\ren}like the FrameLayout that we're using here
Dialogue: 0,1:07:27.31,1:07:31.71,ch,,0,0,0,,默认情况下,这些布局是不允许其子视图大过自身的\N{\ren}by default,they don't allow there children to be larger than themselves
Dialogue: 0,1:07:31.71,1:07:35.81,ch,,0,0,0,,这些布局总是强制限制其子视图,\N使其小于等于自身大小\N{\ren}and they always force constrain them to be at least the same size or smaller
Dialogue: 0,1:07:35.91,1:07:38.42,ch,,0,0,0,,为了打破这个限制,我们就重写了这两个方法\N{\ren}so we're overriding this method
Dialogue: 0,1:07:38.51,1:07:40.08,ch,,0,0,0,,其实这里做的事情跟ScrollView做的事情是一样的\N{\ren}which is the same thing that's ScrollView does
Dialogue: 0,1:07:40.08,1:07:43.28,ch,,0,0,0,,我这里只是照抄了ScrollView的实现\N{\ren}this actually just stole from how ScrollView's implementation is done
Dialogue: 0,1:07:43.31,1:07:44.25,ch,,0,0,0,,\N{\ren}uh
Dialogue: 0,1:07:44.31,1:07:46.11,ch,,0,0,0,,这样做的话\N{\ren}we are overriding this
Dialogue: 0,1:07:46.11,1:07:50.62,ch,,0,0,0,,就能让孩子视图被测量出的大小大过其父视图\N{\ren}so that the child views can be allowed to be measured larger than their parent container
Dialogue: 0,1:07:50.68,1:07:52.00,ch,,0,0,0,,前提是孩子视图真的比父视图大\N{\ren}if they wanna to be
Dialogue: 0,1:07:52.02,1:07:56.57,ch,,0,0,0,,这里我们做的其实也不复杂,\N仅仅是把测量规格改成了UNSPECIFIED\N{\ren}and all were really doing is changing their measureSpecs to be UNSPECIFIED
Dialogue: 0,1:07:56.57,1:07:58.88,ch,,0,0,0,,如果你对这里的\N{\ren}if you have other specific questions about
Dialogue: 0,1:07:58.88,1:08:00.48,ch,,0,0,0,,视图如何测量等等问题有疑问的话\N{\ren}how view measurement and stuff works
Dialogue: 0,1:08:00.51,1:08:03.25,ch,,0,0,0,,你可以参考一下今天早上的自定义视图课程\N{\ren}i might refer you to the custom view session this morning
Dialogue: 0,1:08:03.28,1:08:06.37,ch,,0,0,0,,看看那节课的PPT,看了之后如果你还有疑问,再来找我.\N{\ren}look at those slides so maybe we can answer some other questions offline on that
Dialogue: 0,1:08:06.42,1:08:08.20,ch,,0,0,0,,但是这里用到的仅仅是这些\N{\ren}but that's all these are doing
Dialogue: 0,1:08:08.22,1:08:11.94,ch,,0,0,0,,接下来看这两个方法computerScroll()和scrollTo()\N{\ren}then these next two methods computerScroll() and scrollTo()
Dialogue: 0,1:08:11.94,1:08:13.82,ch,,0,0,0,,这两个方法在任何View和ViewGroup中都存在\N{\ren}these are methods on any View or ViewGroup
Dialogue: 0,1:08:13.82,1:08:16.42,ch,,0,0,0,,你可以用这两个方法来滚动视图的内容\N{\ren}that you can use to scroll content around
Dialogue: 0,1:08:16.45,1:08:19.68,ch,,0,0,0,,你不用自己动手去画下一帧的滚动视图等等,\N{\ren}so you don't have to you know..do custom drawing or anything like that
Dialogue: 0,1:08:19.71,1:08:22.91,ch,,0,0,0,,对一个视图进行滚动,你只要调用scrollTo()方法就行\N{\ren}you can just scroll a view by calling this  scrollTo()
Dialogue: 0,1:08:22.97,1:08:23.62,ch,,0,0,0,,此方法\N{\ren}and it
Dialogue: 0,1:08:23.62,1:08:27.72,ch,,0,0,0,,此方法会自己计算出滚动的偏移量\N并且画出滚动时的图像\N{\ren}it could generate those scroll offsets to draw the content in a different place
Dialogue: 0,1:08:27.80,1:08:28.22,ch,,0,0,0,,\N{\ren}ok
Dialogue: 0,1:08:28.22,1:08:31.72,ch,,0,0,0,,computeScroll是用于动画方面的\N{\ren}now,computeScroll() is used in the animated set of things
Dialogue: 0,1:08:31.82,1:08:34.60,ch,,0,0,0,,其中用到了一个叫做滚动器的对象\N{\ren}using this object called a scroller
Dialogue: 0,1:08:34.65,1:08:36.31,ch,,0,0,0,,这点我不会涉及很深\N{\ren}i won't go on too much detail on that
Dialogue: 0,1:08:36.31,1:08:39.51,ch,,0,0,0,,但是滚动器大致上就是你小指飞划时的数学引擎而已\N{\ren}but the scroller is basically just the math engine to animate your flings
Dialogue: 0,1:08:39.57,1:08:43.11,ch,,0,0,0,,系统会重复调用computeScroll()这个方法\N{\ren}and then computeScroll() is the repeated callback that the framework gives you
Dialogue: 0,1:08:43.11,1:08:45.11,ch,,0,0,0,,来使你的动画能继续动起来\N{\ren}so that you can continue to animate
Dialogue: 0,1:08:45.11,1:08:48.31,ch,,0,0,0,,重申一下,这方面你要是问题来了,咱就延后再议吧\N{\ren}again,if you have more questions on that we can talk about that later
Dialogue: 0,1:08:48.40,1:08:51.22,ch,,0,0,0,,接下来我们的scrollTo被简单的重写了\N{\ren}and but our scrollTo() is being overwritten
Dialogue: 0,1:08:51.25,1:08:54.14,ch,,0,0,0,,加了个边界处理\N{\ren}simply so that we can clamp the edges of the content
Dialogue: 0,1:08:54.14,1:08:56.22,ch,,0,0,0,,这样我就便于知道视图何时该停下滚动\N{\ren}so i know when to stop allowing scrolling
Dialogue: 0,1:08:56.22,1:08:58.52,ch,,0,0,0,,这样就视图就不会自己滚着滚着滚出界了\N{\ren}not based on you know even if they keep
Dialogue: 0,1:08:58.52,1:09:00.52,ch,,0,0,0,,这样就视图就不会自己滚着滚着滚出界了\N{\ren}trying to go the other direction
Dialogue: 0,1:09:01.22,1:09:03.42,ch,,0,0,0,,clamp.这个方法就是刚刚用来做边界处理的\N{\ren}helper method for animating the fling
Dialogue: 0,1:09:04.62,1:09:06.80,ch,,0,0,0,,但是真正有趣的东西是在这儿\N{\ren}but the real interesting stuff is done here
Dialogue: 0,1:09:07.42,1:09:09.68,ch,,0,0,0,,为了达到我们的想要触摸交互效果\N{\ren}so in order to do that touch interaction
Dialogue: 0,1:09:09.68,1:09:12.88,ch,,0,0,0,,我们要滚动,我们还要飞划,我们还要等等\N{\ren}to detect the scroll,to detect the fling,to do all those
Dialogue: 0,1:09:12.88,1:09:15.18,ch,,0,0,0,,这些只用一个手势侦听器就可以实现\N{\ren}i'm just using a gesture detector,ok
Dialogue: 0,1:09:15.22,1:09:17.80,ch,,0,0,0,,我在这儿重写了手势侦听器的3个方法\N{\ren}the gesture detector i'm overwriting three methods
Dialogue: 0,1:09:17.85,1:09:19.34,ch,,0,0,0,,现在,注意我在onDown方法中所干的事儿\N{\ren}i'm paying attention to onDown()
Dialogue: 0,1:09:19.34,1:09:21.34,ch,,0,0,0,,本质上,\N{\ren}essentially,so that
Dialogue: 0,1:09:21.37,1:09:24.62,ch,,0,0,0,,我先飞划一下,然后如果我在飞划动画\N还在运动的时候点击了屏幕\N{\ren}as i fling if i touch my finger during the animation
Dialogue: 0,1:09:24.71,1:09:27.60,ch,,0,0,0,,那么飞划动画就应该立马停止,\N视图应取消其正在干的任何事情\N{\ren}it should immediately stop it should abort whatever it's been doing
Dialogue: 0,1:09:27.62,1:09:29.14,ch,,0,0,0,,系统的框架也是这么干的\N{\ren}which was the framework does well
Dialogue: 0,1:09:29.14,1:09:31.74,ch,,0,0,0,,我们这儿为了向系统看齐\N{\ren}so just getting that same behavior
Dialogue: 0,1:09:31.74,1:09:36.74,ch,,0,0,0,,我们只需在onDown中调用滚动器的abortAnimation()即可\N{\ren}is we just run that abortAnimation() method on that animate scroll engine
Dialogue: 0,1:09:37.42,1:09:39.85,ch,,0,0,0,,下面我们还重写了onFling和onScroll\N{\ren}then we have onFling() and onScroll()
Dialogue: 0,1:09:39.85,1:09:41.85,ch,,0,0,0,,这两个办法被调用的时机是\N{\ren}so these two methods get called
Dialogue: 0,1:09:41.91,1:09:44.91,ch,,0,0,0,,onFling()被调用的时机是当你的手指\N{\ren}well onFling() gets called at the moment that you lift your finger
Dialogue: 0,1:09:44.94,1:09:46.85,ch,,0,0,0,,带有一定的速度离开屏幕时\N{\ren}and there is some velocity behind it
Dialogue: 0,1:09:46.88,1:09:50.20,ch,,0,0,0,,此时,系统会告知作为一个应用开发者的你\N{\ren}and that tells you as an application developer
Dialogue: 0,1:09:50.20,1:09:52.20,ch,,0,0,0,,你应该开始进行飞划动画了\N{\ren}that you should start that animation
Dialogue: 0,1:09:52.20,1:09:54.50,ch,,0,0,0,,这里我们调用了fling()这个帮助方法\N{\ren}so we were calling that fling helper method
Dialogue: 0,1:09:54.50,1:09:57.40,ch,,0,0,0,,此方法触发了滚动器上的fling动画\N{\ren}which triggers the animation on the scroller
Dialogue: 0,1:09:58.54,1:10:01.80,ch,,0,0,0,,对另一个方法onScroll()这个函数会被系统常常调用\N{\ren}the onScroll() this one is gonna called a lot
Dialogue: 0,1:10:01.85,1:10:06.37,ch,,0,0,0,,每当你拖拽你的手指时,\N{\ren}so as you dragging your finger for all these mini scale delta as you dragging
Dialogue: 0,1:10:06.37,1:10:08.97,ch,,0,0,0,,系统都会调用onScroll()\N{\ren}you get onScroll() , onScroll() ,onScroll()
Dialogue: 0,1:10:09.05,1:10:12.31,ch,,0,0,0,,我们不需要自己计算出\N{\ren}we don't have to do the math of
Dialogue: 0,1:10:12.34,1:10:15.80,ch,,0,0,0,,我们何时滑动了这段距离,以及我们的滑动方向\N{\ren}figuring out when we moves this distance or which direction we move
Dialogue: 0,1:10:15.82,1:10:17.08,ch,,0,0,0,,系统帮我们做了\N{\ren}it does all that for us
Dialogue: 0,1:10:17.08,1:10:19.38,ch,,0,0,0,,我们只要把distanceX,distanceY传递给\N{\ren}we just have to pass those into
Dialogue: 0,1:10:19.42,1:10:22.14,ch,,0,0,0,,scrollBy()方法即可,这个方法也是View自带的\N{\ren}the scrollBy() method which again is a method of a view
Dialogue: 0,1:10:22.20,1:10:25.17,ch,,0,0,0,,我不用重写这个方法来针对特殊情况.我只是调用\N这个方法来告诉视图去滚动它的内容\N{\ren}i don't have to write it in (special),just tell the view to scroll its contents
Dialogue: 0,1:10:25.17,1:10:26.54,ch,,0,0,0,,基于我们滚动了多远\N{\ren}based on how far we moved
Dialogue: 0,1:10:26.54,1:10:30.64,ch,,0,0,0,,你不要需要做任何数学计算等等,\N你只要把距离参数穿进去就可以了\N{\ren}you don't have to do any math sort thing like that,just take that distance hand to the view
Dialogue: 0,1:10:30.65,1:10:31.17,ch,,0,0,0,,\N{\ren}ok
Dialogue: 0,1:10:32.88,1:10:35.14,ch,,0,0,0,,滚动是飞划动画的一部分\N{\ren}scroll is animated piece for flings
Dialogue: 0,1:10:35.14,1:10:37.14,ch,,0,0,0,,这是View自带的\N{\ren}this is all written on view
Dialogue: 0,1:10:39.08,1:10:42.08,ch,,0,0,0,,那会调用scrollTo方法...\N{\ren}it's gonna call the scrollTo() that we have appeared.yes
Dialogue: 0,1:10:43.74,1:10:44.37,ch,,0,0,0,,\N{\ren}ok
Dialogue: 0,1:10:46.17,1:10:49.54,ch,,0,0,0,,最后,为了让我们的侦听器开始工作\N{\ren}and then,in order to trigger this thing
Dialogue: 0,1:10:49.54,1:10:53.64,ch,,0,0,0,,我们一方面要在onIntercept中做些事情\N{\ren}we have implementations in onIntercept()
Dialogue: 0,1:10:53.64,1:10:56.54,ch,,0,0,0,,另一方面还要在onTouchEvent中做些事情.\N我们先看onTouchEvent吧\N{\ren}and onTouchEvent() so i'll start with onTouchEvent()
Dialogue: 0,1:10:56.57,1:10:58.31,ch,,0,0,0,,onTouchEvent()是比较简单的\N{\ren}onTouchEvent() is pretty simple
Dialogue: 0,1:10:58.31,1:11:01.21,ch,,0,0,0,,对于我得到的每个事件,我都把它传递给侦听器\N{\ren}for each event i get,i forward it to the detector
Dialogue: 0,1:11:01.28,1:11:02.31,ch,,0,0,0,,完事儿\N{\ren}end story
Dialogue: 0,1:11:02.31,1:11:05.51,ch,,0,0,0,,侦听器就开始帮我做所有的数学工作了\N{\ren}it does all the other math for me to do that work
Dialogue: 0,1:11:05.54,1:11:09.54,ch,,0,0,0,,onIntercept的话,我就得多干点事情了.\N因为我不想屏蔽所有事件\N{\ren}onIntercept() i have to do a little work cause i don't want it do for every touch event
Dialogue: 0,1:11:09.54,1:11:12.44,ch,,0,0,0,,我只想要在我拖拽的时候进行事件屏蔽\N{\ren}i only wanna do it once we've started dragging
Dialogue: 0,1:11:12.45,1:11:15.97,ch,,0,0,0,,每当我开始拖拽时,我就把所有的事件传给我的侦听器\N{\ren}once we start dragging.i wanna all the events to go through my detector
Dialogue: 0,1:11:15.97,1:11:18.27,ch,,0,0,0,,但是同时我还要能够对按钮的点击做出事件响应等等\N{\ren}but i still want it be able to click the Buttons and stuff like that
Dialogue: 0,1:11:18.27,1:11:22.37,ch,,0,0,0,,因此,我检查了ACTION_DOWN和ACTION_MOVE\N{\ren}so i'm checking against basically ACTION_DOWN and ACTION_MOVE
Dialogue: 0,1:11:22.37,1:11:25.87,ch,,0,0,0,,检查这两个事件是为了搞清楚手指在屏幕上所处的位置\N{\ren}to say that when the finger goes down i need figured out where i was
Dialogue: 0,1:11:25.87,1:11:27.87,ch,,0,0,0,,对于每一个移动事件来说\N{\ren}and then for every move event
Dialogue: 0,1:11:27.88,1:11:29.17,ch,,0,0,0,,我需要检查\N{\ren}i need to check the delta
Dialogue: 0,1:11:29.17,1:11:31.77,ch,,0,0,0,,起始触摸点跟当前所处点之间的增量\N{\ren}between my initial touch point and where i am now
Dialogue: 0,1:11:31.77,1:11:33.77,ch,,0,0,0,,然后用此增量跟slop相比\N{\ren}against that slop value
Dialogue: 0,1:11:33.82,1:11:35.45,ch,,0,0,0,,其实这就是我前面说slop检查\N{\ren}that's all that really is to a slop check
Dialogue: 0,1:11:35.45,1:11:37.80,ch,,0,0,0,,看似不太起眼\N{\ren}but it makes a huge difference
Dialogue: 0,1:11:37.80,1:11:41.60,ch,,0,0,0,,但是能极大地提升用户体验\N{\ren}in the user's experience of what you're trying to do with your touch
Dialogue: 0,1:11:44.22,1:11:45.25,ch,,0,0,0,,这里告一段落\N{\ren}all right.so
Dialogue: 0,1:11:45.25,1:11:47.55,ch,,0,0,0,,看哥的另一个例子\N{\ren}flip that over to
Dialogue: 0,1:11:48.42,1:11:50.82,ch,,0,0,0,,哥的二维ScrollView\N{\ren}the two dimensional ScrollView
Dialogue: 0,1:11:52.97,1:11:53.60,ch,,0,0,0,,我在听\N{\ren}yeah
Dialogue: 0,1:12:01.11,1:12:03.74,ch,,0,0,0,,两者(onTouchEven跟onIntercept)的目的不同,不是么\N{\ren}well,they sort of different purposes right?
Dialogue: 0,1:12:03.94,1:12:08.02,ch,,0,0,0,,onTouchEvent告诉系统的是\N{\ren}the onTouchEvent is reporting to the framework that
Dialogue: 0,1:12:08.11,1:12:10.34,ch,,0,0,0,,关于此手势中,我这个View想要处理的事件,\N以及随后的事件是什么\N{\ren}this event and subsequent events in the gesture
Dialogue: 0,1:12:10.34,1:12:12.34,ch,,0,0,0,,关于此手势中,我这个View想要处理的事件,\N以及随后的事件是什么\N{\ren}you as a view want to handle
Dialogue: 0,1:12:12.34,1:12:15.24,ch,,0,0,0,,onIntercept告诉系统的是,我作为一个ViewGroup\N{\ren}onIntercept() is saying that as a ViewGroup
Dialogue: 0,1:12:15.28,1:12:18.71,ch,,0,0,0,,我想要把本来由其他视图处理的手势截取过来\N{\ren}you want to take this current gesture being handled by someone else
Dialogue: 0,1:12:18.71,1:12:21.01,ch,,0,0,0,,然后交由自己来处理\N{\ren}and start handling it yourself
Dialogue: 0,1:12:21.01,1:12:23.61,ch,,0,0,0,,因此他们两个有着不同的用途\N{\ren}so that they have slightly different use cases
Dialogue: 0,1:12:23.65,1:12:25.85,ch,,0,0,0,,还有一点是,只有在ViewGroup中才能用onIntercept\N{\ren}and onIntercept is only available on a ViewGroup
Dialogue: 0,1:12:25.85,1:12:28.08,ch,,0,0,0,,View自身里面是没有这个函数的\N{\ren}just simple views don't have that abilities
Dialogue: 0,1:12:28.08,1:12:31.88,ch,,0,0,0,,只有ViewGroup才可以屏蔽其子视图的事件\N{\ren}just the ViewGroups can intercept touches from any of their children
Dialogue: 0,1:12:31.88,1:12:35.08,ch,,0,0,0,,通过在此方法中返回true\N{\ren}using by returning true from that particular method
Dialogue: 0,1:12:35.17,1:12:38.28,ch,,0,0,0,,onIntercept更多的是重定向整个手势的目的地\N{\ren}onIntercept() is more of redirection of the (existing) gesture
Dialogue: 0,1:12:38.28,1:12:40.14,ch,,0,0,0,,而onTouchEvent就更多的是\N{\ren}where is onTouch() is more about
Dialogue: 0,1:12:40.14,1:12:43.04,ch,,0,0,0,,消费掉手势中你感兴趣的一部分事件\N{\ren}consuming the events is part of the gesture you currently working with
Dialogue: 0,1:12:45.20,1:12:45.85,ch,,0,0,0,,\N{\ren}all right
Dialogue: 0,1:12:45.85,1:12:48.28,ch,,0,0,0,,到这儿为止我写的代码\N{\ren}so all the code up to this point is exactly the same
Dialogue: 0,1:12:48.28,1:12:50.25,ch,,0,0,0,,跟我刚才的例子中的代码都是一样的\N{\ren}in the previous one as we have here
Dialogue: 0,1:12:50.40,1:12:50.94,ch,,0,0,0,,\N{\ren}uh
Dialogue: 0,1:12:50.97,1:12:52.08,ch,,0,0,0,,唯一的不同在于\N{\ren}the only difference here
Dialogue: 0,1:12:52.08,1:12:54.98,ch,,0,0,0,,我们必须靠自己来计算好各种手势了\N{\ren}is now we have to manage a lot of this ourselves
Dialogue: 0,1:12:55.05,1:12:57.68,ch,,0,0,0,,因此这里我们用到了速度跟踪器类\N{\ren}so we have classes like a VelocityTracker
Dialogue: 0,1:12:57.68,1:12:59.68,ch,,0,0,0,,此类也是框架的一部分\N{\ren}these all part of the framework,but
Dialogue: 0,1:12:59.74,1:13:01.57,ch,,0,0,0,,速度跟踪器用处在于\N{\ren}VelocityTrackers are used
Dialogue: 0,1:13:01.60,1:13:02.28,ch,,0,0,0,,可以帮助我们\N{\ren}so that
Dialogue: 0,1:13:02.34,1:13:05.40,ch,,0,0,0,,根据每个独立的事件,计算出\N{\ren}we can do the math of determining for each individual touch event
Dialogue: 0,1:13:05.40,1:13:08.90,ch,,0,0,0,,手指滑动的速度是否能达到一个飞划的级别\N{\ren}whether or not that velocity is worth detecting as a fling
Dialogue: 0,1:13:09.00,1:13:09.77,ch,,0,0,0,,\N{\ren}uh
Dialogue: 0,1:13:09.82,1:13:13.74,ch,,0,0,0,,因此对于处于onIntercept中的每个单独事件\N{\ren}so for each individual event inside of onIntercept()
Dialogue: 0,1:13:13.74,1:13:16.34,ch,,0,0,0,,还有后面的onTouchEvent方法中的每个触摸事件\N{\ren}and then further down inside of onTouch()
Dialogue: 0,1:13:16.37,1:13:18.42,ch,,0,0,0,,我们不断地跟踪记录这些事件\N{\ren}we are constantly tracking these values
Dialogue: 0,1:13:18.45,1:13:21.62,ch,,0,0,0,,通过调用速度跟踪器的addMovement方法\N{\ren}by calling addMovement on the velocityTracker
Dialogue: 0,1:13:21.62,1:13:24.52,ch,,0,0,0,,因此速度跟踪器也是系统数学引擎的一种\N{\ren}so velocityTracker is just another one of those math engines
Dialogue: 0,1:13:24.57,1:13:25.71,ch,,0,0,0,,它会根据传进的事件\N{\ren}so that for each event
Dialogue: 0,1:13:25.71,1:13:28.91,ch,,0,0,0,,在任何时候返回手指的滑动速度\N{\ren}that can tell me at any given time what is the velocity of the finger
Dialogue: 0,1:13:29.65,1:13:33.71,ch,,0,0,0,,然后,对于ACTION_UP的处理就是\N{\ren}and then for in cases like,when we get to ACTION_UP
Dialogue: 0,1:13:33.88,1:13:37.40,ch,,0,0,0,,判断当前手指的速度\N{\ren}if we need to determine what the current velocity is
Dialogue: 0,1:13:37.40,1:13:39.70,ch,,0,0,0,,是否能达到我们称之为飞划的速度\N{\ren}and figure out if we wish call that a fling
Dialogue: 0,1:13:39.70,1:13:44.10,ch,,0,0,0,,现在,我们用拿检测到的速度跟最小,最大飞划速度做比较\N{\ren}so now,we were doing a fling check against those mini,max velocity values
Dialogue: 0,1:13:44.10,1:13:47.90,ch,,0,0,0,,通过速度跟踪器我们可以轻松获取检测到的速度值\N{\ren}but velocityTracker gives us that information
Dialogue: 0,1:13:47.90,1:13:50.50,ch,,0,0,0,,注意,这里你看到的弹起跟取消事件处理是分开的\N{\ren}notice this is the case where up and cancel are different
Dialogue: 0,1:13:50.60,1:13:52.57,ch,,0,0,0,,因为我不想\N{\ren}cause i don't wanna also start a fling
Dialogue: 0,1:13:52.62,1:13:55.82,ch,,0,0,0,,当事件被取消时,还去触发一个飞划\N{\ren}if the action event was canceled
Dialogue: 0,1:13:55.82,1:13:58.72,ch,,0,0,0,,飞划只能在手指真的离开屏幕时发生\N{\ren}only if it truly was lifted the finger,ok
Dialogue: 0,1:13:59.97,1:14:01.51,ch,,0,0,0,,对拖拽的处理也是类同的\N{\ren}and the same thing for dragging
Dialogue: 0,1:14:01.51,1:14:04.41,ch,,0,0,0,,首先,我们要对拖拽进行slop检查\N{\ren}we have to do the those same slop checks on dragging but then
Dialogue: 0,1:14:04.45,1:14:06.05,ch,,0,0,0,,一旦拖拽发生\N{\ren}once the dragging occurs
Dialogue: 0,1:14:06.05,1:14:09.85,ch,,0,0,0,,我们就要自己算出拖拽的偏移量\N{\ren}we have to do the calculation of the deltas myself
Dialogue: 0,1:14:09.85,1:14:12.75,ch,,0,0,0,,然后把这些偏移量送到scrollBy方法中\N{\ren}and then place those inside the references of scrollBy
Dialogue: 0,1:14:12.75,1:14:15.65,ch,,0,0,0,,因此,过程都是一样的\N{\ren}ok,so it's the same basic (?) fact
Dialogue: 0,1:14:15.65,1:14:18.54,ch,,0,0,0,,自己来做计算跟使用侦听器来做的不同之处在于\N{\ren}but the difference between using a detector and doing it ourselves
Dialogue: 0,1:14:18.54,1:14:20.48,ch,,0,0,0,,自己做的话,我们要跟踪所有需要的状态值\N{\ren}is we have to track all these state values
Dialogue: 0,1:14:20.51,1:14:23.65,ch,,0,0,0,,然后根据这些值计算出各种手势动作\N{\ren}and then we have to do all the mathematic ourselves to pass into these
Dialogue: 0,1:14:23.68,1:14:27.91,ch,,0,0,0,,然后调用scrollBy,scrollTo或者fling,\N让系统进行视图动画和更新\N{\ren}scroll and fling operations to actually begin the drawing and change
Dialogue: 0,1:14:32.25,1:14:34.28,ch,,0,0,0,,那会是个弹起\N{\ren}it'll be an up,yeah
Dialogue: 0,1:14:34.28,1:14:37.48,ch,,0,0,0,,系统能够辨别其中的不同\N{\ren}it would know the differences between that and just leaving the screen otherwise
Dialogue: 0,1:14:37.48,1:14:39.48,ch,,0,0,0,,\N{\ren}ok
Dialogue: 0,1:14:40.31,1:14:43.22,ch,,0,0,0,,我会很快的把这最后一个例子给过了,因为我们时间有限\N{\ren}we go quickly through this last one,cause we're basically out of time
Dialogue: 0,1:14:44.82,1:14:46.02,ch,,0,0,0,,\N{\ren}ok
Dialogue: 0,1:14:46.02,1:14:48.32,ch,,0,0,0,,最后一个要给你看的例子是\N{\ren}so the last one i'm gonna show you
Dialogue: 0,1:14:48.32,1:14:50.62,ch,,0,0,0,,是这个多点触摸的例子\N{\ren}is this multi-touch example
Dialogue: 0,1:14:56.05,1:14:57.08,ch,,0,0,0,,\N{\ren}ok
Dialogue: 0,1:14:57.08,1:14:59.74,ch,,0,0,0,,最后一个例子中用到了一个ImageView\N{\ren}this last one that i've got is an ImageView
Dialogue: 0,1:14:59.74,1:15:02.64,ch,,0,0,0,,如果我将两个手指放下\N{\ren}and if i put two fingers down
Dialogue: 0,1:15:02.64,1:15:04.64,ch,,0,0,0,,我可以旋转这个图片\N{\ren}i can rotate it
Dialogue: 0,1:15:06.34,1:15:09.85,ch,,0,0,0,,如果我将三根手指放下,我可以缩放这个图片\N{\ren}if i put three fingers down,i can zoom it
Dialogue: 0,1:15:12.25,1:15:15.00,ch,,0,0,0,,例子的意图很明了\N{\ren}ok,it's a fairly simple example
Dialogue: 0,1:15:24.65,1:15:27.88,ch,,0,0,0,,这些功能是在一个自定义视图中实现的\N{\ren}ok,so that implementation is done inside of a custom view
Dialogue: 0,1:15:27.91,1:15:29.91,ch,,0,0,0,,这个自定义的视图是个ImageView的子类\N{\ren}that just a subclass of an ImageView
Dialogue: 0,1:15:29.94,1:15:33.60,ch,,0,0,0,,此例中我依靠的是\N{\ren}so in this case,what i'm relying on is
Dialogue: 0,1:15:33.65,1:15:36.80,ch,,0,0,0,,ImageView能帮我做到对图片进行缩放\N{\ren}the fact ImageView can do all the image scaling for me
Dialogue: 0,1:15:36.80,1:15:39.40,ch,,0,0,0,,ImageView有一个缩放模式,叫做ScaleType.MATRIX\N{\ren}ImageView has a scaling mode called matrix
Dialogue: 0,1:15:39.40,1:15:42.11,ch,,0,0,0,,所以我可以将任何旋转啊,缩放啊\N{\ren}and i can apply any rotations,zoom scale
Dialogue: 0,1:15:42.14,1:15:43.45,ch,,0,0,0,,等等对于一张图片所要做的操作应用到矩阵里\N{\ren}whatever i'd like to an image
Dialogue: 0,1:15:43.45,1:15:46.95,ch,,0,0,0,,ImageView做的仅仅是把这些动作的数学计算交给矩阵,\N然后告诉矩阵去计算\N{\ren}ImageView just by applying that math to a matrix and then telling it use this
Dialogue: 0,1:15:46.95,1:15:48.95,ch,,0,0,0,,之后ImageView就会据此将图片进行缩放\N{\ren}and it will scale the Image for me
Dialogue: 0,1:15:48.95,1:15:52.15,ch,,0,0,0,,那么,我所用到的就是这些,\N并且使其跟触摸事件进行了结合\N{\ren}so i'm using that behavior and then adding in the touch pieces
Dialogue: 0,1:15:52.20,1:15:54.22,ch,,0,0,0,,当我们构造视图的时候\N{\ren}so again,when we construct the view
Dialogue: 0,1:15:54.22,1:15:57.72,ch,,0,0,0,,同样的,我初始化了一个手势缩放侦听器\N{\ren}i'm gonna have one of those scale gesture detectors for the pitch zoom stuff
Dialogue: 0,1:15:57.77,1:15:59.97,ch,,0,0,0,,由于没有旋转侦听器,因此关于旋转的监测我就自己做了\N{\ren}and i'm gonna do the other one's myself
Dialogue: 0,1:15:59.97,1:16:04.07,ch,,0,0,0,,我还创建了一个Matrix,用于进行计算\N{\ren}then i..i'm gonna create this matrix that i apply all the mathematic to
Dialogue: 0,1:16:05.31,1:16:07.34,ch,,0,0,0,,这里我们用到了onSizeChanged()\N{\ren}so here we using onSizeChanged
Dialogue: 0,1:16:07.42,1:16:09.25,ch,,0,0,0,,onSizeChange被调用的时机是\N{\ren}onSizeChange() is called
Dialogue: 0,1:16:09.34,1:16:13.17,ch,,0,0,0,,当视图被布局好,测量好时\N{\ren}once the view has been laid out and measured and we know what size it gonna be
Dialogue: 0,1:16:13.22,1:16:15.97,ch,,0,0,0,,这有点像紧跟在onMeasure后调用的\N{\ren}so it's kind of like one step after onMeasure()
Dialogue: 0,1:16:15.97,1:16:18.57,ch,,0,0,0,,在这个时机,我就能确定\N{\ren}but at this point,i can determine
Dialogue: 0,1:16:18.62,1:16:20.57,ch,,0,0,0,,矩阵的中心点了\N{\ren}where to place my image so that was centered
Dialogue: 0,1:16:20.60,1:16:22.85,ch,,0,0,0,,默认情况下,矩阵缩放的变换中心点是在左上角的\N{\ren}by default,matrix scaling puts in the top,left
Dialogue: 0,1:16:22.85,1:16:24.85,ch,,0,0,0,,而我想让其从图片的中心点开始\N{\ren}and i wanna started with the center
Dialogue: 0,1:16:24.88,1:16:27.37,ch,,0,0,0,,因此我们做了一点计算算出了矩阵的变换中心位置\N{\ren}so we do a little bit math to figure out where center is
Dialogue: 0,1:16:27.37,1:16:29.37,ch,,0,0,0,,然后初次对矩阵进行了变换\N{\ren}and translate our matrix the first time
Dialogue: 0,1:16:29.37,1:16:33.77,ch,,0,0,0,,我们同时也把视图的中心点保存到了PivotXX变量中,\N因为这将用于旋转过程中\N{\ren}we also set pivot that point which we will use in the rotation
Dialogue: 0,1:16:34.51,1:16:37.40,ch,,0,0,0,,然后,我们来看这个缩放手势侦听器的回调\N{\ren}then the scale gesture detector has a callback
Dialogue: 0,1:16:37.40,1:16:39.40,ch,,0,0,0,,跟其他侦听器差不多\N{\ren}just like the other one does
Dialogue: 0,1:16:39.40,1:16:41.40,ch,,0,0,0,,这玩意儿刚被android studio折叠了\N{\ren}which is currently folded
Dialogue: 0,1:16:41.45,1:16:42.00,ch,,0,0,0,,展开它\N{\ren}there we go
Dialogue: 0,1:16:42.42,1:16:44.25,ch,,0,0,0,,来看onScale这个方法\N{\ren}in a method called onScale()
Dialogue: 0,1:16:44.28,1:16:46.14,ch,,0,0,0,,使用这个侦听器的好处在于\N{\ren}so onScale(),the nice thing about the detector
Dialogue: 0,1:16:46.17,1:16:48.65,ch,,0,0,0,,它会告诉我\N{\ren}is that does the math of telling me
Dialogue: 0,1:16:48.68,1:16:50.82,ch,,0,0,0,,我手指间的距离...\N{\ren}this distance between
Dialogue: 0,1:16:50.85,1:16:53.51,ch,,0,0,0,,会告诉我,我的两根手指是越来越远还是越来越近\N{\ren}are my fingers moving farther apart or coming closer together
Dialogue: 0,1:16:53.57,1:16:55.22,ch,,0,0,0,,这是通过缩放因子来告诉我的\N{\ren}it does that with scale factor
Dialogue: 0,1:16:55.22,1:16:58.37,ch,,0,0,0,,当我这样缩放的时候,缩放因子就会大于1,可能是1.1或1.2\N{\ren}scale factor is essentially just a little bit more than one like
Dialogue: 0,1:16:58.37,1:17:00.97,ch,,0,0,0,,当我这样缩放的时候,缩放因子就会大于1,可能是1.1或1.2\N{\ren}1.1,1.2 as you move this way,
Dialogue: 0,1:17:00.97,1:17:03.57,ch,,0,0,0,,而当我这样缩放的时候,其值就会小于1\N{\ren}and a little bit less than one as you move this way
Dialogue: 0,1:17:03.62,1:17:05.54,ch,,0,0,0,,如果你缩放的速度越快\N{\ren}and if you move faster,it'll be
Dialogue: 0,1:17:05.54,1:17:07.84,ch,,0,0,0,,缩放因子就会更大或者更小\N{\ren}a you know, larger number (on) one side of the other
Dialogue: 0,1:17:07.84,1:17:10.14,ch,,0,0,0,,因此,我们可以把缩放因子拿过来\N{\ren}so we can sort take that scale factor
Dialogue: 0,1:17:10.14,1:17:13.04,ch,,0,0,0,,然后直接传给我的矩阵\N{\ren}and again,i can just pass it straight in my matrix here
Dialogue: 0,1:17:13.05,1:17:14.48,ch,,0,0,0,,这样每当缩放的手势被监测到\N{\ren}to do the image scaling piece
Dialogue: 0,1:17:14.48,1:17:16.78,ch,,0,0,0,,矩阵就会对图片进行扩大或者缩小操作了\N{\ren}whenever the scale gesture has been detected
Dialogue: 0,1:17:16.80,1:17:18.74,ch,,0,0,0,,这就是捏合跟扩大的实现机制了\N{\ren}ok.so that's how the pitch zoom is working
Dialogue: 0,1:17:18.74,1:17:21.04,ch,,0,0,0,,要写的代码也没几行\N{\ren}just those few lines of code
Dialogue: 0,1:17:22.34,1:17:24.28,ch,,0,0,0,,我们一会再看旋转的逻辑,\N{\ren}we will come back to the rotation in a second
Dialogue: 0,1:17:24.28,1:17:26.28,ch,,0,0,0,,现在我们先看onTouchEvent()方法\N{\ren}in the onTouchEvent()
Dialogue: 0,1:17:26.28,1:17:29.78,ch,,0,0,0,,我对屏幕上的触摸点数进行了检查\N{\ren}i'm evaluating how many pointers i have on the screen
Dialogue: 0,1:17:29.82,1:17:31.57,ch,,0,0,0,,当我检测到屏幕上有3个手指时\N{\ren}so if i have three fingers
Dialogue: 0,1:17:31.57,1:17:34.17,ch,,0,0,0,,我就要把事件传递给缩放手势侦听器了\N{\ren}that's when i do i pass them to the scale detector
Dialogue: 0,1:17:34.17,1:17:35.77,ch,,0,0,0,,这样我们就能实现缩放的功能了\N{\ren}and we get the zooming effect
Dialogue: 0,1:17:35.85,1:17:37.14,ch,,0,0,0,,当屏幕上只有两个手指时\N{\ren}if i have two on the screen
Dialogue: 0,1:17:37.14,1:17:39.74,ch,,0,0,0,,我就要调用我自己做的数学处理了\N{\ren}i'm gonna do my manual rotation calculation
Dialogue: 0,1:17:39.74,1:17:41.68,ch,,0,0,0,,除此之外的话\N{\ren}and if it's anything other than that
Dialogue: 0,1:17:41.68,1:17:43.08,ch,,0,0,0,,我不做任何事情\N{\ren}i'm just gonna ignore this event
Dialogue: 0,1:17:43.08,1:17:45.88,ch,,0,0,0,,这就是我返回父类方法而不返回false的原因了\N{\ren}ok,this is why i return super not false
Dialogue: 0,1:17:45.88,1:17:48.48,ch,,0,0,0,,因为我想确保在其他情况下,系统正常运作\N{\ren}i wanna make sure that everything else works just normal
Dialogue: 0,1:17:49.88,1:17:51.05,ch,,0,0,0,,\N{\ren}ok
Dialogue: 0,1:17:51.05,1:17:53.65,ch,,0,0,0,,这儿的旋转事件处理函数就是一大堆数学的东西了\N{\ren}the rotationEvent is really a bunch of math
Dialogue: 0,1:17:53.71,1:17:56.05,ch,,0,0,0,,我们要基于\N{\ren}we figure out based on the
Dialogue: 0,1:17:56.05,1:18:00.15,ch,,0,0,0,,触摸点0跟触摸点1中的触摸事件\N{\ren}the touch events of pointer0 and 1 which are my two fingers
Dialogue: 0,1:18:00.15,1:18:03.35,ch,,0,0,0,,我们随时都要用到这些事件中的x,y坐标\N{\ren}you know basically where the x and y locations that at any given time
Dialogue: 0,1:18:03.45,1:18:05.34,ch,,0,0,0,,然后用正切三角函数\N{\ren}do a little bit tangent math
Dialogue: 0,1:18:05.34,1:18:07.34,ch,,0,0,0,,算一下旋转的角度\N{\ren}to figure out what that angle is
Dialogue: 0,1:18:07.34,1:18:10.24,ch,,0,0,0,,一旦我们知道了这些角度时\N{\ren}and then once we know the angle and degrees
Dialogue: 0,1:18:10.24,1:18:13.14,ch,,0,0,0,,我就能将其作为矩阵的旋转参数发布出去\N{\ren}i can post that as a rotate to my matrix
Dialogue: 0,1:18:13.14,1:18:15.14,ch,,0,0,0,,好了,完事儿了\N{\ren}ok,done
Dialogue: 0,1:18:15.14,1:18:18.34,ch,,0,0,0,,任何时候,我们对矩阵进行更新时\N{\ren}at any time,we update this matrix
Dialogue: 0,1:18:18.34,1:18:20.14,ch,,0,0,0,,我们就要在ImageView重新设置上此矩阵\N{\ren}we just set it back to the ImageView
Dialogue: 0,1:18:20.14,1:18:22.31,ch,,0,0,0,,这样ImageView就知道如何去更新自己的视图内容了\N{\ren}and that tells the ImageView to update redrawn
Dialogue: 0,1:18:22.31,1:18:24.31,ch,,0,0,0,,这样ImageView就知道如何去更新自己的视图内容了\N{\ren}put it in new place.ok
Dialogue: 0,1:18:31.05,1:18:32.14,ch,,0,0,0,,没有人提问么\N{\ren}all right
Dialogue: 0,1:18:32.60,1:18:34.31,ch,,0,0,0,,这些就是我今天要讲的了\N{\ren}so that's all i get for you folks
Dialogue: 0,1:18:34.37,1:18:36.28,ch,,0,0,0,,感谢你跟我一起度过这个下午\N{\ren}thank you for spending your afternoon with me
Dialogue: 0,1:18:36.34,1:18:38.28,ch,,0,0,0,,如果你还有其他问题的话,我可以留下答疑\N{\ren}i'm happy to hang around if there are any other questions
Dialogue: 0,1:18:38.34,1:18:39.51,ch,,0,0,0,,现在,我先说一句,谢谢大家了\N{\ren}but i'll just say thank you now
Dialogue: 0,1:18:39.57,1:18:42.28,ch,,0,0,0,,你也可以在Twitter和Google+上跟我互动\N{\ren}feel free to contact me on Twitter,Google+
Dialogue: 0,1:18:42.34,1:18:44.28,ch,,0,0,0,,谢谢大家\N{\ren}thank you very much
Dialogue: 0,1:18:44.34,1:18:48.25,ch,,0,0,0,,请把掌声听完
Dialogue: 0,1:18:48.28,1:18:56.60,ch,,0,0,0,,微博求粉:Ocean-藏心\N\N翻译不足之处,请留言指正\N\N作者本人有Github链接,还有个人博客,不过需要翻墙\N\N\N\N\N\N\N最后的demo很经典,翻译不好的地方,请对着源码看\N相信你一定能迎刃而解\N\N最后,如果你觉得好,分享给更多的人\N \N \N{\ren}
