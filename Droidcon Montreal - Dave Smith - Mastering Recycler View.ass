[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None
PlayResX: 1920
PlayResY: 1080

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: Droidcon Montreal - Dave Smith - Mastering Recycler View.mp4
Video Zoom Percent: 0.250000
Scroll Position: 557
Active Line: 572

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: en,Monaco,48,&H00FFFFFF,&H00FFFFFF,&H000405FF,&H00101012,-1,0,0,0,100,100,0,0,1,1.5,0,2,15,15,15,1
Style: ch,Heiti SC,70,&H00FFFFFF,&H00FBFBFF,&H00AD9000,&H00000000,0,0,0,0,100,100,0,0,1,1.5,0.45,2,15,15,15,1
Style: Default,Arial,30,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,3,3,2,15,15,15,1
Style: 城之内,Weibei SC,48,&H00FFFFFF,&H00FEFEFF,&H00000000,&H00000000,-1,0,0,0,100,100,0,0,1,1.2,0.45,2,15,15,15,134
Style: 游戏,Hiragino Sans GB,48,&H00FFFFFF,&H00FEFEFF,&H00FF0000,&H00000000,0,0,0,0,100,100,0,0,1,1.05,0.3,2,15,15,18,1
Style: 十代,Songti SC,48,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1.5,0.3,2,15,15,15,1
Style: 海马,Kaiti TC,30,&H00FFFFFF,&H00FEFEFF,&H00060607,&H00000000,0,0,0,0,100,100,0,0,1,1.5,0.3,2,15,15,15,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:04.61,0:00:06.33,ch,,0,0,0,,你好,他好,大家好\N{\ren}hello hello everyone
Dialogue: 0,0:00:06.33,0:00:10.28,ch,,0,0,0,,进来,坐好,我要开始讲了.下午好\N{\ren}come sit stay awhile good afternoon
Dialogue: 0,0:00:10.28,0:00:14.20,ch,,0,0,0,,今天大家过的如何?噢,大家的答案我喜欢听\N{\ren}how's everyone today the that's what I\Nlike to hear
Dialogue: 0,0:00:14.20,0:00:18.81,ch,,0,0,0,,我叫大卫-史密斯,我是NewCircle培训中心的Android老大\N{\ren}I hello everyone my name is Dave Smith I\Nam the Android lead for new circle
Dialogue: 0,0:00:18.81,0:00:19.37,ch,,0,0,0,,我叫大卫-史密斯,我是NewCircle培训中心的Android老大\N{\ren}training
Dialogue: 0,0:00:19.37,0:00:22.61,ch,,0,0,0,,我们对很多技术做开源的培训,Android只是其中一项\N{\ren}we do open Source Training a number of\Ntechnologies and reduce happens to be
Dialogue: 0,0:00:22.61,0:00:23.35,ch,,0,0,0,,我们对很多技术做开源的培训,Android只是其中一项\N{\ren}one of them
Dialogue: 0,0:00:23.35,0:00:26.77,ch,,0,0,0,,不过言归正传,今天我要谈的主题是\N{\ren}I'm gonna be here to you today to talk\Nabout
Dialogue: 0,0:00:26.77,0:00:31.26,ch,,0,0,0,,精通RecyclerView的布局.\n我们的关注点不在于如何具体的\N{\ren}mastering recycler view layouts I we're\Nnot gonna talk more specifically about
Dialogue: 0,0:00:31.26,0:00:33.19,ch,,0,0,0,,具体的使用RecyclerView\N{\ren}how to use recycler view
Dialogue: 0,0:00:33.19,0:00:38.09,ch,,0,0,0,,而在于如何\N{\ren}in the generals a sense today we're going\Nto be talking mostly about building
Dialogue: 0,0:00:38.09,0:00:40.59,ch,,0,0,0,,自定义RecyclerView的布局管理器\N{\ren}custom layout managers with recyclerView
Dialogue: 0,0:00:40.59,0:00:43.61,ch,,0,0,0,,以及我们在自定义布局管理器过程中\n应该注意的事情\N{\ren}and how we can kind of get through that\Nprocess so
Dialogue: 0,0:00:43.61,0:00:46.99,ch,,0,0,0,,先给大家说说我站在这儿的原因\N{\ren}a little bit about why I'm here standing\Nin front of you today
Dialogue: 0,0:00:46.99,0:00:50.01,ch,,0,0,0,,正所谓前人栽树,后人乘凉嘛\N{\ren}call it a bit of (Hannah) a humanitarian\Neffort
Dialogue: 0,0:00:50.01,0:00:54.52,ch,,0,0,0,,我会给你介绍你可能需要到的工具(指API的帮助类)\N{\ren}I'm really here to give you the tools\Nhopefully that you will need
Dialogue: 0,0:00:54.52,0:00:58.48,ch,,0,0,0,,当你尝试使用RecyclerView时,当你为了特定的需求\N{\ren}if you are trying to use recycler view\Nyou're trying to customize it for your
Dialogue: 0,0:00:58.48,0:00:59.79,ch,,0,0,0,,而去自定义RecyclerView时将有所帮助\N{\ren}specific purposes
Dialogue: 0,0:00:59.79,0:01:03.60,ch,,0,0,0,,我会尽力带你把这整个过程走通\N{\ren}and trying to get you through that\Nprocess with out losing
Dialogue: 0,0:01:03.60,0:01:07.32,ch,,0,0,0,,来让你少走弯路\N{\ren}you know essentially losing your mind\NI'm so
Dialogue: 0,0:01:07.32,0:01:11.04,ch,,0,0,0,,在我们深入讲解之前,我想确保大家是不是都在一个级别上\N{\ren}before we dive too deep into the details\NI just wanna make sure that everybody's
Dialogue: 0,0:01:11.04,0:01:12.53,ch,,0,0,0,,在我们深入讲解之前,我想确保大家是不是都在一个级别上\N{\ren}on the same page so
Dialogue: 0,0:01:12.53,0:01:16.18,ch,,0,0,0,,那么大家所看到的这种情况是从哪儿来的呢\N{\ren}where does this all this come from you\Nknow the
Dialogue: 0,0:01:16.18,0:01:20.77,ch,,0,0,0,,众所周知,视图回收的这种主意是一种惯用的技术,\N{\ren}this idea of view recycling is a\Npattern that's used in mobile all over
Dialogue: 0,0:01:20.77,0:01:22.72,ch,,0,0,0,,其被用于所有的移动平台\N{\ren}the place all mobile platforms do this
Dialogue: 0,0:01:22.72,0:01:26.15,ch,,0,0,0,,android恰好是其中一个而已.\N{\ren}android just happens to do it as well\Nit has done this
Dialogue: 0,0:01:26.15,0:01:29.67,ch,,0,0,0,,从android1.0就有了,说具体点,这种机制体现在\N{\ren}since version 1 I  most specifically
Dialogue: 0,0:01:29.67,0:01:33.60,ch,,0,0,0,,LisView这个控件上.想必各位都用过不下百十次吧\N{\ren}in the format ListView most of us have\Nprobably use a number of times
Dialogue: 0,0:01:33.60,0:01:37.45,ch,,0,0,0,,我只是好奇,请举下手.各位都有谁真的尝试着\N{\ren}I am just curious shorthand how many\Nhave you have actually tried to use
Dialogue: 0,0:01:37.45,0:01:38.42,ch,,0,0,0,,去用RecyclerView呢\N{\ren}recycler view
Dialogue: 0,0:01:38.42,0:01:43.02,ch,,0,0,0,,还不错嘛.那么,有谁试着去写自定义的布局管理器呢\N{\ren}before,pretty good.how many have you tried to\Nbuild your own layout manager
Dialogue: 0,0:01:43.02,0:01:46.09,ch,,0,0,0,,貌似人不多咯.不过超过我的预期咯\N{\ren}okay more than I expected good
Dialogue: 0,0:01:46.09,0:01:50.42,ch,,0,0,0,,其实更重要的是,各位的头发都还在.这比啥都好啊.\N{\ren}and mostly you still have your hair\Nthat even better so
Dialogue: 0,0:01:50.42,0:01:55.36,ch,,0,0,0,,这种对视图的回收利用机制使我们\N{\ren}this this idea view recycling is really\Nit allows developers and it allows
Dialogue: 0,0:01:55.36,0:01:56.72,ch,,0,0,0,,的设备能够\N{\ren}devices to
Dialogue: 0,0:01:56.72,0:02:00.99,ch,,0,0,0,,展现非常大的数据集合,可能是成百上千条\N{\ren}present large collections of data\Nmaybe hundreds or even thousands of
Dialogue: 0,0:02:00.99,0:02:01.64,ch,,0,0,0,,的数据项\N{\ren}items
Dialogue: 0,0:02:01.64,0:02:05.13,ch,,0,0,0,,给用户.但又仅仅用有限的几个视图便可完成\N{\ren}to the user but only using a handful of\Nviews
Dialogue: 0,0:02:05.13,0:02:08.56,ch,,0,0,0,,不必创建跟数据项个数一样多的视图来展示数据\N{\ren}not creating as many views as we need to\Ndisplay that data
Dialogue: 0,0:02:08.56,0:02:12.23,ch,,0,0,0,,作为替代,使用一种叫做 回收->绑定 的过程\N{\ren}but instead, using a process called\Nrecycling of rebinding
Dialogue: 0,0:02:12.23,0:02:17.04,ch,,0,0,0,,来将用户需要看到的数据绑定到各个视图之上\N{\ren}of data to individual views as the\Nuser needs to see them
Dialogue: 0,0:02:17.04,0:02:21.34,ch,,0,0,0,,可以这么讲,\N{\ren}so basically like we've got going here\Nwe have this idea that
Dialogue: 0,0:02:21.34,0:02:25.28,ch,,0,0,0,,显示用户数据集的视图的个数\N{\ren}the number reviews necessary to show the\Nuser their collection
Dialogue: 0,0:02:25.28,0:02:28.47,ch,,0,0,0,,只等于我们屏幕上能显示出的视图的个数\N{\ren}is only what we need to be able to show\Non screen
Dialogue: 0,0:02:28.47,0:02:33.34,ch,,0,0,0,,一旦用户开始跟他的数据集交互,不管是上划\N{\ren}and as the user is interacting with this\Ncontent whether there's scrolling up
Dialogue: 0,0:02:33.34,0:02:34.26,ch,,0,0,0,,还是怎么划\N{\ren}around
Dialogue: 0,0:02:34.26,0:02:38.76,ch,,0,0,0,,只要视图被划出屏幕,这个视图就不需要了.但是\N{\ren}as view scroll off-screen they're no\Nlonger necessary but rather than
Dialogue: 0,0:02:38.76,0:02:41.65,ch,,0,0,0,,对于将要到来的新的数据,不采用创建一个新视图的方式\N{\ren}creating new views for the new data\Ncoming in
Dialogue: 0,0:02:41.65,0:02:45.45,ch,,0,0,0,,而是把这个旧的视图重新填充数据\N{\ren}we can simply take the old views\Nrepurpose them with new data
Dialogue: 0,0:02:45.45,0:02:48.65,ch,,0,0,0,,平移其到一个新位置,然后让它划入屏幕即可\N{\ren}shift them to a new location and allow\Nthem to slide back n
Dialogue: 0,0:02:48.65,0:02:52.12,ch,,0,0,0,,因此,用这种办法,才使得我们能够展示成百上千的数据项\N{\ren}so that way we can display hundreds of\Nthousands of items
Dialogue: 0,0:02:52.12,0:02:55.73,ch,,0,0,0,,仅仅使用有限的几个视图.大体上,\N{\ren}with only a handful of views. generally\Nyou're gonna see you
Dialogue: 0,0:02:55.73,0:03:00.96,ch,,0,0,0,,你会发现RecyclerView和ListView需要创建的视图个数\N{\ren}recycler views or list views creating as\Nmany viewers as necessary to display on
Dialogue: 0,0:03:00.96,0:03:03.23,ch,,0,0,0,,会比展示在屏幕上的视图的个数多一两个\N{\ren}screen plus maybe one or two more
Dialogue: 0,0:03:03.23,0:03:07.34,ch,,0,0,0,,这跟采用的算法有关.\N{\ren}depending on how the algorithm works\Nokay
Dialogue: 0,0:03:07.34,0:03:11.70,ch,,0,0,0,,再重申一次,我不会讲太多如何使用RecyclerView\N{\ren}so again I'm not gonna talk too much\Nabout how to use recycler view I think
Dialogue: 0,0:03:11.70,0:03:13.64,ch,,0,0,0,,这方面有很好的文档\N{\ren}there's some good documentation on that\Nbut
Dialogue: 0,0:03:13.64,0:03:17.65,ch,,0,0,0,,RecyclerView的精华在于\N{\ren}the basics have recycler view is that\Nrecycler view is a
Dialogue: 0,0:03:17.65,0:03:21.34,ch,,0,0,0,,RecyclerView是对这种机制的革新,更加灵活易用\N{\ren}more flexible,evolution of this\Npattern
Dialogue: 0,0:03:21.34,0:03:25.93,ch,,0,0,0,,其允许我们来对可复用的集合创建\N{\ren}that allows us to create these\Nrecyclable collections in
Dialogue: 0,0:03:25.93,0:03:30.60,ch,,0,0,0,,各种自定义(布局,动画,装饰)的实现.之前,我们只有ListView\N{\ren}all kinds of custom implementations you\Nknow previously we only had list view
Dialogue: 0,0:03:30.60,0:03:32.39,ch,,0,0,0,,是一个可在垂直方向上滚动的列表\N{\ren}which was a vertical scrolling list
Dialogue: 0,0:03:32.39,0:03:35.81,ch,,0,0,0,,开发者们已经为其做过一些自定制的实现了\N{\ren}there have been some custom\Nimplementations done by other developers
Dialogue: 0,0:03:35.81,0:03:38.95,ch,,0,0,0,,比方说水平滚动的列表.等等其他定制的效果\N{\ren} ways to do this maybe horizontally\Nor another custom ways
Dialogue: 0,0:03:38.95,0:03:43.48,ch,,0,0,0,,RecyclerView为之前大家所需要的实现提供了一个框架\N{\ren}recyclerView bring that all together\Ninto a framework so because it that
Dialogue: 0,0:03:43.48,0:03:45.84,ch,,0,0,0,,因此,要想使用RecyclerView\N{\ren}recycler you cannot be used
Dialogue: 0,0:03:45.84,0:03:49.87,ch,,0,0,0,,你必须要提供一个布局管理器不可.这俩必须成对使用,不然\N{\ren}without a layout manager.the two always\Nhave to pair together in fact if you try
Dialogue: 0,0:03:49.87,0:03:52.65,ch,,0,0,0,,当你尝试实例化一个没有定义布局管理器的RecyclerView时\N{\ren}to instantiate a RecyclerView without\Na layup manager
Dialogue: 0,0:03:52.65,0:03:56.60,ch,,0,0,0,,你会得到一个没有用的异常,会让你的程序崩溃\N{\ren}you'll get a very unhelpful exception about\Nthat will crash your application
Dialogue: 0,0:03:56.60,0:04:01.24,ch,,0,0,0,,所以,用RecyclerView之前,咱一定要有布局管理器\N{\ren}OK.so you always need to set a layout\Nmanager before you try to use a recycler
Dialogue: 0,0:04:01.24,0:04:02.06,ch,,0,0,0,,\N{\ren}view
Dialogue: 0,0:04:02.06,0:04:06.13,ch,,0,0,0,,为了使你能登堂入室,或者说为了便于应对最常用的场合\N{\ren}and to sort of get you started or cover\Nmost use cases
Dialogue: 0,0:04:06.13,0:04:09.51,ch,,0,0,0,,框架在这方面干的很不错.为我们提供了\N{\ren}the framework has done a pretty good job\Nof providing
Dialogue: 0,0:04:09.51,0:04:14.17,ch,,0,0,0,,几个自带的布局管理器.在大多数情况下,你甚至有可能\N{\ren}a handful of its own layout managers that\Nin a lot cases you might even be able
Dialogue: 0,0:04:14.17,0:04:15.54,ch,,0,0,0,,都用得上\N{\ren}to use wholesale
Dialogue: 0,0:04:15.54,0:04:19.51,ch,,0,0,0,,如果你从Lpreview或者从RecyclerView最初版本发布以来\N{\ren}and if you haven't looked at recycler\Nview since the L reviewer or maybe since
Dialogue: 0,0:04:19.51,0:04:20.93,ch,,0,0,0,,你一直都没有再看RecyclerView的话\N{\ren}some of the initial releases
Dialogue: 0,0:04:20.93,0:04:23.97,ch,,0,0,0,,你可能会漏掉几个他们目前已经加进去的布局管理器\N{\ren}you may have missed some of the layout\Nmanagers they've added
Dialogue: 0,0:04:23.97,0:04:25.87,ch,,0,0,0,,因为,预览版的时候,我们手里的RecyclerView\N{\ren}because during the preview really all we
Dialogue: 0,0:04:25.87,0:04:29.27,ch,,0,0,0,,所提供的基本功能就跟ListView差不多\N{\ren}had was some basic functionality that\Nwas very similar to ListView and they
Dialogue: 0,0:04:29.27,0:04:31.68,ch,,0,0,0,,但是到正式发布的时候,很多新功能都已经被加进去了.\N{\ren}add it quite a bit by the time they got\Nto release
Dialogue: 0,0:04:31.68,0:04:35.41,ch,,0,0,0,,接下来,我来快速梳理一遍,framework提供了些什么\N{\ren}let's just quickly go through what the\Nframework gives us the first
Dialogue: 0,0:04:35.41,0:04:39.13,ch,,0,0,0,,首先,是大家都很熟悉的\N{\ren}option which will.familiar to\Nprobably most of you
Dialogue: 0,0:04:39.13,0:04:42.72,ch,,0,0,0,,LinearLayoutManager.\N{\ren}is the linear layout manager so the\NLinearLayout manager
Dialogue: 0,0:04:42.72,0:04:46.40,ch,,0,0,0,,你基本可以把它当成ListView的替代品\N{\ren}is essentially the ListView replacement\Nif you well
Dialogue: 0,0:04:46.40,0:04:49.66,ch,,0,0,0,,尽管它还有些其他的特性,但是基本上它是\N{\ren}I it's got some additional features in\Nit but is it is a
Dialogue: 0,0:04:49.66,0:04:53.72,ch,,0,0,0,,一个列表项均分的单一列表.LinearLayoutManager有个\N{\ren}uniform single list of items.one of the\Nneat features
Dialogue: 0,0:04:53.72,0:04:57.18,ch,,0,0,0,,ListView没有的特性.那就是对方向参数的可选性\N{\ren}of linear layout manager that we\Ndidn't have in listview is the optional
Dialogue: 0,0:04:57.18,0:04:58.50,ch,,0,0,0,,那就是对方向参数的可选性\N{\ren}orientation setup
Dialogue: 0,0:04:58.50,0:05:02.75,ch,,0,0,0,,因此LinearLayoutManager允许RecyclerView创建\N{\ren}so LinearLayout Manager allows recycler\Nview to create a list of items that
Dialogue: 0,0:05:02.75,0:05:03.63,ch,,0,0,0,,可滚动的列表\N{\ren}scrolls
Dialogue: 0,0:05:03.63,0:05:08.47,ch,,0,0,0,,不管是垂直的还是水平的.很明显,我们之前\N{\ren}either vertically or horizontally which\Nis a new feature that we obviously
Dialogue: 0,0:05:08.47,0:05:09.76,ch,,0,0,0,,是没有这个特性的.\N{\ren}didn't have before
Dialogue: 0,0:05:09.76,0:05:12.77,ch,,0,0,0,,你只需要在LinearLayoutManager实例化的时候\N{\ren}and this is controlled during the\Ninstantiation of the LinearLayout
Dialogue: 0,0:05:12.77,0:05:17.08,ch,,0,0,0,,指定水平或者垂直的方向参数即可\N{\ren}manager just by giving it that vertical\Nor horizontal orientation qualifier
Dialogue: 0,0:05:17.08,0:05:17.49,ch,,0,0,0,,\N{\ren}there
Dialogue: 0,0:05:17.49,0:05:21.69,ch,,0,0,0,,这里最后一个boolean型的参数,代表是你是否要逆序进行\N{\ren}OK. the boolean parameter that at the end\Nthat allows you to also reverse the
Dialogue: 0,0:05:21.69,0:05:22.28,ch,,0,0,0,,布局\N{\ren}layout
Dialogue: 0,0:05:22.28,0:05:25.60,ch,,0,0,0,,通常,大家都是把它设为false\N{\ren}so the traditional by setting it to\Nfalse would
Dialogue: 0,0:05:25.60,0:05:29.00,ch,,0,0,0,,那么列表项显示的顺序跟适配器中getView()顺序是一致的\N{\ren}order the items as they viewed in the\Nadapter so
Dialogue: 0,0:05:29.00,0:05:32.15,ch,,0,0,0,,从位置0开始,由高到低依次依序显示列表项\N{\ren}adapter item position $0 upfront down to\Nthe end
Dialogue: 0,0:05:32.15,0:05:35.72,ch,,0,0,0,,如果你把这个参数设成true,那么就成逆序了.\N{\ren}if you set this parameter to true it\Nwill reverse that and have the
Dialogue: 0,0:05:35.72,0:05:39.13,ch,,0,0,0,,列表中最后一项会先显示.因此,从前ListView的这种特性\N{\ren}end of the adapter show first in the\Nlist okay so they have that feature in
Dialogue: 0,0:05:39.13,0:05:39.80,ch,,0,0,0,,在LinearLayoutManager中也存在\N{\ren}there as well
Dialogue: 0,0:05:43.08,0:05:46.22,ch,,0,0,0,,接下来,framework提供给我们的是GridLayoutManager\N{\ren}the next one that we have appears the\Ngrid layout manager
Dialogue: 0,0:05:46.22,0:05:51.03,ch,,0,0,0,,这个布局管理器在L预览版中是没有的,但是其功能性\N{\ren}so this is...this one was not in the\Npreview but functionality have it is
Dialogue: 0,0:05:51.03,0:05:55.50,ch,,0,0,0,,我们却不陌生.因为我们都知道GridView\N{\ren}still pretty intuitive to most of us because\Nwe've either seen or used gridview
Dialogue: 0,0:05:55.50,0:05:56.16,ch,,0,0,0,,\N{\ren}before
Dialogue: 0,0:05:56.16,0:05:59.21,ch,,0,0,0,,当然,这里的布局管理器更加灵活一点.它的特点是,\N{\ren}at a little bit more flexible than that\Nbut the idea here is that
Dialogue: 0,0:05:59.21,0:06:02.47,ch,,0,0,0,,大体上,我们仍有着均分的网格布局列表项集合\N{\ren}we're still having this uniform\Ncollection of items
Dialogue: 0,0:06:02.47,0:06:06.56,ch,,0,0,0,,但是这些列表项,现在可以一个挨着一个填满一行后,\N{\ren}but these items can now be stacked up\Nuh you know, either side by side on
Dialogue: 0,0:06:06.56,0:06:07.53,ch,,0,0,0,,再竖着往上填(- -!)\N{\ren}top of each other
Dialogue: 0,0:06:07.53,0:06:11.91,ch,,0,0,0,,像LinearLayoutManager一样,GridLayoutManager也提供\N{\ren}uh, just like with linear layout manager\Ngrid layout manager does support
Dialogue: 0,0:06:11.91,0:06:15.68,ch,,0,0,0,,方向参数,因此我们可以像之前一样,做个垂直的可滚动列表\N{\ren}orientation changes so we can do a\Nvertical scrolling list
Dialogue: 0,0:06:15.68,0:06:20.97,ch,,0,0,0,,也可以做一个水平的可滚动网格列表\N{\ren}like the traditional grid view or we can\Nflip that into a horizontally scrolling grid
Dialogue: 0,0:06:20.97,0:06:25.05,ch,,0,0,0,,这里位于参数列表中的数字代表着\N{\ren}instead now the the number that you see\Nin this
Dialogue: 0,0:06:25.05,0:06:28.91,ch,,0,0,0,,GridLayoutManager所提供的一种控制参数\N{\ren}declaration here is that the the grid\Nlayout manager supports
Dialogue: 0,0:06:28.91,0:06:33.22,ch,,0,0,0,,这个参数决定了每行item所能占用的最大span数\N{\ren}controlling how many what they call\Nspans are associated with that
Dialogue: 0,0:06:33.22,0:06:34.26,ch,,0,0,0,,每个数据项都有着相关的span数\N{\ren}particular item
Dialogue: 0,0:06:34.26,0:06:37.88,ch,,0,0,0,,这里把这个参数称作span而不是行或列的原因在于\N{\ren}now the reason they call them spans\Ninstead of rows or columns is because
Dialogue: 0,0:06:37.88,0:06:39.00,ch,,0,0,0,,GridLayoutManager有着两种方向\N{\ren}the fact that you can do it
Dialogue: 0,0:06:39.00,0:06:42.41,ch,,0,0,0,,简单的讲,span定义了\N{\ren}in either direction so a span just simply\Ndefines
Dialogue: 0,0:06:42.41,0:06:46.61,ch,,0,0,0,,你能够在某一维度上堆栈起来的item数,纵表即为列数\N{\ren}how many items you can stack up so in a\Nvertical grid the spans are the columns
Dialogue: 0,0:06:46.61,0:06:49.03,ch,,0,0,0,,横表即为行数\N{\ren}in a horizontal grid the span to be the\NRose
Dialogue: 0,0:06:49.03,0:06:53.05,ch,,0,0,0,,除此之外,span还\N{\ren}OK but they're still defined in such a\Nway that they are uniform so
Dialogue: 0,0:06:53.05,0:06:56.47,ch,,0,0,0,,仍旧体现其均匀的特性.举例来讲,在这我定义了2个span\N{\ren}for instance in this case I have two\Nspans defined so
Dialogue: 0,0:06:56.47,0:07:01.03,ch,,0,0,0,,这里每行就被均分成了两部分来给列表项占用.仅用span\N{\ren}they will evenly be spaced on both sides\Nthere's not really a mechanism to define
Dialogue: 0,0:07:01.03,0:07:04.24,ch,,0,0,0,,是无法将每行不均等分的(左边占1/3 右边占2/3).\N{\ren}you know sort of a 1/3 2/3 with the\Nspans
Dialogue: 0,0:07:04.24,0:07:09.30,ch,,0,0,0,,你一定是在这个控制水准啦,懂么?但是别怕,有哥在呢.\N{\ren}you're necessarily at this level ok\Nthey did at a
Dialogue: 0,0:07:09.30,0:07:13.08,ch,,0,0,0,,系统的确提供了一个相当有意思的特性,\N来让你对均等性进行改变\N{\ren}fairly interesting feature though that\Nallows you to change the uniformity
Dialogue: 0,0:07:13.08,0:07:16.86,ch,,0,0,0,,这显然比传参数复杂一点,我们要用SpanSizeLook\N{\ren}in in some basic ways using something\Ncalled a span size lookup
Dialogue: 0,0:07:16.86,0:07:21.33,ch,,0,0,0,,我这里的例子中,GridLayoutManager的span依然\N{\ren}so in the example that I have here the\Ngrid layout manager still has
Dialogue: 0,0:07:21.33,0:07:25.74,ch,,0,0,0,,被设置为2,但是我们自定义了SpanSizeLookUp的实现\N{\ren}two spans defined but using this custom\Nimplementation of
Dialogue: 0,0:07:25.74,0:07:29.49,ch,,0,0,0,,我们在运行时为\N{\ren}a span size lookup we can define at\Nruntime for
Dialogue: 0,0:07:29.49,0:07:32.86,ch,,0,0,0,,每个位置来设置其占用span的个数\N{\ren}each individual position how many spans
Dialogue: 0,0:07:32.86,0:07:36.95,ch,,0,0,0,,我这的方法挺简单\N{\ren}should each item take up and this is a\Nvery simple algorithm basically says
Dialogue: 0,0:07:36.95,0:07:39.14,ch,,0,0,0,,每个3的倍数的列表项都会占用2个span\N{\ren}every third item should take two spans
Dialogue: 0,0:07:39.14,0:07:42.30,ch,,0,0,0,,而其他的就还按默认的,只占用一个\N{\ren}and all the other should take just the\Ndefault 1
Dialogue: 0,0:07:42.30,0:07:45.39,ch,,0,0,0,,这里,大家所看到的,就是这种实现的效果\N{\ren}and this gives us the implementation\Nthat we see up here
Dialogue: 0,0:07:45.39,0:07:48.58,ch,,0,0,0,,这样网格就被整行分割了\N{\ren}where every other row is essentially\Nlaid out
Dialogue: 0,0:07:48.58,0:07:51.93,ch,,0,0,0,,这样网格就被整行分割了\N{\ren}all the way across but the grids\Ninterspersed in between
Dialogue: 0,0:07:51.93,0:07:55.27,ch,,0,0,0,,因此你可以在GridLayoutManager里创建一些变形的元素\N{\ren}so you can create some shifting elements\Nhere
Dialogue: 0,0:07:55.27,0:07:58.88,ch,,0,0,0,,但是这必须被定义在可用的span数之上\N{\ren}but this is always defined in terms of\Nthe number of spans available
Dialogue: 0,0:07:58.88,0:08:03.70,ch,,0,0,0,,因此,这不像明显的像素宽度或其他测量参数\N{\ren}so this isn't like a an explicit pixel\Nwidth or anything like that you define
Dialogue: 0,0:08:03.70,0:08:05.80,ch,,0,0,0,,你必须提前定义好在你的布局中要用到的span数\N{\ren}ahead a time how many spans are\Navailable
Dialogue: 0,0:08:05.80,0:08:09.89,ch,,0,0,0,,然后,你可以用LookUp来决定\N{\ren}in this layout and then you can use the\Nlookup to basically tell it how many of
Dialogue: 0,0:08:09.89,0:08:11.93,ch,,0,0,0,,(在桌子上占用的单元数)\N{\ren}those you think of them as the cells in a\Ntable
Dialogue: 0,0:08:11.93,0:08:16.44,ch,,0,0,0,,这个特定的item所应该占用的单元数\N{\ren}this specific item should take up at I
Dialogue: 0,0:08:16.44,0:08:20.01,ch,,0,0,0,,关于GridLayoutManager还有件事你不能忘\N{\ren}it one of the important things to\Nrealize with grid layout though is that
Dialogue: 0,0:08:20.01,0:08:20.49,ch,,0,0,0,,\N{\ren}the
Dialogue: 0,0:08:20.49,0:08:23.52,ch,,0,0,0,,不论其使用何种的方向.其表项的高度\N{\ren}whatever orientation it's in,the item\Nheight:
Dialogue: 0,0:08:23.52,0:08:27.93,ch,,0,0,0,,亦或其表项的宽度(水平方向),在每个表项\N{\ren}or for towards on all the item with\Nstill needs to be uniform for
Dialogue: 0,0:08:27.93,0:08:31.24,ch,,0,0,0,,所占的块中必须是均等的.在我们这个例子中,\N{\ren}each element block so for instance in\Nthis example
Dialogue: 0,0:08:31.24,0:08:34.70,ch,,0,0,0,,每一行中的item的高度必须是一样的\N{\ren}all the items in the same row have to be\Nthe same height
Dialogue: 0,0:08:34.70,0:08:37.77,ch,,0,0,0,,行高取决于\N{\ren}and the the row height itself will
Dialogue: 0,0:08:37.77,0:08:40.82,ch,,0,0,0,,最高的列表项的高度\N{\ren}essentially adjust to whatever the\Ntallest item is
Dialogue: 0,0:08:40.82,0:08:44.29,ch,,0,0,0,,因此,如果我在一行中间的元素比两边的元素高\N{\ren}so if I had one item in the middle of the\Nother two that was much taller
Dialogue: 0,0:08:44.29,0:08:47.31,ch,,0,0,0,,那么两边的元素下面就会有留白\N{\ren}there would be a gap underneath the two\Nitems on either side
Dialogue: 0,0:08:47.31,0:08:50.97,ch,,0,0,0,,位于其下面的元素并不会滑上去填充空隙\N{\ren}they don't slide up to sort of fill in\Nthe gaps or anything like that
Dialogue: 0,0:08:50.97,0:08:52.54,ch,,0,0,0,,而你恰好正是为了这种目的\N{\ren}for that
Dialogue: 0,0:08:52.54,0:08:55.30,ch,,0,0,0,,别怕,我们还有StaggeredGridLayoutManager.\N{\ren}we have the staggered grid layout\Nmanager
Dialogue: 0,0:08:55.30,0:08:59.58,ch,,0,0,0,,因此,SGLM正是构建在这种模式之上的\N{\ren}so the staggered grid layout manager\Nbuild on that pattern
Dialogue: 0,0:08:59.58,0:09:04.36,ch,,0,0,0,,其被构造的方法和布局的操作都跟GLM相似\N{\ren}and operates and is constructed in a\Nvery similar way to grid layout manager
Dialogue: 0,0:09:04.36,0:09:07.67,ch,,0,0,0,,不同的是,我们有机会去为表项视图定义\N{\ren}but in this case we have the opportunity\Nto define
Dialogue: 0,0:09:07.67,0:09:12.73,ch,,0,0,0,,不同的大小.然后SGLM会把将其布局出来\N{\ren}different size item views and the\Nstaggered grid layout manager will simply lay them out
Dialogue: 0,0:09:12.73,0:09:17.12,ch,,0,0,0,,并尽其所能的将留白用item填充起来.\N{\ren}as best it knows how underneath each\Nother filling in those individual gaps
Dialogue: 0,0:09:17.12,0:09:20.13,ch,,0,0,0,,对我们的实现来讲\N{\ren}OK the from an implementation perspective
Dialogue: 0,0:09:20.13,0:09:24.87,ch,,0,0,0,,创建这个布局管理器跟创建前面两个一样\N{\ren}creating one is again no different then\Nworking with the other two and it
Dialogue: 0,0:09:24.87,0:09:28.06,ch,,0,0,0,,这种管理器也同样支持水平和垂直\N{\ren}also supports horizontal and vertical\Norientation
Dialogue: 0,0:09:28.06,0:09:31.13,ch,,0,0,0,,前方依旧高能\N{\ren}now
Dialogue: 0,0:09:31.13,0:09:35.45,ch,,0,0,0,,有件事要注意,我刚刚所展示给你们的每一种布局管理器\N{\ren}one of the things to notice\Nabout each of these that I've shown you
Dialogue: 0,0:09:35.45,0:09:40.55,ch,,0,0,0,,它们都支持不同方向的滚动\N{\ren}so far is that well they support\Ndifferent orientations of scrolling
Dialogue: 0,0:09:40.55,0:09:44.85,ch,,0,0,0,,但是,无论何时这些实现只能支持一条坐标轴上的滚动\N{\ren}both these implementations only supports\Ngrowing in a single axis
Dialogue: 0,0:09:44.85,0:09:48.48,ch,,0,0,0,,我想要做的是\N{\ren}at any given time what what I need to do
Dialogue: 0,0:09:48.48,0:09:53.75,ch,,0,0,0,,创造一种RecyclerView,就说它是个简单的网格布局吧\N{\ren}if I wanted to create a recycler view\Nimplementation or say like a simple grid
Dialogue: 0,0:09:53.75,0:09:57.16,ch,,0,0,0,,我想让它能在两个方向上都能滚动\N{\ren}that I want to be able to actually\Nscroll in two directions
Dialogue: 0,0:09:57.16,0:10:02.00,ch,,0,0,0,,我能这么做么?答案是,你可以的.\N不过在framework里,你找不到现成的\N{\ren}can I do that? well the answer is yes \Nthe framework is not gonna give you anything to do that
Dialogue: 0,0:10:02.00,0:10:05.69,ch,,0,0,0,,这就要靠我们自己动手来创建布局管理器了\N{\ren}in that case we have to look may be perhaps building our own
Dialogue: 0,0:10:05.69,0:10:09.19,ch,,0,0,0,,那么我会向你展示我所干过的活\N{\ren}so what I've done and I'll show you the
Dialogue: 0,0:10:09.19,0:10:12.38,ch,,0,0,0,,在我们会谈结束后,你可以自己去分析源码\N{\ren}where you can look at the example at the end of the talk here
Dialogue: 0,0:10:12.38,0:10:16.22,ch,,0,0,0,,可以说我所做的研究就是现在所谈的问题的核心\N{\ren}is a sort of key study for what what\Nwe're talking about here
Dialogue: 0,0:10:16.22,0:10:19.31,ch,,0,0,0,,首先,经过我全面的分析之后,我决定去创建\N{\ren}I went through and decided I'm gonna\Ncreate a
Dialogue: 0,0:10:19.31,0:10:23.20,ch,,0,0,0,,一个二维的可滚动的布局,这是个简单均分网格布局\N{\ren}two-dimensional scrolling layout this\Njust a simple uniform grid
Dialogue: 0,0:10:23.20,0:10:26.93,ch,,0,0,0,,网格里的元素会一个挨着一个的布局出来,其中元素的位置\N{\ren}OK so the grid is going to be laid out\Nthe positions would basically be the way
Dialogue: 0,0:10:26.93,0:10:28.19,ch,,0,0,0,,就是你在屏幕上所看到的\N{\ren}you see them up there whether
Dialogue: 0,0:10:28.19,0:10:31.79,ch,,0,0,0,,元素的顺序是从左到右,网格的宽度是固定的\N{\ren}they order themselves left to right the\Ngrid with is fixed
Dialogue: 0,0:10:31.79,0:10:35.06,ch,,0,0,0,,因此元素按列数被包裹起来,按行从上往下排\N{\ren}so the number of columns they just wrap around\Nto the next and I'll just line
Dialogue: 0,0:10:35.06,0:10:35.76,ch,,0,0,0,,因此元素按列数被包裹起来,按行从上往下排\N{\ren}themselves up
Dialogue: 0,0:10:35.76,0:10:40.04,ch,,0,0,0,,这就好像我正在看一个电视预告或者是体育赛事比分\N{\ren}like if I was looking at maybe a TV\Nschedule or sports scores in a grid
Dialogue: 0,0:10:40.04,0:10:40.97,ch,,0,0,0,,或者其他诸如此类的东西\N{\ren}something like that
Dialogue: 0,0:10:40.97,0:10:44.88,ch,,0,0,0,,用户可以随意的上滑下滑左滑右滑斜着划\N{\ren}then the user could simply pan and\Nscroll around
Dialogue: 0,0:10:44.88,0:10:48.88,ch,,0,0,0,,按任意方向滑动去查看网格列表中的内容\N{\ren}this content visually in whatever\Norientation they wanted
Dialogue: 0,0:10:48.88,0:10:52.31,ch,,0,0,0,,我最先给自己提出的问题是\N{\ren}okay and the question essentially I pose\Nto myself was
Dialogue: 0,0:10:52.31,0:10:56.91,ch,,0,0,0,,我能用RecyclerView来干这件事儿么?或者换一个说法\N\N{\ren}can I build this with recycler view and\Ncome out saying on the other side
Dialogue: 0,0:10:56.91,0:11:01.39,ch,,0,0,0,,好吧,想不出来别的说法了.等你听我讲完就该明白了\N{\ren}I'll let you decide when I'm done\Nwhether know that actually words okay
Dialogue: 0,0:11:01.39,0:11:06.47,ch,,0,0,0,,在我阐述你所需的,构建这种RecyclerView的方法之前\N{\ren}before I talk about the mechanisms of\Nwhat you need to do to build this
Dialogue: 0,0:11:06.47,0:11:09.67,ch,,0,0,0,,咱们先来谈谈RecyclerView内部的一些机制\N{\ren}let's discuss a little bit about\Nthe internals
Dialogue: 0,0:11:09.67,0:11:12.74,ch,,0,0,0,,来帮你理解\N{\ren}of RecyclerView you so that you can get\Nsome idea of
Dialogue: 0,0:11:12.74,0:11:16.49,ch,,0,0,0,,文档中你可能遇到过的一些方法的流程梳理\N{\ren}how these pieces that you may see in the\Ndocumentation actually fit together
Dialogue: 0,0:11:16.49,0:11:19.93,ch,,0,0,0,,首先我想讲的是\N{\ren}so the first element that i wanna talk\Nabout in the
Dialogue: 0,0:11:19.93,0:11:23.30,ch,,0,0,0,,RecyclerView给我们的一个核心帮助类\N{\ren}the core utility if you will that\Nrecycler view
Dialogue: 0,0:11:23.30,0:11:26.76,ch,,0,0,0,,这个类体现了回收利用的概念\N{\ren}gives you is this instance for this\Nconcept a recycler
Dialogue: 0,0:11:26.76,0:11:31.23,ch,,0,0,0,,在构建自定义布局管理器的时候,这个类干的活挺多的\N{\ren}this is really the workhorse of\Nbuilding a custom layout the recycler
Dialogue: 0,0:11:31.23,0:11:34.32,ch,,0,0,0,,回收器(recycler)是RecyclerView传递给你的\N{\ren}is a utility given to you by a recycler\Nview
Dialogue: 0,0:11:34.32,0:11:37.95,ch,,0,0,0,,它为你干了几乎所有的\N{\ren}that does all of the work necessary\Nfor
Dialogue: 0,0:11:37.95,0:11:42.52,ch,,0,0,0,,像获取视图,缓存视图,等等\N{\ren}obtaining views cacheing views your\Nbasically doing all the recycling
Dialogue: 0,0:11:42.52,0:11:44.20,ch,,0,0,0,,所有跟回收相关的活\N{\ren}functionality that you need
Dialogue: 0,0:11:44.20,0:11:48.48,ch,,0,0,0,,它让你能够快速的获取一个新视图来填充新数据.\N以及快速丢弃\N{\ren}to be able to quickly get new views for\Nnew data and toss away views you don't
Dialogue: 0,0:11:48.48,0:11:49.42,ch,,0,0,0,,你不再需要的视图\N{\ren}need anymore
Dialogue: 0,0:11:49.42,0:11:53.35,ch,,0,0,0,,因此,当你开始构建一个布局管理器时,\N{\ren}OK so when you're building a layout\Nmanager your interaction is almost
Dialogue: 0,0:11:53.35,0:11:54.54,ch,,0,0,0,,你的交互行为跟\N{\ren}exclusively
Dialogue: 0,0:11:54.54,0:11:58.64,ch,,0,0,0,,recycler息息相关.比方说,当你需要一个新的视图时\N{\ren}with the recycler there you know when\Nwhen you need a new view
Dialogue: 0,0:11:58.64,0:12:02.89,ch,,0,0,0,,当用户滑动屏幕到下一个位置时,有新视图进入等等\N{\ren}with the next position the user is\Nscrolling enter a view or something like
Dialogue: 0,0:12:02.89,0:12:05.94,ch,,0,0,0,,新进入的视图就是从recycler中返回的\N{\ren}that you obtain that view from the\Nrecycler
Dialogue: 0,0:12:05.94,0:12:10.18,ch,,0,0,0,,你只要告诉recycler你所需新视图的position\N{\ren}by giving it the position value that you\Nwant so this is the next position I need
Dialogue: 0,0:12:10.18,0:12:14.64,ch,,0,0,0,,那么recycler就会返回一个已经绑定过相关数据的新视图\N{\ren}please give me the view that has all the\Ndata already bound associated with it
Dialogue: 0,0:12:14.64,0:12:18.82,ch,,0,0,0,,类似地,当你的滑动一些视图移出屏幕时,\N{\ren}and similarly when you're done with a\Nview but say it scrolls of screen and
Dialogue: 0,0:12:18.82,0:12:20.00,ch,,0,0,0,,这些视图你已经不再需要了\N{\ren}you don't need it anymore
Dialogue: 0,0:12:20.00,0:12:23.39,ch,,0,0,0,,你应该把这些视图丢给recycler,以便于\N{\ren}you would toss that back to the recycler\Nso that it can
Dialogue: 0,0:12:23.39,0:12:27.64,ch,,0,0,0,,将来使用的时候还能从recycler中获取到,\N并且获取到的是已经绑定好数据的\N{\ren}keep access to that around and rebind it\Nto some other data later and headed back
Dialogue: 0,0:12:27.64,0:12:28.77,ch,,0,0,0,,(同上)\N{\ren}to another point
Dialogue: 0,0:12:28.77,0:12:34.11,ch,,0,0,0,,所有的这些工作都在recycler内部完成.\N{\ren}okay so all that functionality is bound\Ninside the recycler in the recyclers job
Dialogue: 0,0:12:34.11,0:12:38.61,ch,,0,0,0,,recycler的对外的工作是对接adapter.\N而adapter是你所有数据的来源\N{\ren}is to talk to the adapter so the adapter\Nwere all your data comes from where you
Dialogue: 0,0:12:38.61,0:12:42.00,ch,,0,0,0,,你在adapter里根据数据源创建ViewHolder和绑定数据\N{\ren}you create view holders and bind all the\Ndata that
Dialogue: 0,0:12:42.00,0:12:46.30,ch,,0,0,0,,recycler是可以直接从adapter中\N{\ren}is ... there's a direct interaction\Nbetween the recycler in the adapter to
Dialogue: 0,0:12:46.30,0:12:48.00,ch,,0,0,0,,获取所需信息的\N{\ren}get all that information
Dialogue: 0,0:12:48.00,0:12:52.01,ch,,0,0,0,,但是,布局管理器就不同,你该谨记,布局管理器绝不该\N{\ren}the key point to remember here is your\Nlayout manager should never
Dialogue: 0,0:12:52.01,0:12:55.02,ch,,0,0,0,,去引用适配器\N{\ren}ever ever touch the adapter
Dialogue: 0,0:12:55.02,0:12:59.26,ch,,0,0,0,,因为这个工作是recycler干的.\N当你正在创建一个布局管理器时\N{\ren}that is the recyclers job if you have\Nare building a layout manager that
Dialogue: 0,0:12:59.26,0:13:02.57,ch,,0,0,0,,出于某种原因,你非要获取一些状态信息的话或者\N一些其他跟列表项相关的数据时\N{\ren}somehow you was trying to get state\Ninformation or some other data directly
Dialogue: 0,0:13:02.57,0:13:03.88,ch,,0,0,0,,(从适配器中)\N{\ren}from the adapter
Dialogue: 0,0:13:03.88,0:13:07.83,ch,,0,0,0,,你会把事情搞砸.然而,对于状态信息的存取,\N其实用ViewHolder才最合适不过\N{\ren}that pattern is broken instead the view\Nholders
Dialogue: 0,0:13:07.83,0:13:11.30,ch,,0,0,0,,在RecyclerViewAPI里,ViewHolder被强制传递给你\N{\ren}that are basically forced down your\Nthroat by the recycler view API
Dialogue: 0,0:13:11.30,0:13:15.15,ch,,0,0,0,,它才是你存取状态的最佳选择.因为\N{\ren}those are great places to hold that\Nstate because the adapter
Dialogue: 0,0:13:15.15,0:13:18.53,ch,,0,0,0,,不光适配器可以获取到ViewHolder,布局管理器也能\N{\ren}has access to the view holder and so\Ndoes the layout manager
Dialogue: 0,0:13:18.53,0:13:22.65,ch,,0,0,0,,它俩能获取到VH(ViewHolder)的原因在于,\N中间者recycler在内部也对VH进行了状态信息的存取\N{\ren}and recycler view does this internally\Nyou know, all the information that
Dialogue: 0,0:13:22.65,0:13:24.86,ch,,0,0,0,,每个位置上的视图都应该知道其相关的状态信息\N{\ren}view knows about its current position
Dialogue: 0,0:13:24.86,0:13:28.66,ch,,0,0,0,,这些状态信息包含其是否正在被改变,是否被删除或添加\N{\ren}whether it's are changing weather is\Nbeing added removed all these things that
Dialogue: 0,0:13:28.66,0:13:31.84,ch,,0,0,0,,当RecyclerView对所管理的视图进行好看的动画时,\N{\ren}recycler view uses for these fancy\Ntransition animations
Dialogue: 0,0:13:31.84,0:13:36.47,ch,,0,0,0,,这些状态信息都是从ViewHolder中存取的.\N你可以继承ViewHolder来对自定义的状态信息进行存取\N{\ren}that state is all held on the beholder\Nand you can extend that the holder which
Dialogue: 0,0:13:36.47,0:13:40.11,ch,,0,0,0,,当然,当你构建自己适配器,系统也要求你这么做.\N{\ren}your obviously supposed to when you\Nbuild your own adapter so if you wanna
Dialogue: 0,0:13:40.11,0:13:42.80,ch,,0,0,0,,因此,当你需要为每个视图设置一些状态信息的话\N{\ren}stuff more state in there for each\Nindividual view
Dialogue: 0,0:13:42.80,0:13:46.70,ch,,0,0,0,,正确的做法就是继承ViewHolder来干这事儿.\N因为视图会携带着这些信息\N{\ren}that's the right way to do that and then\Nthat will transport along with the views
Dialogue: 0,0:13:46.70,0:13:49.86,ch,,0,0,0,,当其被传递到布局管理器中时.\N{\ren}as they move into the layout manager and\Nand so on and so forth
Dialogue: 0,0:13:49.86,0:13:52.99,ch,,0,0,0,,因此牢记,布局管理器只对接回收器,不对接适配器\N{\ren}so always touch the recycler never touch\Nthe adapter
Dialogue: 0,0:13:55.40,0:13:58.81,ch,,0,0,0,,接下来,咱们对recycler的讨论要再深入一点\N{\ren}alright so let's look a little bit\Ndeeper into the recycler itself so I
Dialogue: 0,0:13:58.81,0:14:00.10,ch,,0,0,0,,我之前提到的\N{\ren}mention that the recycler
Dialogue: 0,0:14:00.10,0:14:03.95,ch,,0,0,0,,recycler最核心的工作就是其对视图的缓存(回收利用)\N{\ren}is a it's a caching mechanism above all\Nelse
Dialogue: 0,0:14:03.95,0:14:08.15,ch,,0,0,0,,一方面,你要从recycler中获取新视图\N{\ren}so the recycler is where you need to get\Nnew views
Dialogue: 0,0:14:08.15,0:14:11.09,ch,,0,0,0,,另一方面,你还要把废弃视图丢给recycler,但结果是,\N{\ren}and you need to toss away your old views\Nbut it turns out that they actually have
Dialogue: 0,0:14:11.09,0:14:13.06,ch,,0,0,0,,recycler里面竟有两种级别的机制\N{\ren}a two-level mechanism inside
Dialogue: 0,0:14:13.06,0:14:17.28,ch,,0,0,0,,来干这两件事情.recycler中有个叫废料堆的概念\N{\ren}to make this work the recycler has this\Nconcept of what they call the scrap heap
Dialogue: 0,0:14:17.28,0:14:21.52,ch,,0,0,0,,它底层还有个叫回收池的东西\N{\ren}and then underneath that is this idea of\Nthe recycle poor
Dialogue: 0,0:14:21.52,0:14:25.91,ch,,0,0,0,,这两者之间的差别是很微小的.在多数情况下\N{\ren}now the the difference between them is\Nfairly nuanced and in a lot cases it
Dialogue: 0,0:14:25.91,0:14:26.29,ch,,0,0,0,,其影响\N{\ren}doesn't
Dialogue: 0,0:14:26.29,0:14:30.05,ch,,0,0,0,,可以忽略不计.不过,如果你致力于获取最佳性能时\N{\ren}really matter but there are some\Noptimizations that can be made if you
Dialogue: 0,0:14:30.05,0:14:31.33,ch,,0,0,0,,了解这种微小差别就很有必要了\N{\ren}understand the difference
Dialogue: 0,0:14:31.33,0:14:35.88,ch,,0,0,0,,这里的ScrapHeap就像是第一道防线,\N{\ren}the the scrap heap is usually the the\Nfirst line of defense where you would
Dialogue: 0,0:14:35.88,0:14:37.35,ch,,0,0,0,,当你在Layout的时候\N{\ren}typically toss views
Dialogue: 0,0:14:37.35,0:14:41.79,ch,,0,0,0,,通常会把视图先丢到那里面去.难理解,没关系.先听着.\N{\ren}while you're doing layouts and all I'll\Nexplain to you in sort of a technique how
Dialogue: 0,0:14:41.79,0:14:47.52,ch,,0,0,0,,后面我会配着代码给你讲.\NScrapHeap是一种轻量级的操作\N{\ren}you would possibly use that in your code but the\Nscrap heap is a is a very lightweight place
Dialogue: 0,0:14:47.52,0:14:50.81,ch,,0,0,0,,在它里面检索视图和丢弃视图\N{\ren}where views can be tossed and retrieved\Nback
Dialogue: 0,0:14:50.81,0:14:55.53,ch,,0,0,0,,是以一种很快的方式进行.\N甚至从中获取的视图都不用再重新绑定数据\N{\ren}in a in a very quick fashion often cases\Nwithout even having to rebind the data
Dialogue: 0,0:14:55.53,0:14:58.92,ch,,0,0,0,,作为一个布局管理器,是很适合用这种结构来存取视图的\N{\ren}so it it's a nice place that as a layout\Nmanager
Dialogue: 0,0:14:58.92,0:15:02.24,ch,,0,0,0,,你可以把一些暂时不想用的视图先丢给ScrapHeap\N{\ren}you can toss a bunch of views that you\Nknow you're going to reuse again
Dialogue: 0,0:15:02.24,0:15:05.78,ch,,0,0,0,,注意这些视图还是可见的,然后也许在你对整个列表视图\N采用一些转换操作后,再让那些被丢弃的视图回来时\N{\ren}they're still on screen but maybe you\Nneed to shift them around or something
Dialogue: 0,0:15:05.78,0:15:09.56,ch,,0,0,0,,这时,这些回来的视图可以不走适配器(重新生成,绑定数据)这条路\N{\ren}like that and rather than them having to\Ngo back to the adapter to rebind data
Dialogue: 0,0:15:09.56,0:15:10.80,ch,,0,0,0,,传回给你,而是\N{\ren}and bring them back to you
Dialogue: 0,0:15:10.80,0:15:13.85,ch,,0,0,0,,你可以直接从ScrapHeap中拿到你之前丢弃给它的视图\N{\ren}you can just quickly get them back\Nfrom the scrap heap
Dialogue: 0,0:15:13.85,0:15:17.82,ch,,0,0,0,,再然后,你再对这些视图进行一下布局,\N那么你对列表的转换操作就算完美的结束了\N因此,通常,咱都是先用ScrapHeap来丢掉视图的.\N{\ren}and lay them out again,so typically\Nyou'll toss things in the scrap heap
Dialogue: 0,0:15:17.82,0:15:23.42,ch,,0,0,0,,不过如果你确定某些视图你永远都不用了的话,\N那么就该RecyclerPool派上用场了\N{\ren}first the recycle pool is more commonly\Nused for views you are certain you don't
Dialogue: 0,0:15:23.42,0:15:24.20,ch,,0,0,0,,(同上)\N{\ren}need anymore
Dialogue: 0,0:15:24.20,0:15:28.36,ch,,0,0,0,,比方说,当你运行了一次Layout之后,你可能有一些\N{\ren}so for instance after you've run a\Nlayout maybe you have a handful of
Dialogue: 0,0:15:28.36,0:15:30.73,ch,,0,0,0,,视图滑出了屏幕,以及你知道\N{\ren}views that have scrolled off screen and\Nyou didn't
Dialogue: 0,0:15:30.73,0:15:34.38,ch,,0,0,0,,你不想再使用这些视图了.\N那么你就可以把这些视图扔给RecyclerPo\N{\ren}you didn't need these and you know that\Nyou can toss those into the recycle poor
Dialogue: 0,0:15:34.38,0:15:39.24,ch,,0,0,0,,RecyclerPool依然可以被认为,你能从中快速获取视图\N{\ren}the recycle pool is still a quick way\Nof allowing you to get data back
Dialogue: 0,0:15:39.24,0:15:42.50,ch,,0,0,0,,但是,你所获取到的视图的一些meta-data会丢失\N{\ren}but it tosses away some of the\Nadditional meta-data
Dialogue: 0,0:15:42.50,0:15:46.33,ch,,0,0,0,,它仅仅对ViewHolder以及里面的itemView进行一下缓存\N{\ren}basically recycles the view holder and\Nkeeps the view around so
Dialogue: 0,0:15:46.33,0:15:50.24,ch,,0,0,0,,尽管你知道它可以快速的从适配器中重新绑定数据\N{\ren}even know it can quickly rebind data\Nfrom the adapter its a little bit more
Dialogue: 0,0:15:50.24,0:15:53.42,ch,,0,0,0,,但是如果你对每个视图都这么操作的话,代价就有点高了\N{\ren}expensive if you're constantly doing\Nthat for every single view
Dialogue: 0,0:15:53.42,0:15:57.04,ch,,0,0,0,,所以,通常你是把确定不会再在回收器中使用的视图\N{\ren}so typically you would wanna throw views\Nyou know you don't need in recycle into
Dialogue: 0,0:15:57.04,0:15:57.93,ch,,0,0,0,,丢给RecyclePool\N{\ren}the recycle poor
Dialogue: 0,0:15:57.93,0:16:01.98,ch,,0,0,0,,其他的那就是都扔给ScrapHeap.我会给你展示\N{\ren}toss everything else in this Scrap Heap\Nand I'll show you a technique that kind of
Dialogue: 0,0:16:01.98,0:16:02.97,ch,,0,0,0,,如何具体地去干这些事\N{\ren}allows you to do this
Dialogue: 0,0:16:02.97,0:16:07.20,ch,,0,0,0,,分别针对这两种级别.接下来,我要讲解的概念是\N{\ren}on on two different levels.the other\Nconcepts that
Dialogue: 0,0:16:07.20,0:16:10.36,ch,,0,0,0,,detachment和removal的区别\N{\ren}we were illustrating here is the\Ndifference between a detachment and a
Dialogue: 0,0:16:10.36,0:16:11.16,ch,,0,0,0,,(同上)\N{\ren}removal
Dialogue: 0,0:16:11.16,0:16:15.30,ch,,0,0,0,,这里看到的方法都是绑到一起的\N{\ren}in the method that I've got appear\Nthat they look like they're bound
Dialogue: 0,0:16:15.30,0:16:18.36,ch,,0,0,0,,但是你也可以将方法拆分着用\N{\ren}together but you can actually do all\Nthese operations separately you can
Dialogue: 0,0:16:18.36,0:16:19.60,ch,,0,0,0,,attach() 和 detach()\N{\ren}attach and detach
Dialogue: 0,0:16:19.60,0:16:23.14,ch,,0,0,0,,remove() 和 scrap(),所以你可以单个调用,\N绑定在一起只是为了方便\N{\ren}remove scrap you can do those things\Nindividually these are just convenience
Dialogue: 0,0:16:23.14,0:16:23.81,ch,,0,0,0,,(同上)\N{\ren}functions
Dialogue: 0,0:16:23.81,0:16:28.18,ch,,0,0,0,,在我看来,这里的函数命名是有点臭的\N{\ren}that the syntax is a little stinky in my\Nopinion because
Dialogue: 0,0:16:28.18,0:16:32.41,ch,,0,0,0,,因为detach是跟scrap相对应的\N{\ren}detach is really.it's a mechanism\Nsimilar to scrapping
Dialogue: 0,0:16:32.41,0:16:35.54,ch,,0,0,0,,当你把一个视图暂时的丢弃时\N{\ren}that allows you to toss a view away\Ntemporarily
Dialogue: 0,0:16:35.54,0:16:38.70,ch,,0,0,0,,这个视图你知道你会在相同的布局过程中重用\N{\ren}that you know you're going to reuse in\Nthe same layout pass
Dialogue: 0,0:16:38.70,0:16:41.75,ch,,0,0,0,,尽管这里的名字是detach\N{\ren}so the while the name is detach
Dialogue: 0,0:16:41.75,0:16:46.11,ch,,0,0,0,,从专业的角度来看,被detach的视图没有在父视图中被移除\N{\ren}a detached view is not technically\Nremoved from its parent
Dialogue: 0,0:16:46.11,0:16:49.56,ch,,0,0,0,,这里的父视图是指RecyclerView.\N子视图仍被添加在父视图中的\N{\ren}which is the recycler view it's actually\Nstill added to that view
Dialogue: 0,0:16:49.56,0:16:53.12,ch,,0,0,0,,其实布局管理器只允许你对这个视图进行一点操作而已\N{\ren}the layout managers just allowed to\Nmanipulate it a little bit so it's much
Dialogue: 0,0:16:53.12,0:16:54.30,ch,,0,0,0,,因此detach其实是个相当轻量级的操作\N{\ren}more lightweight
Dialogue: 0,0:16:54.30,0:16:57.99,ch,,0,0,0,,矛盾的是虽然名字是detach,但是还是attach着父视图的\N{\ren}I but it is still attached to the parent\Nview
Dialogue: 0,0:16:57.99,0:17:02.57,ch,,0,0,0,,remove操作跟你在ViewGroup中的移除视图操作相似\N{\ren}remove view is very similar to of a\Nview removal you would have on
Dialogue: 0,0:17:02.57,0:17:06.29,ch,,0,0,0,,这里被remove的视图可是的的确确的从其\N{\ren}a view group or anything like that\Nwhere it is actually detached from its
Dialogue: 0,0:17:06.29,0:17:07.25,ch,,0,0,0,,父视图中移除了\N{\ren}parent so it's
Dialogue: 0,0:17:07.25,0:17:10.74,ch,,0,0,0,,这让我不爽的就是remove操作的视图的确是detached,\N但是detach操作的视图却不是的\N{\ren}its little bit difficult cause remove\Nactually detach and detach does not
Dialogue: 0,0:17:10.74,0:17:15.35,ch,,0,0,0,,这里的话,你把detach当成一种轻量级的操作,而remove\N{\ren}but you can really think of it as\Ndetaches the lightweight and remove is
Dialogue: 0,0:17:15.35,0:17:16.07,ch,,0,0,0,,就是一种重量级的操作.这样来理解就比较好了\N{\ren}the heavyweight
Dialogue: 0,0:17:16.07,0:17:19.90,ch,,0,0,0,,通常你会把这两种事情合并在一起来做\N{\ren}so typically in most cases you do these\Nthings together
Dialogue: 0,0:17:19.90,0:17:23.58,ch,,0,0,0,,在recycler中的detachAndScrap方法\N{\ren}so the method on a recycler for detachAndScrap
Dialogue: 0,0:17:23.58,0:17:26.86,ch,,0,0,0,,被用来丢弃可能再次用到的视图\N{\ren}is where you would you would use that\Nto toss views away that you
Dialogue: 0,0:17:26.86,0:17:31.38,ch,,0,0,0,,而removeAndRecycle丢弃掉的视图,\N{\ren}might use again and removeAndRecycler\Nis the one you would use to toss views a
Dialogue: 0,0:17:31.38,0:17:34.85,ch,,0,0,0,,当你下次再从中获取时,可能就不一样了\N{\ren}away that the next time you need it.it's\Nprobably gonna be for different
Dialogue: 0,0:17:34.85,0:17:38.60,ch,,0,0,0,,因此这两个方法被用在不同的场合\N{\ren}different use case or a different mind
Dialogue: 0,0:17:38.60,0:17:40.67,ch,,0,0,0,,一些其他的\N{\ren}okay couple other
Dialogue: 0,0:17:40.67,0:17:43.68,ch,,0,0,0,,小贴士.这些小贴士在自定义布局管理器时肯定用得到\N{\ren}tips just to know when you're building a\Nlayout manager
Dialogue: 0,0:17:43.68,0:17:48.28,ch,,0,0,0,,布局管理器顾名思义,它的作用就是负责measure和layout\N{\ren}layout manager as the name implies is\Nresponsible for measuring and laying out
Dialogue: 0,0:17:48.28,0:17:49.99,ch,,0,0,0,,RecyclerView中每个视图\N{\ren}every view in a recycler view
Dialogue: 0,0:17:49.99,0:17:53.74,ch,,0,0,0,,这个作用跟ViewGroup对待其孩子视图的作用相类似\N{\ren}very similar to the responsibility that\Na container view group has for it
Dialogue: 0,0:17:53.74,0:17:54.52,ch,,0,0,0,,(同上)\N{\ren}child views
Dialogue: 0,0:17:54.52,0:17:58.77,ch,,0,0,0,,但是,RecyclerView还提供了个\N{\ren}however recycler provides this
Dialogue: 0,0:17:58.77,0:18:03.11,ch,,0,0,0,,额外的特性叫Decorations.大家都有谁用过Decoration\N{\ren}additional feature to developers call\Ndecorations how many of you used decorations before
Dialogue: 0,0:18:03.11,0:18:07.71,ch,,0,0,0,,很不错呢,这个特性让你能够\N{\ren}okay pretty good group.they allow you to\Nprovide
Dialogue: 0,0:18:07.71,0:18:12.86,ch,,0,0,0,,做额外的绘制或者做额外的边距间隔\N或者额外的尺寸大小\N{\ren}additional drawing or additional margins\Nor sizing requirements
Dialogue: 0,0:18:12.86,0:18:17.17,ch,,0,0,0,,在每个单一的列表项之上.例如,有了列表装饰\N{\ren}on individual items so for instance with\Nan item decoration
Dialogue: 0,0:18:17.17,0:18:21.44,ch,,0,0,0,,你不仅能在视图里面定义边距,还能把边距定义在装饰里\N{\ren}I can define not in the item view itself\Nbut in a declaration that
Dialogue: 0,0:18:21.44,0:18:25.16,ch,,0,0,0,,比方说如果你在decoration设置了边距\N{\ren}all of my items should have a margin\Naround them and it just
Dialogue: 0,0:18:25.16,0:18:29.10,ch,,0,0,0,,那么RecyclerView就会把这种设置应用到所有元素之上\N{\ren}recycler view applies that for me I\Ndon't have to do anything with it
Dialogue: 0,0:18:29.10,0:18:32.97,ch,,0,0,0,,而对布局管理器来讲,它不用关心\N{\ren}and that's true on the layout side as well\NI don't have to necessarily know that
Dialogue: 0,0:18:32.97,0:18:34.28,ch,,0,0,0,,当它进行布局的时候\N{\ren}when I lay something out
Dialogue: 0,0:18:34.28,0:18:38.70,ch,,0,0,0,,它不用把视图的边距考虑在内,API已经帮我们算好了\N{\ren}it has a margin and I've inside it the\NAPI handles that part for you
Dialogue: 0,0:18:38.70,0:18:42.37,ch,,0,0,0,,前提是你要在布局的时候使用\N{\ren}but it only handles that part if you lay\Nthem out appropriately using
Dialogue: 0,0:18:42.37,0:18:45.75,ch,,0,0,0,,一组不同的方法,这些方法你可能很熟悉,如果你之前做过\N{\ren}a different set of methods and you might\Nbe familiar with if you've done custom
Dialogue: 0,0:18:45.75,0:18:46.92,ch,,0,0,0,,自定义布局的话\N{\ren}you work in the past
Dialogue: 0,0:18:46.92,0:18:50.15,ch,,0,0,0,,与你之前做自定义布局类似,用view本身的参数来布局\N{\ren}so similarly all the information about\Nthe view
Dialogue: 0,0:18:50.15,0:18:53.30,ch,,0,0,0,,从技术上来说都是错误的\N{\ren}is technically wrong if you ask the view\Nitself
Dialogue: 0,0:18:53.30,0:18:56.67,ch,,0,0,0,,比方说我使用视图的left,right,top,bottom来布局的话\N{\ren}if I asked the view for its information\Nlike it left right top bottom
Dialogue: 0,0:18:56.67,0:18:59.85,ch,,0,0,0,,这样做是错的,因为这些参数并没有把"装饰"考虑在内\N{\ren}those are incorrect because they don't\Naccount for the decoration
Dialogue: 0,0:18:59.85,0:19:03.08,ch,,0,0,0,,作为替代,我们使用的是装饰过的left,right,top,bottom\N{\ren}instead there are decorated left right\Ntop bottom
Dialogue: 0,0:19:03.08,0:19:07.91,ch,,0,0,0,,请使用这些参数来对你的视图进行布局\N{\ren}that will give you the appropriate value\Nmight need while you're laying out other views
Dialogue: 0,0:19:07.91,0:19:11.08,ch,,0,0,0,,例如,我以垂直线性的方式来布局一堆视图时\N{\ren}so for instance if I'm laying out a\Nbunch views in a linear fashion
Dialogue: 0,0:19:11.08,0:19:15.61,ch,,0,0,0,,我会使用被装饰过的top和bottom值来确定前一个\N{\ren}I would use the decorated top and bottom\Nvalues to know where the previous view
Dialogue: 0,0:19:15.61,0:19:19.51,ch,,0,0,0,,视图的位置,以确定下一个视图的布局位置\N{\ren}was so I can lay out the next one in\Nfront of it or something like that
Dialogue: 0,0:19:19.51,0:19:22.83,ch,,0,0,0,,与之相似的,我们还有新的关于获取视图大小的方法\N{\ren}similarly we have method like that for\Nsizing
Dialogue: 0,0:19:22.83,0:19:26.61,ch,,0,0,0,,被装饰过的高度和宽度同样会将视图的边距计算在内\N{\ren}so the decorated height and with will\Naccount for those margins as well
Dialogue: 0,0:19:26.61,0:19:30.37,ch,,0,0,0,,我之前提到过,当你用布局管理器layout你的视图时\N{\ren}and as I mentioned when you're laying out your views
Dialogue: 0,0:19:30.37,0:19:34.64,ch,,0,0,0,,你要确保所用的是管理器中的layout和measure方法\N{\ren}you need to make sure to use the layout\Nand measure methods on the manager
Dialogue: 0,0:19:34.64,0:19:37.67,ch,,0,0,0,,你要去调用子视图自身的measure和layout方法\N{\ren}not calling measure and layout directly\Non the child views
Dialogue: 0,0:19:37.67,0:19:41.67,ch,,0,0,0,,如果你没有这么干的话\N{\ren}okay this will if you don't do these\Nthings
Dialogue: 0,0:19:41.67,0:19:45.23,ch,,0,0,0,,你的实现没有使用decoration的话\N{\ren}and you have an implementation that\Ndoesn't use decoration
Dialogue: 0,0:19:45.23,0:19:49.22,ch,,0,0,0,,那么看起来是没啥问题的.但假如有人对其设置的适配器\N{\ren}it'll look like it's working but as soon\Nas someone brings in an adapter that has
Dialogue: 0,0:19:49.22,0:19:50.11,ch,,0,0,0,,有装饰的话\N{\ren}a decoration
Dialogue: 0,0:19:50.11,0:19:53.23,ch,,0,0,0,,你的布局看起来就会让人困惑了,你可能还不知道为什么\N{\ren}attach to it,all your layouts will be confused you won't know why
Dialogue: 0,0:19:53.23,0:19:56.75,ch,,0,0,0,,所以,只要你坚持使用这些正确的方法在布局中\N{\ren}so as long as you stick to using these\Nmethods in your layouts all the time
Dialogue: 0,0:19:56.78,0:20:00.40,ch,,0,0,0,,那么你的布局管理器就会工作的非常好,\N无论是否有人对其设置Decoration\N{\ren}it'll just work regardless of whether\Nsomebody decorated their content or not
Dialogue: 0,0:20:03.67,0:20:06.79,ch,,0,0,0,,接下来我要讲的是\N{\ren}so the next piece that I wanna talk to you
Dialogue: 0,0:20:06.79,0:20:10.27,ch,,0,0,0,,被我称作为fill技术的概念\N{\ren}about is a concept that I call the "fill" technique
Dialogue: 0,0:20:10.27,0:20:14.32,ch,,0,0,0,,framework中关于视图回收的机制都用到fill这个概念\N{\ren}this is how the framework typically does\Na view recycling they did it this way
Dialogue: 0,0:20:14.32,0:20:16.80,ch,,0,0,0,,不光ListView中有,布局管理器的核心实现\N{\ren}in ListView they do it this way in their\Ncore
Dialogue: 0,0:20:16.80,0:20:19.81,ch,,0,0,0,,也用到了这个重要概念\N{\ren}layout managers as well
Dialogue: 0,0:20:19.81,0:20:24.22,ch,,0,0,0,,fill其实是一个函数,其目的是希望能够帮助你简化\N{\ren}this is a function that hopefully will helpful simplify the concept of
Dialogue: 0,0:20:24.22,0:20:29.64,ch,,0,0,0,,如何去运行一次布局的概念.\N和如何去构建一个布局管理器的概念\N{\ren}how you run a layout and how you sort of build a layout manager,it is all centrally
Dialogue: 0,0:20:29.64,0:20:33.80,ch,,0,0,0,,这两个过程的核心都在于这个被称为fill的概念上.fill其实\N{\ren}focused around this concept called the fill the fill is really just a layout
Dialogue: 0,0:20:33.80,0:20:37.05,ch,,0,0,0,,只是个布局操作.很多操作都被封装进了这一个操作中.\N{\ren}operation but it's all encapsulated into
Dialogue: 0,0:20:37.05,0:20:40.87,ch,,0,0,0,,比如说对当前视图状态进行检查的操作,\N{\ren}this functionality that is able to check for the current state
Dialogue: 0,0:20:40.87,0:20:44.93,ch,,0,0,0,,以及对这些状态做"解释"的操作等等.通常你得自己\N{\ren}and account for differences in that sort\Nof thing.so typically what she'll have
Dialogue: 0,0:20:44.93,0:20:48.71,ch,,0,0,0,,写一个方法,当你决定用fill这项技术时\N{\ren}when you're using this technique is a single method that you write
Dialogue: 0,0:20:48.71,0:20:53.17,ch,,0,0,0,,因为RecyclerView并没有给你提供fillGap或者fillAxe方法\N{\ren}there's no fill gap or fill axe method\Nthat lives in recycler view
Dialogue: 0,0:20:53.17,0:20:58.51,ch,,0,0,0,,这就需要我们自己来写一个方法.为了方便,就叫做fill了\N{\ren}you would create an internal method that we just by convention would call fill
Dialogue: 0,0:20:58.51,0:21:02.94,ch,,0,0,0,,(高能预警,我怕解释的不清楚,请把当前的布局管理假设为StaggerGridLayoutManager)这个方法会做列举出来的事情.它首先要\N{\ren}that does these things that I've listed here.so it's going to be responsible for
Dialogue: 0,0:21:02.94,0:21:06.75,ch,,0,0,0,,根据运行这次布局前的状态,来找出布局后第一个\N{\ren}determining based on the current layout what is the first
Dialogue: 0,0:21:06.75,0:21:10.10,ch,,0,0,0,,可见元素的位置\N{\ren}visible position you can see.you know,the
Dialogue: 0,0:21:10.10,0:21:13.90,ch,,0,0,0,,根据列表被向下滚动过长度\N{\ren}based on how far down the list is scrolled
Dialogue: 0,0:21:13.90,0:21:17.06,ch,,0,0,0,,由于布局前后第一个可见视图的位置会变\N你要在fill中做的就是,找出布局后第一个可见视图的位置\N{\ren}the first visible view doesn't necessarily mean
Dialogue: 0,0:21:17.06,0:21:21.78,ch,,0,0,0,,我们的做法就是\N{\ren}the first visible position but you basically the idea is to enumerate all
Dialogue: 0,0:21:21.78,0:21:23.16,ch,,0,0,0,,对布局前的视图进行枚举\N{\ren}those individual views
Dialogue: 0,0:21:23.16,0:21:28.19,ch,,0,0,0,,根据视图的状态,\N来决定哪个视图会是布局后的第一个可见视图\N{\ren}and figure out based on the views I have\Nwhat's the first position I can see
Dialogue: 0,0:21:28.19,0:21:31.62,ch,,0,0,0,,它可能是位置0,也可能是位置5,还可能是其他\N{\ren}as position 0 or as position 5 whatever\Nthe case may be
Dialogue: 0,0:21:31.62,0:21:35.41,ch,,0,0,0,,对于此视图,我们还要找出其偏移量\N{\ren}and you'll typically wanna look at that view and also determine its offset
Dialogue: 0,0:21:35.41,0:21:39.92,ch,,0,0,0,,如果此视图进行过位置变换的话.\N这种变化可能是由于视图被向上或向下平移了\N{\ren}is the view shifted in any way as it's shifted up or it's shifted down
Dialogue: 0,0:21:39.92,0:21:43.38,ch,,0,0,0,,而作为偏移量的另一部分,你还要考虑到\N{\ren}and as part of that,placement to that view
Dialogue: 0,0:21:43.38,0:21:46.71,ch,,0,0,0,,需不需要把Gap给计算在内.\N{\ren}do I have a gap?you know have the views
Dialogue: 0,0:21:46.71,0:21:50.29,ch,,0,0,0,,如果用户的滑动操作将列表往下平移到\N{\ren}shifted because of the user input user scroll the operation
Dialogue: 0,0:21:50.29,0:21:53.72,ch,,0,0,0,,需要其他视图进入来填充列表顶部的程度\N{\ren}to the point where I've got some extra\Nspace at the top that I need to fill
Dialogue: 0,0:21:53.72,0:21:54.74,ch,,0,0,0,,那这偏移量就要算上顶部的留白(Gap)\N{\ren}with another view
Dialogue: 0,0:21:54.74,0:21:58.27,ch,,0,0,0,,Gap这个术语就是这样而来的\N{\ren}that's kinda where the term comes from\Nif I don't
Dialogue: 0,0:21:58.27,0:22:01.87,ch,,0,0,0,,当然,如果列表按其他方式被平移,结果如果造成下面留白\N{\ren}or you know and maybe it shifted the\Nother way and maybe I have a gap at the bottom
Dialogue: 0,0:22:01.87,0:22:03.63,ch,,0,0,0,,因此底部要有东西来填充,这样偏移量就要算上底部留白\N{\ren}and I need to fill something there
Dialogue: 0,0:22:03.63,0:22:07.51,ch,,0,0,0,,简而言之,fill过程分为以下几步:\N1.找到第一个可视元素位置2.计算出Gap\N{\ren}so basically it's discovering what's\Nfirst finding gaps
Dialogue: 0,0:22:07.51,0:22:10.82,ch,,0,0,0,,不管Gap处在哪个边缘或者哪个角落\N{\ren}where where ever which edge whichever\Ncorner they may live in
Dialogue: 0,0:22:10.82,0:22:15.77,ch,,0,0,0,,3.最后,把所有视图Scrap掉,丢给recycler.\N这简单的三步走战略,能解决很多令人头疼的问题\N{\ren}and then scrapped everything this is the\Npart that will save you a bunch of headache
Dialogue: 0,0:22:15.77,0:22:20.21,ch,,0,0,0,,笨方法是,判断当前的状态,搞清楚视图将要如何被转换\N{\ren}rather than trying to determine your\Ncurrent state figure out whether based
Dialogue: 0,0:22:20.21,0:22:24.37,ch,,0,0,0,,接着对各个视图都做各做各的处理.\N两种方法,孰难孰易,孰好孰坏,不言自明.\N{\ren}on if it shifted this way do this if\Nit shifted that way do that just get
Dialogue: 0,0:22:24.37,0:22:28.05,ch,,0,0,0,,兄弟,你就省省劲,按我说的.1.找到第一个可视元素的位置\N{\ren}your current state information about\Nfirst visible position and where it
Dialogue: 0,0:22:28.05,0:22:31.34,ch,,0,0,0,,2.找出其偏移量3.把视图都留给ScrapHeap\N{\ren}is offset located toss everything in\Nthis crap in
Dialogue: 0,0:22:31.34,0:22:34.47,ch,,0,0,0,,这样以来\N{\ren}OK then from there
Dialogue: 0,0:22:34.47,0:22:38.72,ch,,0,0,0,,咱就能利用第一个可视视图的位置和偏移量等初始信息\N{\ren}take that initial information of the\Nfirst view and the first location
Dialogue: 0,0:22:38.72,0:22:43.06,ch,,0,0,0,,来走一次布局的过程了.这次的布局过程的逻辑是{\ren}and run a layup pass.just whatever logic
Dialogue: 0,0:22:43.06,0:22:47.16,ch,,0,0,0,,从初始位置的视图开始布局,依次往后布局,\N直到后面没有剩下空间为止{\ren}you need to say from this position until\NI run out of space
Dialogue: 0,0:22:47.16,0:22:51.88,ch,,0,0,0,,期间不断的从recycler中取出视图,然后对视图进行layout\N{\ren}grab views from the recycler and laid\Nthem out and then in that case it
Dialogue: 0,0:22:51.88,0:22:54.61,ch,,0,0,0,,这整个layout pass中,你无须考虑哪个视图是第一个,\N以及后面的视图离第一个视图的距离有多远\N{\ren}doesn't matter what's first or how far it is
Dialogue: 0,0:22:54.61,0:22:58.12,ch,,0,0,0,,你要做的,就仅仅是把所需的所有视图拿出来\N{\ren}you always just fill the space with
Dialogue: 0,0:22:58.12,0:23:01.70,ch,,0,0,0,,填充完剩下的空间而已,而不必考虑\N{\ren}all the views that you\Nneed depending on no matter what state
Dialogue: 0,0:23:01.70,0:23:02.63,ch,,0,0,0,,你当前列表所处什么状态\N{\ren}you're currently in
Dialogue: 0,0:23:02.63,0:23:06.66,ch,,0,0,0,,根据Gap所在的部位,你可能还要做一些调整的工作\N{\ren}now depending on where your gaps are you\Nmight have to make some adjustments
Dialogue: 0,0:23:06.66,0:23:10.89,ch,,0,0,0,,例如,你将列表向下平移了,那么Gap就在列表的上面\N{\ren}so for an instance if you shift the views\Ndown that gap is above
Dialogue: 0,0:23:10.89,0:23:13.89,ch,,0,0,0,,你将要进行布局的第一个视图的位置就\N{\ren}your first visible position that you\Nactually to lay out
Dialogue: 0,0:23:13.89,0:23:17.83,ch,,0,0,0,,往前递减了1次.\N因此你要根据Gap来做一些调整工作\N{\ren}has popped back one.so you may need to\Nmake some adjustment based on the gaps
Dialogue: 0,0:23:17.83,0:23:19.98,ch,,0,0,0,,不过,当你有了这些初始的信息之后\N{\ren}but once you have that initial information
Dialogue: 0,0:23:19.98,0:23:22.98,ch,,0,0,0,,往后列表发生任何转换,都只需执行一次三步走即可\N{\ren}and you scrap everything.just run a layout every time
Dialogue: 0,0:23:22.98,0:23:27.92,ch,,0,0,0,,整个操作的花费并不昂贵.\N因为其中大多数视图都是被布局过的.\N{\ren}right it's not expensive because a lot of these views are already laid out so
Dialogue: 0,0:23:27.92,0:23:30.55,ch,,0,0,0,,再次调用layout并不会改变任何属性\N{\ren}calling layout again doesn't change any other properties
Dialogue: 0,0:23:30.55,0:23:34.32,ch,,0,0,0,,除此之外,我们是把视图给放在ScrapHeap中的\N{\ren}and in it,in addition we've tossed them\Nin the scrap heap
Dialogue: 0,0:23:34.32,0:23:37.81,ch,,0,0,0,,因此,将视图从recycler中检索回来的代价也是很低的\N{\ren}so retrieving them back from the\Nrecycler is also very cheap
Dialogue: 0,0:23:37.81,0:23:42.24,ch,,0,0,0,,所以,可以看出来,这种操作就算不停的被执行\N{\ren}okay so I can do this over and over and\Nover again and as you know it doesn't
Dialogue: 0,0:23:42.24,0:23:45.79,ch,,0,0,0,,它也不会很影响性能.因此,我们不必想着\N{\ren}it doesn't necessarily affect the performance.I don't just have to try and
Dialogue: 0,0:23:45.79,0:23:49.47,ch,,0,0,0,,1.怎么对所需的空间里的元素进行操作\N2.怎么调整其余的元素不受影响\N{\ren}manipulate the spaces that I need and\Ntry to leave all the other views along
Dialogue: 0,0:23:49.47,0:23:52.64,ch,,0,0,0,,你如果这么干的话,你会处处碰壁,举步维艰\N{\ren}you'll get yourself caught in way too\Nmany edge cases if you do that
Dialogue: 0,0:23:52.64,0:23:56.24,ch,,0,0,0,,正确的做法,就是简化整个过程,\N每次更新列表都按我刚说的办\N{\ren}you can simplify it by just doing the\Nsame process every time
Dialogue: 0,0:23:56.24,0:23:59.98,ch,,0,0,0,,fill这个方法不管是在初始化布局时\N{\ren}and then this method will be called\Nwhether it's in initial layout
Dialogue: 0,0:23:59.98,0:24:03.93,ch,,0,0,0,,还是在用户滚动列表时,\N还是在RecyclerView有任何状态改变时\N{\ren}where they were scrolling whether any\Nstate changes on the recycler view which
Dialogue: 0,0:24:03.93,0:24:06.26,ch,,0,0,0,,其都会被调用.而且每次被调用所走的都是同一个过程\N{\ren}is gonna go through this exact same\Nprocess
Dialogue: 0,0:24:06.26,0:24:09.56,ch,,0,0,0,,(太佩服我自己了,居然把fill这个概念翻译完了 - -)\N{\ren}alright
Dialogue: 0,0:24:09.56,0:24:12.44,ch,,0,0,0,,你可能又会问,上哪儿找我的Gap呢\N{\ren}questions you would ask yourself about\Nwhere my gaps
Dialogue: 0,0:24:12.44,0:24:16.61,ch,,0,0,0,,这里很重要的一点要记住,你要尽可能少的去保存状态值\N{\ren}and the important thing to remember here\Nis to save as little state as possible
Dialogue: 0,0:24:16.61,0:24:20.39,ch,,0,0,0,,你要做的是把视图的信息给算出来\N{\ren}right you want to discover the\Ninformation about your view
Dialogue: 0,0:24:20.39,0:24:24.36,ch,,0,0,0,,第一个可视视图的位置和其偏移量都要算才行.\N{\ren}what's the first visible position what\Nis it offset don't try to track
Dialogue: 0,0:24:24.36,0:24:28.30,ch,,0,0,0,,不要想着设置状态值去追踪这些信息.\N因为这通常会由于\N{\ren}that information because that typically\Ntends to lead to edge cases where you
Dialogue: 0,0:24:28.30,0:24:29.92,ch,,0,0,0,,你没有追踪到位都导致边界错误.\N{\ren}can track it correctly and then you
Dialogue: 0,0:24:29.92,0:24:34.03,ch,,0,0,0,,你会把事情推向另一个分支发展.所以正确的做法是\N{\ren}you are branching a statement all over the\Nplace.ok use this as a
Dialogue: 0,0:24:34.03,0:24:37.49,ch,,0,0,0,,尽可能把fill这个函数当成一个无状态函数,\N只借助内部状态找出\N{\ren}as stateless a function as you can\Npossibly do that discovers everything it
Dialogue: 0,0:24:37.49,0:24:38.41,ch,,0,0,0,,来找出我们所需的布局初始信息\N{\ren}needs up front
Dialogue: 0,0:24:38.41,0:24:41.71,ch,,0,0,0,,然后恰当的去运行布局过程.\N{\ren}and then runs the layout appropriately\Non each pass
Dialogue: 0,0:24:44.78,0:24:45.48,ch,,0,0,0,,\N{\ren}okay
Dialogue: 0,0:24:45.48,0:24:48.75,ch,,0,0,0,,顺便,我们这里举一个fill的例子\N{\ren}just by  way,an example,this is what a fill
Dialogue: 0,0:24:48.75,0:24:51.92,ch,,0,0,0,,fill函数应该就长得像这样\N{\ren}function might look like or you\Nmight stop one out
Dialogue: 0,0:24:51.92,0:24:56.05,ch,,0,0,0,,这里,首先,你需要想出一些逻辑来找出{\ren}so you know,at the beginning you're going to\Nhave some logic to determine what the
Dialogue: 0,0:24:56.05,0:24:58.76,ch,,0,0,0,,第一个可视视图的位置,这个位置由于布局的不同\N{\ren}first visible position is depending on\Nyour layout that
Dialogue: 0,0:24:58.76,0:25:02.65,ch,,0,0,0,,其位置的算法肯定也不相同.若是简单的算法,也许就像是\N{\ren}your could mean a number of things it's\Nprobably just gonna be something simple
Dialogue: 0,0:25:02.65,0:25:07.13,ch,,0,0,0,,枚举所有的孩子视图,对其ViewHolder进行询问\N{\ren}like enumerating overall the child views\Nasking those Child's View holders what
Dialogue: 0,0:25:07.13,0:25:08.15,ch,,0,0,0,,其所处的位置是多少\N{\ren}their position are
Dialogue: 0,0:25:08.15,0:25:12.16,ch,,0,0,0,,要是你的列表是按线性布局的话,\N那么所要找的位置就是其中最小的\N{\ren}and may be looking for the lowest value\NOK that would be true for a linear want
Dialogue: 0,0:25:12.16,0:25:14.01,ch,,0,0,0,,如果是其他情形,那么就要依据\N{\ren}it may not be true depending on what your
Dialogue: 0,0:25:14.01,0:25:18.59,ch,,0,0,0,,布局的不同来选取不同的位置了.\N总之,你要找出来第一个列表项的位置\N{\ren}your layout implementation is,but\Nfiguring out what that first visible item is
Dialogue: 0,0:25:18.59,0:25:22.88,ch,,0,0,0,,如果需要的话,你还要把偏移量给找出来.\N这就取决于你的列表有没有进行过转换\N{\ren}and if it's necessary what is its offset\Nis it has it been shifted
Dialogue: 0,0:25:22.94,0:25:25.78,ch,,0,0,0,,如果被转换过,我们就要对留白进行填充等等.\N{\ren}so that we need to of your fill a gap or\Nsomething like that
Dialogue: 0,0:25:26.42,0:25:28.05,ch,,0,0,0,,正如我之前所提到的\N{\ren}and then as i mentioned there are
Dialogue: 0,0:25:28.05,0:25:31.10,ch,,0,0,0,,RecyclerView中有一些帮助类的方法可供我们使用\N{\ren}a helper methods available on the\Nrecycler view
Dialogue: 0,0:25:31.10,0:25:34.37,ch,,0,0,0,,这样方法可以帮助我们将视图传给回收器进行回收\N{\ren}to help you toss away of views so the
Dialogue: 0,0:25:34.37,0:25:39.61,ch,,0,0,0,,framework中几乎每个主要的方法都会传递给你两个对象\N{\ren}the two objects that you're going to see\Npassed to you in pretty much every major framework method
Dialogue: 0,0:25:39.61,0:25:43.79,ch,,0,0,0,,1是回收器的实例,2是叫做回收器状态的对象\N{\ren}is a recycler instance and something\Ncalled the recycler state
Dialogue: 0,0:25:43.79,0:25:47.00,ch,,0,0,0,,这两个对象一般都是绑定在一起工作的\N{\ren}and those two things all will work together
Dialogue: 0,0:25:47.00,0:25:50.11,ch,,0,0,0,,其工作目的是\N在你需要做跟修改布局相关的事情时来帮你\N{\ren}for everything that you need to do\Nassociated with modifying your layout so
Dialogue: 0,0:25:50.11,0:25:50.87,ch,,0,0,0,,我们这个例子中\N{\ren}in this case
Dialogue: 0,0:25:50.87,0:25:55.52,ch,,0,0,0,,recycler被传进入了API中的一个帮助方法\N{\ren}the recycler is passed to this helper\Nfunction which is part of the API
Dialogue: 0,0:25:55.52,0:25:59.29,ch,,0,0,0,,这个方法不用你来做实现,你只要告诉framework,\NdetachAndScrapAttachedViews就行了\N{\ren}that's not something you have to write\Njust detach and scrap attached views
Dialogue: 0,0:25:59.29,0:26:02.68,ch,,0,0,0,,这意思是说,把当前attached的视图全都\N{\ren}that says tossed every view that I has\Ncurrently attached to me
Dialogue: 0,0:26:02.68,0:26:06.90,ch,,0,0,0,,丢给Scrap堆.之后,\N{\ren}throw into scrap.OK,and then from there
Dialogue: 0,0:26:06.90,0:26:10.74,ch,,0,0,0,,你可以简单的遍历出你所需要的视图,\N{\ren}you can simply iterate through however\Nmany views you need whether you have
Dialogue: 0,0:26:10.74,0:26:14.21,ch,,0,0,0,,不管你是要把这些视图布局到一个固定大小的窗口里,\N还是你要用视图把整个界面的空间都布局满\N{\ren}like a fixed window size or you just\Nwant to iterate through views until you
Dialogue: 0,0:26:14.21,0:26:17.49,ch,,0,0,0,,或者将这些视图应用到任何你想出来的布局算法中\N{\ren}run out of space whatever algorithm that you\Nwant to use to do this
Dialogue: 0,0:26:17.49,0:26:21.01,ch,,0,0,0,,你都得把这些需要的视图给遍历出来.你要在\N{\ren}iterate through those views and get each one back
Dialogue: 0,0:26:21.01,0:26:22.66,ch,,0,0,0,,recycler中把每个视图给查找出来.\N{\ren}from the recycler so
Dialogue: 0,0:26:22.66,0:26:26.53,ch,,0,0,0,,getViewForPosition这个方法会告诉recycler,\N我想在这个位置上进行布局\N{\ren}getViewForPosition will tell the recycler this is\Nthe position I wanna lay out
Dialogue: 0,0:26:26.53,0:26:30.16,ch,,0,0,0,,接着recycler会返回给你所需要的视图,\N并且已经给你绑定好了数据\N{\ren}and it will give you the view already\Nbound to the data that you need to do
Dialogue: 0,0:26:30.16,0:26:30.98,ch,,0,0,0,,这些数据会在你布局的时候被用到\N{\ren}that layout with
Dialogue: 0,0:26:30.98,0:26:34.94,ch,,0,0,0,,之后,就像你将视图布局到其他任何ViewGroup中一样,\N你先要把视图给添加进入\N{\ren}OK and then just like you would in any\Nother view group you need add it
Dialogue: 0,0:26:34.94,0:26:38.27,ch,,0,0,0,,或者说是attach到父视图上,然后measure,layout\N{\ren}or attach it measure it and lay it out
Dialogue: 0,0:26:38.27,0:26:43.88,ch,,0,0,0,,这之后\N{\ren}oK then from there
Dialogue: 0,0:26:43.88,0:26:48.11,ch,,0,0,0,,最后一步是看看有没有剩下的视图\N{\ren}the final job is determining if there\Nare any views that were in my layout
Dialogue: 0,0:26:48.11,0:26:52.12,ch,,0,0,0,,这些在布局中没有被用到.之前,我们开始的时候,\N我们是把当前所有的视图都丢给ScrapHeap\N{\ren}that I don't need anymore so when I went\Nthrough and I scrapped everything
Dialogue: 0,0:26:52.12,0:26:55.75,ch,,0,0,0,,如果在接下来的layout过程中,\N仅仅使用到了我们所需的视图\N{\ren}if if the next step is to lay out just what I need
Dialogue: 0,0:26:55.75,0:26:58.95,ch,,0,0,0,,那么在Scrap中就有可能还剩下没被操作的视图\N{\ren}there may be views that were left in the scrap heap
Dialogue: 0,0:26:58.95,0:27:02.48,ch,,0,0,0,,这些视图就可能是滚出屏幕的视图,\N也可能是由于某种原因\N{\ren}and those are views that I scrolled off screen or for whatever reason I don't
Dialogue: 0,0:27:02.48,0:27:03.32,ch,,0,0,0,,我不在需要的视图\N{\ren}need anymore
Dialogue: 0,0:27:03.32,0:27:07.50,ch,,0,0,0,,因为这些视图没有经过layout的过程\N(因此就不会再出现在屏幕之上了)\N{\ren}because they didn't make it back into the layout pass.you can ask the recycler
Dialogue: 0,0:27:07.50,0:27:10.23,ch,,0,0,0,,此时你可以对recycler中的视图状态进行检查\N{\ren}view for its current list of what's in scrap
Dialogue: 0,0:27:10.23,0:27:14.19,ch,,0,0,0,,此时如果还有视图存在与Scrap中的话,我们是不需要的了\N{\ren}and if there is anything left in scrap at this stage I don't need it
Dialogue: 0,0:27:14.19,0:27:18.58,ch,,0,0,0,,那对于这些视图,我就可以把它们给回收了.\N回收的过程就是\N{\ren}so I can recycle it.ok,so then this will just go through in
Dialogue: 0,0:27:18.58,0:27:22.89,ch,,0,0,0,,把视图从ScrapHeap中拿出来,\N然后显式的将其它们丢给RecyclerPool\N{\ren}and take the views out at the scrap heap and explicitly put them in their cycle poor
Dialogue: 0,0:27:22.89,0:27:26.36,ch,,0,0,0,,这是一种更有效的回收视图的方式,来把你明确知道的\N{\ren}okay and that's a more efficient way of holding those views when you know
Dialogue: 0,0:27:26.36,0:27:30.21,ch,,0,0,0,,之后还会再绑定数据的视图进行回收.这并不意味着\N{\ren}that they're gonna need to be rebound to data later on,that doesn't mean that
Dialogue: 0,0:27:30.21,0:27:34.77,ch,,0,0,0,,你把这些剩下的存在于Scrap的视图给回收后,\N{\ren}if you run out of views and recycle\Nand the only views that are available are in scrap that
Dialogue: 0,0:27:34.77,0:27:39.60,ch,,0,0,0,,这些视图就不能进行数据绑定了.recycler不光从Scrap中,\N也会从RecyclerPool中取出视图进行绑定.\N{\ren}it won't be able to rebind them.recycle will rebind data from scrap or recycle so it
Dialogue: 0,0:27:39.60,0:27:42.98,ch,,0,0,0,,你不必担心到底能不能\N{\ren}it's not something you necessarily have to worry about as to whether it will
Dialogue: 0,0:27:42.98,0:27:46.97,ch,,0,0,0,,让你的视图工作起来.这仅仅是一种优化操作\N{\ren}make your view work correctly.it's just an optimization
Dialogue: 0,0:27:46.97,0:27:51.66,ch,,0,0,0,,如果在recycler中正确的使用Scrap,\N你就能对回收行为做最大的优化\N{\ren}if you use scrap in recycle appropriately\Nthen you'll have the most optimized for recycling behavior
Dialogue: 0,0:27:51.66,0:27:53.86,ch,,0,0,0,,比方说内存管理或其他等等相关的.\N{\ren}in terms of memory management that sort of thing.okay
Dialogue: 0,0:27:53.86,0:27:56.44,ch,,0,0,0,,layout的过程讲完了.\N{\ren}okay
Dialogue: 0,0:27:56.46,0:28:00.33,ch,,0,0,0,,那么framework让我们这么干的好处在哪呢\N其好处之一就是,在实现我的例子\N{\ren}so one of the advantages from the example that I
Dialogue: 0,0:28:00.33,0:28:04.51,ch,,0,0,0,,之前,我必须要对视图的索引进行处理\N{\ren}had put forth of doing this has to do with view indices
Dialogue: 0,0:28:04.51,0:28:09.75,ch,,0,0,0,,要实现这种布局,我第一个要考虑的问题就是\N{\ren}one of the first problem i doubt with when dealing with this,this fixed grid implementation
Dialogue: 0,0:28:09.75,0:28:14.22,ch,,0,0,0,,这不像是一个通常的线性单向滚动的\N{\ren}was unlike a traditional linear single scrolling
Dialogue: 0,0:28:14.22,0:28:18.23,ch,,0,0,0,,实现,这里在滚动时,视图的索引不是连续的\N{\ren}implementation the view indices aren't always consistent
Dialogue: 0,0:28:18.23,0:28:21.65,ch,,0,0,0,,在LinearLayout甚至GridLayout中,你都可以简单的\N{\ren}you know something like a LinearLayout or even a grid layout you can typically
Dialogue: 0,0:28:21.65,0:28:23.05,ch,,0,0,0,,依赖这样一个事实\N{\ren}rely on the fact that
Dialogue: 0,0:28:23.05,0:28:26.10,ch,,0,0,0,,列表中的第一个视图,就是第一个可见的视图\N{\ren}the first views in the list are the first visible
Dialogue: 0,0:28:26.10,0:28:29.49,ch,,0,0,0,,最后一个视图,就是最后一个可见的视图.你可以依赖于\N{\ren}and the last views in list is the last visible.and you can rely on a
Dialogue: 0,0:28:29.49,0:28:33.63,ch,,0,0,0,,视图的index和position以一种相对连续的方式进行映射\N{\ren}a fairly consistent mapping between view indices
Dialogue: 0,0:28:33.63,0:28:36.08,ch,,0,0,0,,当列表往上滚的时候,\N{\ren}and positions you know when you scroll up you would
Dialogue: 0,0:28:36.08,0:28:40.25,ch,,0,0,0,,你通常在列表前面插入视图,如果列表下滚\N{\ren}typically insert views at the front and\Nif as you scroll down you would
Dialogue: 0,0:28:40.25,0:28:44.52,ch,,0,0,0,,通常就在尾部进行添加.但是对于\N{\ren}append them to the end or vice versa but\Nthat's not necessarily true with this
Dialogue: 0,0:28:44.52,0:28:46.17,ch,,0,0,0,,我们的例子来说这样做就不对了.\N{\ren}case you know in this case if the
Dialogue: 0,0:28:46.17,0:28:50.22,ch,,0,0,0,,如果用户正在查看网格中间的某些块元素\N{\ren}if the user is looking at some block of elements in the middle of the grid
Dialogue: 0,0:28:50.22,0:28:54.07,ch,,0,0,0,,视图的索引就可能看起来像这种样子,按照我布局的方式\N{\ren}the view indices might look something like this: based on the way I've laid them out
Dialogue: 0,0:28:54.07,0:28:57.82,ch,,0,0,0,,但是你可以看出来,如果你把左边和右边的\N{\ren}but you can kinda see that on the left and the right hand side there
Dialogue: 0,0:28:57.82,0:29:01.00,ch,,0,0,0,,视图索引当成适配器的位置来看时\N{\ren}those views are part of the range
Dialogue: 0,0:29:01.00,0:29:04.83,ch,,0,0,0,,从适配器的角度来看,它们就是不可见的\N{\ren}from the adapters perspective they just aren't visible right now
Dialogue: 0,0:29:04.83,0:29:08.78,ch,,0,0,0,,你可以想象的到,当我把这个窗口在视图上做各种平移时\N{\ren}so you can imagine that as i shift the window across these views
Dialogue: 0,0:29:08.78,0:29:12.51,ch,,0,0,0,,视图们就会以组的形式给添加进来.我可能\N{\ren}they will be brought in as groups\Nso I would bring in maybe
Dialogue: 0,0:29:12.51,0:29:16.36,ch,,0,0,0,,会添加4个视图来布局出下一列,\N或者添加几个视图来布局下一行\N{\ren}for call 4 views in the next column\Nmaybe a couple for the new row
Dialogue: 0,0:29:16.36,0:29:20.23,ch,,0,0,0,,这些视图以组的形式可能从各个方向上\N(上,下,左,右)被添加进来\N{\ren}and it will come in groups that could be coming from all four sides
Dialogue: 0,0:29:20.23,0:29:23.79,ch,,0,0,0,,因此如果我要依赖任何\N{\ren}so if I want to rely on any sort
Dialogue: 0,0:29:23.79,0:29:28.73,ch,,0,0,0,,视图索引的连续性的话,我需要先把所有视图都丢掉,然后\N{\ren}of consistency in the view indices I need to toss everything away and
Dialogue: 0,0:29:28.73,0:29:33.00,ch,,0,0,0,,然后对其进行重新布局,来确保索引0的孩子总在左上方\N{\ren}relayout and that insures that child 0 is always at the top left
Dialogue: 0,0:29:33.00,0:29:36.14,ch,,0,0,0,,索引X的孩子总在右下方\N{\ren}child whatever is at the bottom right.ok
Dialogue: 0,0:29:36.14,0:29:39.38,ch,,0,0,0,,否则你就不能依赖索引连续性.\N我并不是说你非得这么干.\N{\ren}otherwise I can't and I'm not saying you\Nhave to rely on that but
Dialogue: 0,0:29:39.38,0:29:43.26,ch,,0,0,0,,但你如果非要为这么干找一个原因的话,\N如果说你能够确定\N{\ren}but a little trick to help keep your sanity here is if you can be relatively sure
Dialogue: 0,0:29:43.26,0:29:45.01,ch,,0,0,0,,孩子视图的索引\N{\ren}that the child indices are in the right
Dialogue: 0,0:29:45.01,0:29:50.21,ch,,0,0,0,,一直是正常的话,这会帮你简化你一些检查的逻辑\N{\ren}order all the time then it it helps simplify some of that inspection logic
Dialogue: 0,0:29:50.21,0:29:52.87,ch,,0,0,0,,这种检查是当你对视图做改变时有可能需要做的,等等\N{\ren}that you may need to do later on for changes and stuff like that
Dialogue: 0,0:29:52.87,0:29:56.27,ch,,0,0,0,,因此,这里说的\N仅仅是遵从framework进行layout的一个好处\N{\ren}so just an advantage of using that implementation
Dialogue: 0,0:29:56.27,0:30:01.52,ch,,0,0,0,,取决于你自定义布局的功能性和你对fill方法的改写\N{\ren}and this depending on your functionality and how you mutate that fill method I showed you
Dialogue: 0,0:30:01.52,0:30:04.90,ch,,0,0,0,,你可以通过手动调用attach和detach\N{\ren}you can use attach and detach manually
Dialogue: 0,0:30:04.90,0:30:09.53,ch,,0,0,0,,来对屏幕上的视图进行重新排序.\N如果你不准备将他们都丢给Scrap的话\N{\ren}to reorder these views so you know if\Nyou're not necessarily scrapping them
Dialogue: 0,0:30:09.53,0:30:13.51,ch,,0,0,0,,但是,出于某种原因,你仅仅是想将视图进行重新排序的话\N{\ren}but for whatever reason you just want to\Nreorder them so that the same views have
Dialogue: 0,0:30:13.51,0:30:15.28,ch,,0,0,0,,视图还是同样的视图,但是视图的索引却被重新排序的话\N{\ren}different indices that are in this order
Dialogue: 0,0:30:15.28,0:30:18.49,ch,,0,0,0,,你要先把视图全detach掉,\N然后将视图以正确的顺序给attach回来\N{\ren}detach them all and reattach them in the right order that will
Dialogue: 0,0:30:18.49,0:30:24.26,ch,,0,0,0,,这样才能使孩子视图有合适的视图索引\N{\ren}that will give them the proper view index from a child perspective inside of the parent view
Dialogue: 0,0:30:28.56,0:30:30.05,ch,,0,0,0,,好了,咱接下来要讲一下\N{\ren}okay so let's talk a little bit about
Dialogue: 0,0:30:30.05,0:30:35.26,ch,,0,0,0,,整个布局过程的步骤了.\N假设你现在已经写好了一个fill方法\N{\ren}the steps to build one of these things,so assuming that you have a proper method put together
Dialogue: 0,0:30:35.26,0:30:38.96,ch,,0,0,0,,将我传授给你的秘诀都用上了.\N{\ren}one that sort of follows that recipe that I showed you.
Dialogue: 0,0:30:38.96,0:30:42.77,ch,,0,0,0,,现在,我就传授你如何将前面讲过的东西串联在一起.\N{\ren}this is sort of how we would put these things in place,so the first
Dialogue: 0,0:30:42.77,0:30:45.78,ch,,0,0,0,,我把使用recycler对视图进行布局的第一级别称为\N{\ren}the first level that I call it of working recycler view layout
Dialogue: 0,0:30:45.78,0:30:49.53,ch,,0,0,0,,让布局管理器能工作起来.布局管理器有很多回调方法\N{\ren}is just to get the thing working,right.so that there's a handful call back
Dialogue: 0,0:30:49.53,0:30:54.59,ch,,0,0,0,,需要你来进行重写和实现\N来使一个实际的布局管理器可以工作起来\N{\ren}you need to to override and implement just to get an actual layout manager functioning
Dialogue: 0,0:30:54.59,0:30:58.10,ch,,0,0,0,,第一个要重写的方法就是onLayoutChildren,\N这是一个初始化的方法\N{\ren}the first one is on layout children this is the initial method
Dialogue: 0,0:30:58.10,0:31:02.33,ch,,0,0,0,,这个方法会由framework调用,当任何一个特定的布局改变\N{\ren}they will be called by the framework anytime a significant layout change
Dialogue: 0,0:31:02.33,0:31:03.90,ch,,0,0,0,,发生在RecyclerView身上时\N{\ren}happens to the recycler view
Dialogue: 0,0:31:03.90,0:31:06.94,ch,,0,0,0,,RecyclerView就会把这个改变委托给布局管理器\N{\ren}the recycler view will delegate to the manager that
Dialogue: 0,0:31:06.94,0:31:11.49,ch,,0,0,0,,告诉它,需要它通过onLayoutChildren进行一次新的布局,\N注意,onLayoutChildren并不会被重复调用\N{\ren}it needs to do a new layout through onLayoutChildren.this is not called repeatedly
Dialogue: 0,0:31:11.49,0:31:15.60,ch,,0,0,0,,所以,其不会在每次布局改变时都被调用,而仅在初始化时\N{\ren}meaning it's not called on every change\Nbut it'll be called for initial layout
Dialogue: 0,0:31:15.60,0:31:18.85,ch,,0,0,0,,还有当RecyclerView的大小被改变时也会调用\N{\ren}it will be called if the size of the recycler view changes if you ever call
Dialogue: 0,0:31:18.85,0:31:21.83,ch,,0,0,0,,如果你有调用过RecyclerView.requestLayout的话,\N就会触发onLayoutChildren被调用\N{\ren}requestLayout on the recycler view this is what you're gonna see
Dialogue: 0,0:31:21.83,0:31:25.49,ch,,0,0,0,,如果写的fill方法合格的话,在onLayoutChildren中,\N你要干的全部工作\N{\ren}and again if you haven't inappropriately written fill method all you have to do
Dialogue: 0,0:31:25.49,0:31:29.84,ch,,0,0,0,,仅仅是运行fill而已.不管你在RecyclerView中\N是否已经存在了视图,或者其中视图为空\N{\ren}in here is to run it.whether you have views in there already or whether it's empty
Dialogue: 0,0:31:29.84,0:31:33.13,ch,,0,0,0,,这都没关系,你仅仅在里面运行fill即可,就能把事情全搞定\N{\ren}doesn't matter you just run your fill inside of here and be done
Dialogue: 0,0:31:33.13,0:31:40.08,ch,,0,0,0,,但是,我们还在这个方法中添加一些对用户操作的控制\N{\ren}okay,but we want to add a little bit of user act in there interactivity to this function as well
Dialogue: 0,0:31:40.08,0:31:45.50,ch,,0,0,0,,所以,你必须在RecyclerView中来决定或者说是通知framework\N{\ren}so you have to determine or you have to report back to the framework in recycler view
Dialogue: 0,0:31:45.50,0:31:50.11,ch,,0,0,0,,这个视图能在哪个坐标轴上进行滚动,是垂直轴呢?\N{\ren}which axis can this view scrolling,can it scroll vertically
Dialogue: 0,0:31:50.11,0:31:53.39,ch,,0,0,0,,还是水平轴?或者在我的例子中,两者都行\N{\ren}can scroll horizontally or in my case,both
Dialogue: 0,0:31:53.39,0:31:57.03,ch,,0,0,0,,多数情况下,你仅仅需要在这两个方法中\N{\ren}so in most of these cases you would only return true
Dialogue: 0,0:31:57.03,0:32:01.01,ch,,0,0,0,,的一个里面返回true就行了.\N但是我们的固定网格实现两个方法中都返回了true\N{\ren}from one of these methods but the fix grid implementation returns it for
Dialogue: 0,0:32:01.01,0:32:04.45,ch,,0,0,0,,这样它就能在水平方向和垂直方向同时滚动了.\N{\ren}both so that it can scroll both horizontally and vertically at the same time
Dialogue: 0,0:32:04.45,0:32:07.82,ch,,0,0,0,,如果你没有从这两个方法中返回true\N{\ren}if you don't return true from these methods then
Dialogue: 0,0:32:07.82,0:32:12.22,ch,,0,0,0,,那么RecyclerView的内部实现就简单地\N不把这个方向上事件分发给自己来处理\N{\ren}the recycler view implementation simply won't delivery events back to you
Dialogue: 0,0:32:12.22,0:32:15.74,ch,,0,0,0,,因为它知道你只会在一个方向上滚动,因此会锁定滚动\N{\ren}knowing that you're scrolling in one direction,the other basically locks scrolling
Dialogue: 0,0:32:15.74,0:32:18.87,ch,,0,0,0,,在另一个方向上\N{\ren}in that particular orientation but
Dialogue: 0,0:32:18.87,0:32:22.87,ch,,0,0,0,,而真正实现视图滚动的处理逻辑是在\N{\ren}the actual implementation of this scrolling functionality happens in the
Dialogue: 0,0:32:22.87,0:32:26.85,ch,,0,0,0,,scrollXBy方法中,水平方向滚动的话就是scrollHorizontallyBy,\N垂直的话就是scrollVerticallyBy\N{\ren}scroll x by methods so scroll horizontally or vertically by
Dialogue: 0,0:32:26.85,0:32:31.86,ch,,0,0,0,,这俩方法会重复地被调用,这跟你在\N{\ren}these methods will be called repeatedly very similar to the scroll by methods you
Dialogue: 0,0:32:31.86,0:32:33.53,ch,,0,0,0,,View里或ViewGroup里看到的scrollBy方法是非常相似的,\N{\ren}would see on a view or view group
Dialogue: 0,0:32:33.53,0:32:38.15,ch,,0,0,0,,当用户的手势交互到来时.因此这是布局管理器的责任\N{\ren}as user interaction is coming in.so it is the responsibility
Dialogue: 0,0:32:38.15,0:32:41.64,ch,,0,0,0,,去处理视图的移动\N{\ren}of the layout manager to handle moving the views
Dialogue: 0,0:32:41.64,0:32:45.01,ch,,0,0,0,,RecyclerView本身是不处理视图滚动的,\N它仅仅预先把信息提供给布局管理器\N{\ren}recycle view doesn't do that for you\Nokay it just gives you the information
Dialogue: 0,0:32:45.01,0:32:47.03,ch,,0,0,0,,以使其自身可以被滚动\N{\ren}up front to be able to do that
Dialogue: 0,0:32:47.03,0:32:52.89,ch,,0,0,0,,因此这些方法在调用的时候会附带着\Nframework根据用户的输入计算出来的信息\N{\ren}so these methods will be called with the information that the framework has determined from the user input
Dialogue: 0,0:32:52.89,0:32:56.16,ch,,0,0,0,,从根本上来讲,这两个方法会循序渐进地被调用,\N每次被调用都会传递给你一个delta值\N{\ren}basically they'll give you a delta value and this is called incrementally
Dialogue: 0,0:32:56.16,0:32:59.53,ch,,0,0,0,,这个值代表着framework所认为的,此时,\N你应当将你的视图平移多远\N{\ren}of how far the framework thinks you should shift your views
Dialogue: 0,0:32:59.53,0:33:03.59,ch,,0,0,0,,当然,这得分横向平移和纵向平移\N{\ren}and of course in which direction horizontally or vertically,ok
Dialogue: 0,0:33:03.59,0:33:05.96,ch,,0,0,0,,\N{\ren}and then it will be up to you to actually do
Dialogue: 0,0:33:05.96,0:33:09.78,ch,,0,0,0,,\N{\ren}the movement as well as making any determinations about boundary conditions
Dialogue: 0,0:33:09.78,0:33:14.57,ch,,0,0,0,,\N{\ren}rate the layout managers responsible for\Ntelling the framework when you hit the
Dialogue: 0,0:33:14.57,0:33:17.21,ch,,0,0,0,,\N{\ren}end of the content any need to stop\Nscrolling
Dialogue: 0,0:33:17.21,0:33:21.50,ch,,0,0,0,,\N{\ren}in that particular direction K now that\Nreport is actually done in the terms the
Dialogue: 0,0:33:21.50,0:33:22.44,ch,,0,0,0,,\N{\ren}return value
Dialogue: 0,0:33:22.44,0:33:26.47,ch,,0,0,0,,\N{\ren}so win whatever value you return from\Nthis function
Dialogue: 0,0:33:26.47,0:33:29.74,ch,,0,0,0,,\N{\ren}designates to the framework how far you\Nactually traveled
Dialogue: 0,0:33:29.74,0:33:32.94,ch,,0,0,0,,\N{\ren}and in the framework will make a\Ndetermination based on how much how far
Dialogue: 0,0:33:32.94,0:33:34.14,ch,,0,0,0,,\N{\ren}it told you to travel
Dialogue: 0,0:33:34.14,0:33:37.79,ch,,0,0,0,,\N{\ren}if there's a difference there it assumes\Nit's had a boundary and it's going to do
Dialogue: 0,0:33:37.79,0:33:39.99,ch,,0,0,0,,\N{\ren}things for you like drawing edge close
Dialogue: 0,0:33:39.99,0:33:44.24,ch,,0,0,0,,\N{\ren}and other edge effect behavior that you\Nprobably don't wanna see if you're not
Dialogue: 0,0:33:44.24,0:33:47.44,ch,,0,0,0,,\N{\ren}all the way at the end yet to be very\Ncareful about how that return value
Dialogue: 0,0:33:47.44,0:33:48.36,ch,,0,0,0,,\N{\ren}actually comes up
Dialogue: 0,0:33:48.36,0:33:51.47,ch,,0,0,0,,\N{\ren}so this is kind of an example
Dialogue: 0,0:33:51.47,0:33:55.67,ch,,0,0,0,,\N{\ren}love what you might see this is a a snap\Nto version of what's in fixed grid for
Dialogue: 0,0:33:55.67,0:33:56.88,ch,,0,0,0,,\N{\ren}scroll horizontally
Dialogue: 0,0:33:56.88,0:33:59.90,ch,,0,0,0,,\N{\ren}so you're given a value that they call\Nin this case Deacs
Dialogue: 0,0:33:59.90,0:34:03.69,ch,,0,0,0,,\N{\ren}thats how far they think you should\Nscroll first thing you have to determine
Dialogue: 0,0:34:03.69,0:34:06.98,ch,,0,0,0,,\N{\ren}perhaps based on which direction that's\Ngrowing occurs is
Dialogue: 0,0:34:06.98,0:34:10.25,ch,,0,0,0,,\N{\ren}can I scroll that far or have I hit a\Nboundary
Dialogue: 0,0:34:10.25,0:34:13.98,ch,,0,0,0,,\N{\ren}and determine how far you're actually\Ngoing to shift now the nice thing is
Dialogue: 0,0:34:13.98,0:34:17.58,ch,,0,0,0,,\N{\ren}you don't have to iterate over the child\Nabuse in individually move them
Dialogue: 0,0:34:17.58,0:34:22.29,ch,,0,0,0,,\N{\ren}recycler be layout manager provides of\Nthese offset children methods both
Dialogue: 0,0:34:22.29,0:34:23.70,ch,,0,0,0,,\N{\ren}horizontal and vertical
Dialogue: 0,0:34:23.70,0:34:28.15,ch,,0,0,0,,\N{\ren}that will do the the work I've shifting\Nall views that are currently attached
Dialogue: 0,0:34:28.15,0:34:31.25,ch,,0,0,0,,\N{\ren}so all you have to determine is the\Nactual difference
Dialogue: 0,0:34:31.25,0:34:35.63,ch,,0,0,0,,\N{\ren}and then just passed that into the\Nmethod but because recycler view doesn't
Dialogue: 0,0:34:35.63,0:34:37.28,ch,,0,0,0,,\N{\ren}really know how your layout looks
Dialogue: 0,0:34:37.28,0:34:41.76,ch,,0,0,0,,\N{\ren}once the views have been moved you may\Nhave created a gap so it's up to you
Dialogue: 0,0:34:41.76,0:34:46.50,ch,,0,0,0,,\N{\ren}to go back and run another Phil K now in\Nmy implementation and you can look at
Dialogue: 0,0:34:46.50,0:34:47.24,ch,,0,0,0,,\N{\ren}the details
Dialogue: 0,0:34:47.24,0:34:51.22,ch,,0,0,0,,\N{\ren}in the example and get her but in my\Nimplementation I actually provided
Dialogue: 0,0:34:51.22,0:34:56.01,ch,,0,0,0,,\N{\ren}direction keyword back to the Phil just\Nto help sort of assessed when I needed
Dialogue: 0,0:34:56.01,0:34:57.10,ch,,0,0,0,,\N{\ren}to shift my
Dialogue: 0,0:34:57.10,0:35:00.88,ch,,0,0,0,,\N{\ren}my positions backwards or forward based\Non which way this rowing was going on
Dialogue: 0,0:35:00.88,0:35:04.78,ch,,0,0,0,,\N{\ren}that's not really required in the\Ntechnique that I'm describing it just
Dialogue: 0,0:35:04.78,0:35:08.13,ch,,0,0,0,,\N{\ren}it was helpful for my bi directional\Nscrolling on
Dialogue: 0,0:35:08.13,0:35:11.86,ch,,0,0,0,,\N{\ren}but it it's not really part A its\Nwhatever your algorithm needs
Dialogue: 0,0:35:11.86,0:35:16.74,ch,,0,0,0,,\N{\ren}a you know to be able to do that in the\Nmost efficient way
Dialogue: 0,0:35:16.74,0:35:19.96,ch,,0,0,0,,\N{\ren}okay and then as I mention the return\Nvalue their
Dialogue: 0,0:35:19.96,0:35:23.85,ch,,0,0,0,,\N{\ren}has to be the difference up what was\Nactually scrolled
Dialogue: 0,0:35:23.85,0:35:27.79,ch,,0,0,0,,\N{\ren}if you just take this a new dish return\NDeacs you'll never end up scrolling
Dialogue: 0,0:35:27.79,0:35:31.50,ch,,0,0,0,,\N{\ren}and if you always return 0 never scroll\Nat all anytime you try to scroll you'll
Dialogue: 0,0:35:31.50,0:35:33.39,ch,,0,0,0,,\N{\ren}just get infinity edge close all the\Ntime
Dialogue: 0,0:35:33.39,0:35:37.52,ch,,0,0,0,,\N{\ren}okay so you have to be very specific\Nabout when you can and when you can't
Dialogue: 0,0:35:37.52,0:35:38.06,ch,,0,0,0,,\N{\ren}move
Dialogue: 0,0:35:38.06,0:35:41.16,ch,,0,0,0,,\N{\ren}based on whether or not you've hit a\Nboundary of your content
Dialogue: 0,0:35:41.16,0:35:45.57,ch,,0,0,0,,\N{\ren}okay at a minimum
Dialogue: 0,0:35:45.57,0:35:49.71,ch,,0,0,0,,\N{\ren}that's it that's all you really need to\Nimplement to get a working
Dialogue: 0,0:35:49.71,0:35:53.77,ch,,0,0,0,,\N{\ren}layout managers something that will lay\Nviews out you can move them around
Dialogue: 0,0:35:53.77,0:35:57.06,ch,,0,0,0,,\N{\ren}you know all the things you would expect\Nfrom user interaction perspective
Dialogue: 0,0:35:57.06,0:36:00.35,ch,,0,0,0,,\N{\ren}other additional features you can add\Nand probably should add
Dialogue: 0,0:36:00.35,0:36:04.24,ch,,0,0,0,,\N{\ren}overtime but thats or to the basics like\Neven get that far you can at least
Dialogue: 0,0:36:04.24,0:36:07.61,ch,,0,0,0,,\N{\ren}determine if your other than works in\Nyour layout functionalities okay and all
Dialogue: 0,0:36:07.61,0:36:09.22,ch,,0,0,0,,\N{\ren}that sort of thing I
Dialogue: 0,0:36:09.22,0:36:12.32,ch,,0,0,0,,\N{\ren}the next step if you have additional\Ntime is
Dialogue: 0,0:36:12.32,0:36:15.39,ch,,0,0,0,,\N{\ren}typically to start reacting to dataset\Nchanges
Dialogue: 0,0:36:15.39,0:36:19.04,ch,,0,0,0,,\N{\ren}cannes is really not a whole lot of work\Nto do here most ovett is built right and
Dialogue: 0,0:36:19.04,0:36:19.39,ch,,0,0,0,,\N{\ren}but
Dialogue: 0,0:36:19.39,0:36:22.94,ch,,0,0,0,,\N{\ren}there is one additional method here\Ncalled on adapter changed
Dialogue: 0,0:36:22.94,0:36:25.95,ch,,0,0,0,,\N{\ren}that you can provide some optimizations\Ninsider
Dialogue: 0,0:36:25.95,0:36:30.45,ch,,0,0,0,,\N{\ren}you don't have to override this but it\Ncan be helpful this will be triggered
Dialogue: 0,0:36:30.45,0:36:34.65,ch,,0,0,0,,\N{\ren}if the recycler view ever is provided\Nwith a completely different
Dialogue: 0,0:36:34.65,0:36:38.92,ch,,0,0,0,,\N{\ren}adapter instance so if their call if\Nthey call said adapter again with some
Dialogue: 0,0:36:38.92,0:36:42.45,ch,,0,0,0,,\N{\ren}other object in this will be called in\Nthe layout manager
Dialogue: 0,0:36:42.45,0:36:45.51,ch,,0,0,0,,\N{\ren}and you can use that for as an\Noptimization opportunity
Dialogue: 0,0:36:45.51,0:36:49.92,ch,,0,0,0,,\N{\ren}to simply clear all the views no notice\NI'm not tossing them to the recycler
Dialogue: 0,0:36:49.92,0:36:53.70,ch,,0,0,0,,\N{\ren}I just want them removed completely the\Nassumption here is that
Dialogue: 0,0:36:53.70,0:36:57.64,ch,,0,0,0,,\N{\ren}if we're getting a completely new\Nadapter it's definitely new data
Dialogue: 0,0:36:57.64,0:37:00.97,ch,,0,0,0,,\N{\ren}and it's probably going to be in your\Nview types as well so there's no need
Dialogue: 0,0:37:00.97,0:37:04.14,ch,,0,0,0,,\N{\ren}for me to dump everything I have into\Nthe recycler cuz this is going to end up
Dialogue: 0,0:37:04.14,0:37:06.06,ch,,0,0,0,,\N{\ren}having a toss those away later anyway
Dialogue: 0,0:37:06.06,0:37:10.72,ch,,0,0,0,,\N{\ren}not that we would break if it did that\Nbut we can optimize that out
Dialogue: 0,0:37:10.72,0:37:13.99,ch,,0,0,0,,\N{\ren}by saying if the adapter changes just\Nremove everything
Dialogue: 0,0:37:13.99,0:37:18.74,ch,,0,0,0,,\N{\ren}bypass the Recycle don't like two\Nhundred dollars K
Dialogue: 0,0:37:18.74,0:37:21.88,ch,,0,0,0,,\N{\ren}now we all know notified is a change in\Nan adapter right
Dialogue: 0,0:37:21.88,0:37:25.92,ch,,0,0,0,,\N{\ren}if if something has changed in the data\Nwe trigger this method to update the
Dialogue: 0,0:37:25.92,0:37:26.26,ch,,0,0,0,,\N{\ren}view
Dialogue: 0,0:37:26.26,0:37:29.84,ch,,0,0,0,,\N{\ren}right was that way in listview still\Nexists in recycler view
Dialogue: 0,0:37:29.84,0:37:34.47,ch,,0,0,0,,\N{\ren}at a at a base implementation you don't\Nhave to do anything different here
Dialogue: 0,0:37:34.47,0:37:38.37,ch,,0,0,0,,\N{\ren}are notified is a change just triggers a\Nnew layout change
Dialogue: 0,0:37:38.37,0:37:41.90,ch,,0,0,0,,\N{\ren}and if your fill a game is set up\Nappropriately uydess relay out
Dialogue: 0,0:37:41.90,0:37:46.91,ch,,0,0,0,,\N{\ren}right the only thing you might want to\Npersist in this is sorted implementation
Dialogue: 0,0:37:46.91,0:37:47.90,ch,,0,0,0,,\N{\ren}dependent is
Dialogue: 0,0:37:47.90,0:37:52.35,ch,,0,0,0,,\N{\ren}for a at for an adapter change you might\Nwanna persist with the current first
Dialogue: 0,0:37:52.35,0:37:53.35,ch,,0,0,0,,\N{\ren}position was
Dialogue: 0,0:37:53.35,0:37:58.01,ch,,0,0,0,,\N{\ren}so you may want to discover that before\Nyou run your fill but again depending on
Dialogue: 0,0:37:58.01,0:38:00.78,ch,,0,0,0,,\N{\ren}how you've written your fill you're\Nprobably already doing that anyway
Dialogue: 0,0:38:00.78,0:38:05.18,ch,,0,0,0,,\N{\ren}so they can attempt with the new data to\Nlay out from the same first visible
Dialogue: 0,0:38:05.18,0:38:05.96,ch,,0,0,0,,\N{\ren}position
Dialogue: 0,0:38:05.96,0:38:10.81,ch,,0,0,0,,\N{\ren}okay but if you if you toss those away\Nalready or something like that you may
Dialogue: 0,0:38:10.81,0:38:12.54,ch,,0,0,0,,\N{\ren}want to track that value
Dialogue: 0,0:38:12.54,0:38:15.90,ch,,0,0,0,,\N{\ren}just very briefly until the new layout\Ncomes around or something like that
Dialogue: 0,0:38:15.90,0:38:18.90,ch,,0,0,0,,\N{\ren}otherwise you could just lay it out from\Nthe beginning it would still work
Dialogue: 0,0:38:18.90,0:38:24.50,ch,,0,0,0,,\N{\ren}the one a caveat to this is that if your\Nadapter has stable ladies
Dialogue: 0,0:38:24.50,0:38:28.76,ch,,0,0,0,,\N{\ren}I recycler view assumes at that point\Nthat it actually has enough data to
Dialogue: 0,0:38:28.76,0:38:30.23,ch,,0,0,0,,\N{\ren}train and meet the change
Dialogue: 0,0:38:30.23,0:38:34.79,ch,,0,0,0,,\N{\ren}and so calling notified is a change will\Ntrigger an animation sequence
Dialogue: 0,0:38:34.79,0:38:38.01,ch,,0,0,0,,\N{\ren}and we'll talk about animations a little\Nbit later but if you if your adapter
Dialogue: 0,0:38:38.01,0:38:39.08,ch,,0,0,0,,\N{\ren}doesn't do that
Dialogue: 0,0:38:39.08,0:38:43.23,ch,,0,0,0,,\N{\ren}this will just be a a snap layout\Ncannibal adjust to the new data
Dialogue: 0,0:38:43.23,0:38:49.16,ch,,0,0,0,,\N{\ren}alright well let's say that we happen to\Nhave a little bit more extra time on our
Dialogue: 0,0:38:49.16,0:38:52.20,ch,,0,0,0,,\N{\ren}hands we want to get a little bit more\Nfancy with this functionality
Dialogue: 0,0:38:52.20,0:38:56.01,ch,,0,0,0,,\N{\ren}I the next feature that we can add to\Nour managers targets growing
Dialogue: 0,0:38:56.01,0:39:00.19,ch,,0,0,0,,\N{\ren}so the at external API's for allowing
Dialogue: 0,0:39:00.19,0:39:03.83,ch,,0,0,0,,\N{\ren}a developer to scroll your layout to a\Nspecific position whether that
Dialogue: 0,0:39:03.83,0:39:04.64,ch,,0,0,0,,\N{\ren}immediately
Dialogue: 0,0:39:04.64,0:39:09.13,ch,,0,0,0,,\N{\ren}or in some animated fashion again are\Nnot baked and you have to provide some
Dialogue: 0,0:39:09.13,0:39:10.81,ch,,0,0,0,,\N{\ren}implementation how that works
Dialogue: 0,0:39:10.81,0:39:14.70,ch,,0,0,0,,\N{\ren}so for the scrolled position case which\Nis a non animated case
Dialogue: 0,0:39:14.70,0:39:18.24,ch,,0,0,0,,\N{\ren}it can be pretty simple just like in the\Ncase I mentioned before
Dialogue: 0,0:39:18.24,0:39:22.17,ch,,0,0,0,,\N{\ren}you would need to track somehow what the\Nrequested position was
Dialogue: 0,0:39:22.17,0:39:26.17,ch,,0,0,0,,\N{\ren}and then just call request layout that\Nwill trigger a new layout which will
Dialogue: 0,0:39:26.17,0:39:28.76,ch,,0,0,0,,\N{\ren}trigger on layout children which you can\Njust do fill
Dialogue: 0,0:39:28.76,0:39:32.01,ch,,0,0,0,,\N{\ren}right so if you can start to see how if\Nyou do your
Dialogue: 0,0:39:32.01,0:39:35.39,ch,,0,0,0,,\N{\ren}bill right it becomes everything to you\Nand you don't have to do a whole lot
Dialogue: 0,0:39:35.39,0:39:37.13,ch,,0,0,0,,\N{\ren}else to sort of decorate around
Dialogue: 0,0:39:37.13,0:39:43.03,ch,,0,0,0,,\N{\ren}K to get a little bit more fancy we have\Nthe smooth scroll to position
Dialogue: 0,0:39:43.03,0:39:46.74,ch,,0,0,0,,\N{\ren}and this is where we would want as a\Ndeveloper we would want the view to
Dialogue: 0,0:39:46.74,0:39:47.30,ch,,0,0,0,,\N{\ren}actually
Dialogue: 0,0:39:47.30,0:39:50.76,ch,,0,0,0,,\N{\ren}animate into place K now the
Dialogue: 0,0:39:50.76,0:39:54.17,ch,,0,0,0,,\N{\ren}the functionality for doing this\Nrequires an implementation of something
Dialogue: 0,0:39:54.17,0:39:57.42,ch,,0,0,0,,\N{\ren}called a smooth scroller this is an\Nabstract class provided by the
Dialogue: 0,0:39:57.42,0:40:01.93,ch,,0,0,0,,\N{\ren}by the framework that you can override\Nand create your own implementation
Dialogue: 0,0:40:01.93,0:40:05.21,ch,,0,0,0,,\N{\ren}have essentially what should happen on\Nan incremental basis
Dialogue: 0,0:40:05.21,0:40:08.59,ch,,0,0,0,,\N{\ren}as it animates around your view trying\Nto find the target
Dialogue: 0,0:40:08.59,0:40:12.83,ch,,0,0,0,,\N{\ren}K this interface is actually fairly\Ncomplex there's
Dialogue: 0,0:40:12.83,0:40:16.78,ch,,0,0,0,,\N{\ren}I'd I can't remember five to 10 methods\Nthat you have to override to make that
Dialogue: 0,0:40:16.78,0:40:17.33,ch,,0,0,0,,\N{\ren}happen
Dialogue: 0,0:40:17.33,0:40:20.39,ch,,0,0,0,,\N{\ren}I you can certainly do that if you're\Nnot a
Dialogue: 0,0:40:20.39,0:40:23.66,ch,,0,0,0,,\N{\ren}if you're not happy with the behavior\Nthat the framework gives you
Dialogue: 0,0:40:23.66,0:40:28.03,ch,,0,0,0,,\N{\ren}but there is an implementation called\Nlinear smooth scroller that is provided
Dialogue: 0,0:40:28.03,0:40:32.52,ch,,0,0,0,,\N{\ren}a in support package that you can just\Ntext and this does most of the work for
Dialogue: 0,0:40:32.52,0:40:33.09,ch,,0,0,0,,\N{\ren}you
Dialogue: 0,0:40:33.09,0:40:36.59,ch,,0,0,0,,\N{\ren}by providing a linearly interpolated\Nanimation
Dialogue: 0,0:40:36.59,0:40:39.99,ch,,0,0,0,,\N{\ren}on its way to whatever the target\Nposition yes and the only piece of
Dialogue: 0,0:40:39.99,0:40:42.19,ch,,0,0,0,,\N{\ren}information you have to provide in this\Ncase
Dialogue: 0,0:40:42.19,0:40:46.35,ch,,0,0,0,,\N{\ren}is where is the target position and\Nthat's from a cordon its perspective
Dialogue: 0,0:40:46.35,0:40:50.85,ch,,0,0,0,,\N{\ren}so when when this method is called\Nsmooth scroll the position you basically
Dialogue: 0,0:40:50.85,0:40:53.89,ch,,0,0,0,,\N{\ren}have to figure out what's the first\Nvisible position I have now
Dialogue: 0,0:40:53.89,0:40:57.94,ch,,0,0,0,,\N{\ren}what's the target that they're trying to\Nget to and then this computation what
Dialogue: 0,0:40:57.94,0:40:59.10,ch,,0,0,0,,\N{\ren}they call a vector
Dialogue: 0,0:40:59.10,0:41:02.10,ch,,0,0,0,,\N{\ren}on what is the direction that I need to\Nscroll to get there
Dialogue: 0,0:41:02.10,0:41:06.14,ch,,0,0,0,,\N{\ren}is at left is that right is it up is it\Ndown to the diagonal but has to be some
Dialogue: 0,0:41:06.14,0:41:07.19,ch,,0,0,0,,\N{\ren}linear value
Dialogue: 0,0:41:07.19,0:41:11.33,ch,,0,0,0,,\N{\ren}guy and so you would typically figure\Nout what's the conceptual distance
Dialogue: 0,0:41:11.33,0:41:12.33,ch,,0,0,0,,\N{\ren}between the two
Dialogue: 0,0:41:12.33,0:41:15.69,ch,,0,0,0,,\N{\ren}based on you know whatever guess you can\Nput together
Dialogue: 0,0:41:15.69,0:41:19.58,ch,,0,0,0,,\N{\ren}in my case all these are the same size\Nso I can have a really good guess
Dialogue: 0,0:41:19.58,0:41:21.92,ch,,0,0,0,,\N{\ren}because I knew exactly how far would\Nneed to travel
Dialogue: 0,0:41:21.92,0:41:25.16,ch,,0,0,0,,\N{\ren}but that may not necessarily be the case\Nit doesn't have to be the exact distance
Dialogue: 0,0:41:25.16,0:41:26.75,ch,,0,0,0,,\N{\ren}it just has to know the direction
Dialogue: 0,0:41:26.75,0:41:30.56,ch,,0,0,0,,\N{\ren}and then when your smile scroller is\Ngonna go through and run an incremental
Dialogue: 0,0:41:30.56,0:41:31.31,ch,,0,0,0,,\N{\ren}fashion
Dialogue: 0,0:41:31.31,0:41:34.74,ch,,0,0,0,,\N{\ren}they're gonna walk through they're just\Ngoing to incrementally animate
Dialogue: 0,0:41:34.74,0:41:38.24,ch,,0,0,0,,\N{\ren}and scroll in whatever direction it\Nneeds to get to that position
Dialogue: 0,0:41:38.24,0:41:41.95,ch,,0,0,0,,\N{\ren}and it'll scroll can't see if it's been\Nlaid out scroll again
Dialogue: 0,0:41:41.95,0:41:45.54,ch,,0,0,0,,\N{\ren}see if it's been laid out its just gonna\Nhunt and hunt until
Dialogue: 0,0:41:45.54,0:41:49.76,ch,,0,0,0,,\N{\ren}the position that it's interested in has\Nfinally come into the layout which is
Dialogue: 0,0:41:49.76,0:41:52.06,ch,,0,0,0,,\N{\ren}going to be triggering your scroll\Nmethod that you've already written
Dialogue: 0,0:41:52.06,0:41:55.27,ch,,0,0,0,,\N{\ren}an innocent as it finds that value then\Nit will stop scrolling
Dialogue: 0,0:41:55.27,0:41:59.40,ch,,0,0,0,,\N{\ren}wanted that fully visible on on the\Ndisplay at that point then it will just
Dialogue: 0,0:41:59.40,0:42:02.48,ch,,0,0,0,,\N{\ren}your and K so you can override the SMA\Nscroller
Dialogue: 0,0:42:02.48,0:42:06.84,ch,,0,0,0,,\N{\ren}set the target position and to start it\Nand that's really the simplest and
Dialogue: 0,0:42:06.84,0:42:12.21,ch,,0,0,0,,\N{\ren}the implementation to animated scrolling\NK alright
Dialogue: 0,0:42:12.21,0:42:15.90,ch,,0,0,0,,\N{\ren}the last piece if you have a lot extra\Ntime
Dialogue: 0,0:42:15.90,0:42:20.29,ch,,0,0,0,,\N{\ren}and maybe some sanity left you can\Nattempt
Dialogue: 0,0:42:20.29,0:42:23.67,ch,,0,0,0,,\N{\ren}to add some animation support now out of\Nthe box
Dialogue: 0,0:42:23.67,0:42:27.02,ch,,0,0,0,,\N{\ren}recycler view does support what they\Ncalled defile to fault
Dialogue: 0,0:42:27.02,0:42:31.70,ch,,0,0,0,,\N{\ren}item animations K where the new features\Na recycler view that was not as easy to
Dialogue: 0,0:42:31.70,0:42:33.59,ch,,0,0,0,,\N{\ren}implement something like this view was
Dialogue: 0,0:42:33.59,0:42:37.03,ch,,0,0,0,,\N{\ren}if you inserted a new item or removed it\Nor made some changes
Dialogue: 0,0:42:37.03,0:42:40.28,ch,,0,0,0,,\N{\ren}animating all that in a nice fancy way\Nfor the user
Dialogue: 0,0:42:40.28,0:42:44.83,ch,,0,0,0,,\N{\ren}K the the functionality with all the\Ncore layout managers
Dialogue: 0,0:42:44.83,0:42:48.42,ch,,0,0,0,,\N{\ren}is to provide a very basic algorithm for\Nthat out of the box
Dialogue: 0,0:42:48.42,0:42:51.54,ch,,0,0,0,,\N{\ren}and have an animation to show you what\Nthat looks like but essentially it just
Dialogue: 0,0:42:51.54,0:42:52.69,ch,,0,0,0,,\N{\ren}looks at the views
Dialogue: 0,0:42:52.69,0:42:57.35,ch,,0,0,0,,\N{\ren}looks at the change before and after and\Nthen tries to determine based on this
Dialogue: 0,0:42:57.35,0:42:59.69,ch,,0,0,0,,\N{\ren}layout in this layout in the two\Nsnapshots
Dialogue: 0,0:42:59.69,0:43:03.76,ch,,0,0,0,,\N{\ren}what pews have gone away what use are\Nnew and what you have moved around
Dialogue: 0,0:43:03.76,0:43:07.09,ch,,0,0,0,,\N{\ren}and it will fade out the old views fade\Nin the new views in
Dialogue: 0,0:43:07.09,0:43:10.20,ch,,0,0,0,,\N{\ren}simply translate the other ones on\Nscreen okay
Dialogue: 0,0:43:10.20,0:43:14.08,ch,,0,0,0,,\N{\ren}and in a lot of cases it does a pretty\Ngood job but you'll see there are some
Dialogue: 0,0:43:14.08,0:43:17.78,ch,,0,0,0,,\N{\ren}problems with what you get for free if\Nyou're doing a custom layout because you
Dialogue: 0,0:43:17.78,0:43:18.48,ch,,0,0,0,,\N{\ren}may be
Dialogue: 0,0:43:18.48,0:43:23.22,ch,,0,0,0,,\N{\ren}animating views off-screen that because\Nthey're no longer there the default
Dialogue: 0,0:43:23.22,0:43:25.33,ch,,0,0,0,,\N{\ren}animation just thinks they've\Ndisappeared
Dialogue: 0,0:43:25.33,0:43:29.27,ch,,0,0,0,,\N{\ren}so it fades them out incident gracefully\Nmoving them to where they conceptually
Dialogue: 0,0:43:29.27,0:43:30.33,ch,,0,0,0,,\N{\ren}were supposed to go
Dialogue: 0,0:43:30.33,0:43:35.58,ch,,0,0,0,,\N{\ren}K and so we'll take a look at what you\Nneed to do to Sir provide that so
Dialogue: 0,0:43:35.58,0:43:40.29,ch,,0,0,0,,\N{\ren}and recalls that predictive item\Nanimations and if you want to support
Dialogue: 0,0:43:40.29,0:43:41.54,ch,,0,0,0,,\N{\ren}that in your layout manager
Dialogue: 0,0:43:41.54,0:43:45.34,ch,,0,0,0,,\N{\ren}you just have to tell them to say yes I\Nsupport predictive animations return
Dialogue: 0,0:43:45.34,0:43:46.38,ch,,0,0,0,,\N{\ren}trip from this method
Dialogue: 0,0:43:46.38,0:43:49.74,ch,,0,0,0,,\N{\ren}and this will change your layout\Nbehavior just a little bit
Dialogue: 0,0:43:49.74,0:43:54.35,ch,,0,0,0,,\N{\ren}in this case anytime in item changes\Ntriggered
Dialogue: 0,0:43:54.35,0:43:57.61,ch,,0,0,0,,\N{\ren}now for an initial layout or anything\Nlike that still gonna be the same
Dialogue: 0,0:43:57.61,0:43:58.27,ch,,0,0,0,,\N{\ren}but you
Dialogue: 0,0:43:58.27,0:44:02.12,ch,,0,0,0,,\N{\ren}moving item or you insert and item\Nsomething like that and that item is
Dialogue: 0,0:44:02.12,0:44:02.91,ch,,0,0,0,,\N{\ren}visible
Dialogue: 0,0:44:02.91,0:44:07.05,ch,,0,0,0,,\N{\ren}at the moment then the layout process\Nactually becomes a
Dialogue: 0,0:44:07.05,0:44:10.07,ch,,0,0,0,,\N{\ren}to pass layout it calls on layout
Dialogue: 0,0:44:10.07,0:44:13.98,ch,,0,0,0,,\N{\ren}children first in what they called the\Npre layout state
Dialogue: 0,0:44:13.98,0:44:18.19,ch,,0,0,0,,\N{\ren}this is a state where all the views all\Nthe data from the adapter
Dialogue: 0,0:44:18.19,0:44:22.23,ch,,0,0,0,,\N{\ren}is massage such that it looks the way it\Nwould have looked
Dialogue: 0,0:44:22.23,0:44:26.47,ch,,0,0,0,,\N{\ren}before the change this gives you an\Nopportunity to run a layout pass
Dialogue: 0,0:44:26.47,0:44:29.72,ch,,0,0,0,,\N{\ren}in what they call the pre layout or the\Nthe initial snapshot
Dialogue: 0,0:44:29.72,0:44:34.34,ch,,0,0,0,,\N{\ren}K so from from the views on screen\Nperspective this means you just
Dialogue: 0,0:44:34.34,0:44:37.66,ch,,0,0,0,,\N{\ren}run your traditional Phil but you might\Nneed 10
Dialogue: 0,0:44:37.66,0:44:41.93,ch,,0,0,0,,\N{\ren}make note if any interviews that were\Non-screen were removed
Dialogue: 0,0:44:41.93,0:44:47.25,ch,,0,0,0,,\N{\ren}you've got gaps to fill and if you just\Nlet the default animations do their work
Dialogue: 0,0:44:47.25,0:44:50.70,ch,,0,0,0,,\N{\ren}they will animate until they can see\Nthat gap in the notice paid the new view
Dialogue: 0,0:44:50.70,0:44:51.10,ch,,0,0,0,,\N{\ren}n
Dialogue: 0,0:44:51.10,0:44:54.61,ch,,0,0,0,,\N{\ren}but if you wanna make it look like the\Nview actually slides into place
Dialogue: 0,0:44:54.61,0:44:57.66,ch,,0,0,0,,\N{\ren}you have to lay it out during this pass
Dialogue: 0,0:44:57.66,0:45:01.30,ch,,0,0,0,,\N{\ren}and you lay it out in the location of\Nscreen where it should come from
Dialogue: 0,0:45:01.30,0:45:04.86,ch,,0,0,0,,\N{\ren}K so those are what they call appearing\Nviews
Dialogue: 0,0:45:04.86,0:45:08.73,ch,,0,0,0,,\N{\ren}and they give you additional information\Non the layout parameters which you can
Dialogue: 0,0:45:08.73,0:45:09.87,ch,,0,0,0,,\N{\ren}get from the view holder
Dialogue: 0,0:45:09.87,0:45:13.95,ch,,0,0,0,,\N{\ren}for each individual view as to whether\Nor not this view that you can see
Dialogue: 0,0:45:13.95,0:45:18.03,ch,,0,0,0,,\N{\ren}has actually been removed in the next\Nstep it's gone and if that's the case
Dialogue: 0,0:45:18.03,0:45:19.10,ch,,0,0,0,,\N{\ren}you say wow I've got
Dialogue: 0,0:45:19.10,0:45:22.20,ch,,0,0,0,,\N{\ren}maybe two or three views that were\Nremoved I need to make sure
Dialogue: 0,0:45:22.20,0:45:26.43,ch,,0,0,0,,\N{\ren}I add two or three appearing views in\Nwherever they should be so that the
Dialogue: 0,0:45:26.43,0:45:29.30,ch,,0,0,0,,\N{\ren}animation brings them in the way they're\Nsupposed to look
Dialogue: 0,0:45:29.30,0:45:33.39,ch,,0,0,0,,\N{\ren}okay you want to take note of how many\Nremoved so that you can use that for the
Dialogue: 0,0:45:33.39,0:45:34.24,ch,,0,0,0,,\N{\ren}appearing views
Dialogue: 0,0:45:34.24,0:45:37.60,ch,,0,0,0,,\N{\ren}the other thing that you would typically\Ndo during this step
Dialogue: 0,0:45:37.60,0:45:41.38,ch,,0,0,0,,\N{\ren}is take some stock up what's currently\Nin the layout
Dialogue: 0,0:45:41.38,0:45:45.62,ch,,0,0,0,,\N{\ren}so that after the fact you can determine\Nif any are the views
Dialogue: 0,0:45:45.62,0:45:49.91,ch,,0,0,0,,\N{\ren}had been that weren't miss explicitly\Nremoved are no longer in the layout
Dialogue: 0,0:45:49.91,0:45:50.99,ch,,0,0,0,,\N{\ren}because they shifted
Dialogue: 0,0:45:50.99,0:45:54.02,ch,,0,0,0,,\N{\ren}off-screen and if that's the case you\Nneed to lay them out
Dialogue: 0,0:45:54.02,0:45:57.15,ch,,0,0,0,,\N{\ren}during the second phase which is the the\Nregular layout
Dialogue: 0,0:45:57.15,0:46:00.18,ch,,0,0,0,,\N{\ren}phase in their off-screen positions K
Dialogue: 0,0:46:00.18,0:46:03.20,ch,,0,0,0,,\N{\ren}so during pre layout you have to lay out\Nthose appearing views
Dialogue: 0,0:46:03.20,0:46:06.55,ch,,0,0,0,,\N{\ren}and just take note up what the stated\Nthat snapshot its
Dialogue: 0,0:46:06.55,0:46:08.68,ch,,0,0,0,,\N{\ren}and then run your fill the way you\Nnormally
Dialogue: 0,0:46:08.68,0:46:12.92,ch,,0,0,0,,\N{\ren}a word then that methods gonna be called\Nagain in this case that
Dialogue: 0,0:46:12.92,0:46:16.43,ch,,0,0,0,,\N{\ren}is pre layout is gonna be set to false\Nand this is no different than any other
Dialogue: 0,0:46:16.43,0:46:17.17,ch,,0,0,0,,\N{\ren}Phil
Dialogue: 0,0:46:17.17,0:46:20.64,ch,,0,0,0,,\N{\ren}now all the adapter positions in all the\Nvalues are set the way they are
Dialogue: 0,0:46:20.64,0:46:24.05,ch,,0,0,0,,\N{\ren}after the change and you can lay\Neverything out and then you just have
Dialogue: 0,0:46:24.05,0:46:25.28,ch,,0,0,0,,\N{\ren}that final step
Dialogue: 0,0:46:25.28,0:46:29.14,ch,,0,0,0,,\N{\ren}saying OK at this point I don't need\Nthis P senator
Dialogue: 0,0:46:29.14,0:46:33.61,ch,,0,0,0,,\N{\ren}this piece has gone away I need to lay\Nit out of screen so that the animation
Dialogue: 0,0:46:33.61,0:46:35.14,ch,,0,0,0,,\N{\ren}can slide in the right direction
Dialogue: 0,0:46:35.14,0:46:39.46,ch,,0,0,0,,\N{\ren}K let's
Dialogue: 0,0:46:39.46,0:46:43.19,ch,,0,0,0,,\N{\ren}a take a look at a quick example here\Nyou can get an idea there so
Dialogue: 0,0:46:43.19,0:46:47.92,ch,,0,0,0,,\N{\ren}now you're on layout children might look\Na little bit more complicated right
Dialogue: 0,0:46:47.92,0:46:51.27,ch,,0,0,0,,\N{\ren}so during pre layout is where you're\Ngoing to make that information
Dialogue: 0,0:46:51.27,0:46:54.30,ch,,0,0,0,,\N{\ren}check that information about how many\Nviews were actually removed
Dialogue: 0,0:46:54.30,0:46:58.34,ch,,0,0,0,,\N{\ren}were there any if there was a view\Nremoved then I need to account for that
Dialogue: 0,0:46:58.34,0:47:01.89,ch,,0,0,0,,\N{\ren}by adding some appearing logic so
Dialogue: 0,0:47:01.89,0:47:05.93,ch,,0,0,0,,\N{\ren}in in my implementation if you look at\Nthe example I added that to the sill
Dialogue: 0,0:47:05.93,0:47:10.06,ch,,0,0,0,,\N{\ren}so the fill his also passed if there are\Nany additional appearing to use that it
Dialogue: 0,0:47:10.06,0:47:10.81,ch,,0,0,0,,\N{\ren}needs to add
Dialogue: 0,0:47:10.81,0:47:14.26,ch,,0,0,0,,\N{\ren}and it lays those out in addition to\Nwhat it would otherwise be able to see
Dialogue: 0,0:47:14.26,0:47:18.10,ch,,0,0,0,,\N{\ren}okay so that's kind of hidden in here\Nand similarly
Dialogue: 0,0:47:18.10,0:47:21.18,ch,,0,0,0,,\N{\ren}we can look after pre layout after we've
Dialogue: 0,0:47:21.18,0:47:26.08,ch,,0,0,0,,\N{\ren}at dawn are still for real and we can\Ncheck that scrap list again and say was
Dialogue: 0,0:47:26.08,0:47:27.68,ch,,0,0,0,,\N{\ren}there anything that was left in scrap
Dialogue: 0,0:47:27.68,0:47:32.78,ch,,0,0,0,,\N{\ren}if there was then those are actually\Ndisappearing pews they were removed
Dialogue: 0,0:47:32.78,0:47:36.20,ch,,0,0,0,,\N{\ren}or and they you anything like that so we\Nlay them out again
Dialogue: 0,0:47:36.20,0:47:40.88,ch,,0,0,0,,\N{\ren}so you you could run to fill what but\Nusually easier is just too abstract that
Dialogue: 0,0:47:40.88,0:47:43.67,ch,,0,0,0,,\N{\ren}layout logic in call it again for that\Nspecific view
Dialogue: 0,0:47:43.67,0:47:47.06,ch,,0,0,0,,\N{\ren}and figure out this is where the view\Nshould be off-screen K
Dialogue: 0,0:47:47.06,0:47:51.74,ch,,0,0,0,,\N{\ren}alright to discreetly show you what that\Ndifference looks like
Dialogue: 0,0:47:51.74,0:47:56.16,ch,,0,0,0,,\N{\ren}presso with default item animations on\Nthe example that I had
Dialogue: 0,0:47:56.16,0:47:59.94,ch,,0,0,0,,\N{\ren}this is kind of what you get and you can\Nyou can see how it's not exactly what we
Dialogue: 0,0:47:59.94,0:48:02.28,ch,,0,0,0,,\N{\ren}were looking for. so in this case the\Nred byu
Dialogue: 0,0:48:02.28,0:48:05.70,ch,,0,0,0,,\N{\ren}is the one we're going to remove and the\Ngreen views are the ones that should
Dialogue: 0,0:48:05.70,0:48:08.77,ch,,0,0,0,,\N{\ren}shift location but they don't quite do\Nwhat they're supposed to
Dialogue: 0,0:48:08.77,0:48:12.33,ch,,0,0,0,,\N{\ren}right so when we remove this view what\Nhappens is that
Dialogue: 0,0:48:12.33,0:48:15.55,ch,,0,0,0,,\N{\ren}all the views on the left also fade out
Dialogue: 0,0:48:15.55,0:48:19.17,ch,,0,0,0,,\N{\ren}and then they fade in in their new\Nlocations
Dialogue: 0,0:48:19.17,0:48:22.40,ch,,0,0,0,,\N{\ren}and that's because it does the recycler\Nview doesn't know any better
Dialogue: 0,0:48:22.40,0:48:25.68,ch,,0,0,0,,\N{\ren}he just knows that after pre layout they\Nweren't there anymore
Dialogue: 0,0:48:25.68,0:48:29.18,ch,,0,0,0,,\N{\ren}and then it when I scroll over to see\Nwhere they actually are
Dialogue: 0,0:48:29.18,0:48:34.01,ch,,0,0,0,,\N{\ren}they'll show up there in the new layout\NK by adding proper predictive animation
Dialogue: 0,0:48:34.01,0:48:37.95,ch,,0,0,0,,\N{\ren}support I can modify that behavior and\Nagain this is the way the example
Dialogue: 0,0:48:37.95,0:48:39.02,ch,,0,0,0,,\N{\ren}actually works if you go
Dialogue: 0,0:48:39.02,0:48:42.99,ch,,0,0,0,,\N{\ren}run it I can modify their behaviors that\Nthose green views
Dialogue: 0,0:48:42.99,0:48:46.26,ch,,0,0,0,,\N{\ren}slide off-screen to where they're\Nsupposed to go
Dialogue: 0,0:48:46.26,0:48:50.33,ch,,0,0,0,,\N{\ren}into that direction que nos from the\Nuser screen I'll probably just slight
Dialogue: 0,0:48:50.33,0:48:53.29,ch,,0,0,0,,\N{\ren}off-screen unless it is a large enough\Ndisplay for the next we see the whole
Dialogue: 0,0:48:53.29,0:48:53.78,ch,,0,0,0,,\N{\ren}thing
Dialogue: 0,0:48:53.78,0:48:56.78,ch,,0,0,0,,\N{\ren}but in that case they actually
Dialogue: 0,0:48:56.78,0:49:01.21,ch,,0,0,0,,\N{\ren}that you get the benefit love the user\Nseeing where they should go
Dialogue: 0,0:49:01.21,0:49:05.34,ch,,0,0,0,,\N{\ren}so that when they scroll over they're\Nactually there right it's that idea of
Dialogue: 0,0:49:05.34,0:49:08.61,ch,,0,0,0,,\N{\ren}teaching the user how things are\Nsupposed to go by animating them to the
Dialogue: 0,0:49:08.61,0:49:09.72,ch,,0,0,0,,\N{\ren}proper locations
Dialogue: 0,0:49:09.72,0:49:12.83,ch,,0,0,0,,\N{\ren}if they just of a doubt they might think\Nthey remove them all which is not
Dialogue: 0,0:49:12.83,0:49:13.51,ch,,0,0,0,,\N{\ren}correct
Dialogue: 0,0:49:13.51,0:49:18.22,ch,,0,0,0,,\N{\ren}K so that's the idea behind implementing\Npredictive item animations to give you
Dialogue: 0,0:49:18.22,0:49:19.01,ch,,0,0,0,,\N{\ren}some better intro
Dialogue: 0,0:49:19.01,0:49:22.33,ch,,0,0,0,,\N{\ren}okay so
Dialogue: 0,0:49:22.33,0:49:26.11,ch,,0,0,0,,\N{\ren}couple more pieces of information to\Nwrap up here so
Dialogue: 0,0:49:26.11,0:49:30.09,ch,,0,0,0,,\N{\ren}the example that I've been discussing\Nhere I is on my get her page
Dialogue: 0,0:49:30.09,0:49:34.70,ch,,0,0,0,,\N{\ren}that application also has a few other\Nbasic samples in it for using the grid
Dialogue: 0,0:49:34.70,0:49:38.59,ch,,0,0,0,,\N{\ren}layout managers and things like that but\Nhas the full source code for that fixed
Dialogue: 0,0:49:38.59,0:49:41.15,ch,,0,0,0,,\N{\ren}grid implementations you can dive into\Nall that
Dialogue: 0,0:49:41.15,0:49:45.91,ch,,0,0,0,,\N{\ren}carry details if you're interested I\Nalso went through a series a fairly
Dialogue: 0,0:49:45.91,0:49:48.74,ch,,0,0,0,,\N{\ren}detailed blog posts as I was building\Nthat thing
Dialogue: 0,0:49:48.74,0:49:52.65,ch,,0,0,0,,\N{\ren}so if you wanna get a sense for how much\Ncarry actually tore out while doing this
Dialogue: 0,0:49:52.65,0:49:53.97,ch,,0,0,0,,\N{\ren}you can go through and read that
Dialogue: 0,0:49:53.97,0:49:59.08,ch,,0,0,0,,\N{\ren}specifically if you're doing anything\Nsimilar to what I did with that
Dialogue: 0,0:49:59.08,0:50:03.27,ch,,0,0,0,,\N{\ren}that sort of disconnected range where\Nthe grid and what you're seeing
Dialogue: 0,0:50:03.27,0:50:07.04,ch,,0,0,0,,\N{\ren}is actually just a subset up the overall\Nlayout but the views that are in between
Dialogue: 0,0:50:07.04,0:50:09.10,ch,,0,0,0,,\N{\ren}are actually in the middle of the range
Dialogue: 0,0:50:09.10,0:50:12.17,ch,,0,0,0,,\N{\ren}which you wouldn't typically have with\Nthe linear you might want to read the
Dialogue: 0,0:50:12.17,0:50:12.83,ch,,0,0,0,,\N{\ren}last
Dialogue: 0,0:50:12.83,0:50:16.71,ch,,0,0,0,,\N{\ren}blog post that I call the redox where I\Nactually discuss some other bugs and
Dialogue: 0,0:50:16.71,0:50:20.29,ch,,0,0,0,,\N{\ren}issues with the layout manager API that\Nactually makes that implementation much
Dialogue: 0,0:50:20.29,0:50:21.70,ch,,0,0,0,,\N{\ren}more difficult than it should be
Dialogue: 0,0:50:21.70,0:50:24.98,ch,,0,0,0,,\N{\ren}and some other things you have to do to\Nwork around that if you're doing a much
Dialogue: 0,0:50:24.98,0:50:28.43,ch,,0,0,0,,\N{\ren}more simpler implementation that either\Nsingle accessor doesn't have that
Dialogue: 0,0:50:28.43,0:50:29.70,ch,,0,0,0,,\N{\ren}disconnection problem
Dialogue: 0,0:50:29.70,0:50:33.73,ch,,0,0,0,,\N{\ren}then you won't have any issues like that\Nbut it might be an interesting read
Dialogue: 0,0:50:33.73,0:50:36.69,ch,,0,0,0,,\N{\ren}and then the STK also has some pretty\Ngood documentation and is getting you
Dialogue: 0,0:50:36.69,0:50:37.34,ch,,0,0,0,,\N{\ren}started
Dialogue: 0,0:50:37.34,0:50:40.34,ch,,0,0,0,,\N{\ren}with recycler view their okay
Dialogue: 0,0:50:40.34,0:50:43.67,ch,,0,0,0,,\N{\ren}so looking at the time I don't know that\Nwe have
Dialogue: 0,0:50:43.67,0:50:47.99,ch,,0,0,0,,\N{\ren}any time for questions couple okay
Dialogue: 0,0:50:47.99,0:50:52.99,ch,,0,0,0,,\N{\ren}it will take a couple questions and then\Nif there anymore or can walk a state so
Dialogue: 0,0:50:52.99,0:50:57.06,ch,,0,0,0,,\N{\ren}I saw him first up
Dialogue: 0,0:50:57.06,0:51:02.55,ch,,0,0,0,,\N{\ren}me
Dialogue: 0,0:51:02.55,0:51:18.29,ch,,0,0,0,,\N{\ren}we remember they don't affect the\Ndecorators
Dialogue: 0,0:51:18.29,0:51:25.49,ch,,0,0,0,,\N{\ren}clip their for
Dialogue: 0,0:51:25.49,0:51:33.73,ch,,0,0,0,,\N{\ren}truth
Dialogue: 0,0:51:33.73,0:51:34.99,ch,,0,0,0,,\N{\ren}that's correct the other
Dialogue: 0,0:51:34.99,0:51:39.00,ch,,0,0,0,,\N{\ren}the the information because you\Ndepending on how you implement the
Dialogue: 0,0:51:39.00,0:51:40.05,ch,,0,0,0,,\N{\ren}actual decorator
Dialogue: 0,0:51:40.05,0:51:44.23,ch,,0,0,0,,\N{\ren}if you're using that information have\Nbasically what's the height or the with
Dialogue: 0,0:51:44.23,0:51:46.38,ch,,0,0,0,,\N{\ren}the child to know where to draw those\Nlines
Dialogue: 0,0:51:46.38,0:51:49.55,ch,,0,0,0,,\N{\ren}that information is not updated\Nincrementally
Dialogue: 0,0:51:49.55,0:51:53.05,ch,,0,0,0,,\N{\ren}I'm so it's only gonna be updated when\Nits in its initial state
Dialogue: 0,0:51:53.05,0:51:56.17,ch,,0,0,0,,\N{\ren}and then after the change it should give\Nyou the new information so
Dialogue: 0,0:51:56.17,0:52:00.66,ch,,0,0,0,,\N{\ren}you might see it jump into words proper\Nposition as but it won't transition like
Dialogue: 0,0:52:00.66,0:52:02.81,ch,,0,0,0,,\N{\ren}that because that information is not
Dialogue: 0,0:52:02.81,0:52:06.34,ch,,0,0,0,,\N{\ren}are you if I called again get decorated\Nheight on that view
Dialogue: 0,0:52:06.34,0:52:09.52,ch,,0,0,0,,\N{\ren}on each of those instances it's not\Ngoing to change until the
Dialogue: 0,0:52:09.52,0:52:13.47,ch,,0,0,0,,\N{\ren}the values actually its new state cuz\Nfrom a from that perspective
Dialogue: 0,0:52:13.47,0:52:17.29,ch,,0,0,0,,\N{\ren}the height itself is not incremental it\Nhas its initial state and its final
Dialogue: 0,0:52:17.29,0:52:19.15,ch,,0,0,0,,\N{\ren}state joining the changes the drawing
Dialogue: 0,0:52:19.15,0:52:23.40,ch,,0,0,0,,\N{\ren}so you have to you have to somehow\Nlisten for that event
Dialogue: 0,0:52:23.40,0:52:26.47,ch,,0,0,0,,\N{\ren}and try to trigger it manually which you\Ncan do I
Dialogue: 0,0:52:26.47,0:52:30.55,ch,,0,0,0,,\N{\ren}the layout manager does have a handful\Nmethods for on item removed added answer
Dialogue: 0,0:52:30.55,0:52:31.44,ch,,0,0,0,,\N{\ren}to that sort of thing
Dialogue: 0,0:52:31.44,0:52:34.83,ch,,0,0,0,,\N{\ren}that can signal you win that event is\Noccurring
Dialogue: 0,0:52:34.83,0:52:38.40,ch,,0,0,0,,\N{\ren}so that you can strike a match it as\Nbest you can with your animation
Dialogue: 0,0:52:38.40,0:52:42.65,ch,,0,0,0,,\N{\ren}but otherwise that ya unfortunately it\Ndoesn't give you that feedback directly
Dialogue: 0,0:52:42.65,0:52:43.55,ch,,0,0,0,,\N{\ren}in the decorator
Dialogue: 0,0:52:43.55,0:52:47.08,ch,,0,0,0,,\N{\ren}yes obsolete
Dialogue: 0,0:52:47.08,0:52:50.89,ch,,0,0,0,,\N{\ren}I'll keeps Las the
Dialogue: 0,0:52:50.89,0:52:55.83,ch,,0,0,0,,\N{\ren}here that
Dialogue: 0,0:52:55.83,0:52:59.49,ch,,0,0,0,,\N{\ren}she eighty
Dialogue: 0,0:52:59.49,0:53:03.54,ch,,0,0,0,,\N{\ren}aim to be fully Steelers if you can\Nmanage it in my
Dialogue: 0,0:53:03.54,0:53:07.32,ch,,0,0,0,,\N{\ren}so I'll give you an example from the way\NI built it so the initial implementation
Dialogue: 0,0:53:07.32,0:53:07.97,ch,,0,0,0,,\N{\ren}iro
Dialogue: 0,0:53:07.97,0:53:12.16,ch,,0,0,0,,\N{\ren}I am I track very heavily things like\Nthe first visible position
Dialogue: 0,0:53:12.16,0:53:15.18,ch,,0,0,0,,\N{\ren}and that position offset and I kept that\Nstate around
Dialogue: 0,0:53:15.18,0:53:19.68,ch,,0,0,0,,\N{\ren}all the time and win when we started\Ndoing dataset changes where we went from
Dialogue: 0,0:53:19.68,0:53:23.29,ch,,0,0,0,,\N{\ren}like a really large grid to really small\Ngreater something like that a
Dialogue: 0,0:53:23.29,0:53:26.53,ch,,0,0,0,,\N{\ren}trying to assume that that value was\Neven valid anymore
Dialogue: 0,0:53:26.53,0:53:29.94,ch,,0,0,0,,\N{\ren}lead to a long list if statements well\Nif I shifted
Dialogue: 0,0:53:29.94,0:53:33.58,ch,,0,0,0,,\N{\ren}all the way down and leadership back but\Nif I shifted from here I need to do this
Dialogue: 0,0:53:33.58,0:53:38.38,ch,,0,0,0,,\N{\ren}and if I had just basically run a new\NPhil we're at that point I say okay
Dialogue: 0,0:53:38.38,0:53:39.68,ch,,0,0,0,,\N{\ren}based on what I've got
Dialogue: 0,0:53:39.68,0:53:41.91,ch,,0,0,0,,\N{\ren}what am I supposed to be able to see
Dialogue: 0,0:53:41.91,0:53:46.67,ch,,0,0,0,,\N{\ren}it would have been a much simpler flow\Nso I mean as far as good state to track
Dialogue: 0,0:53:46.67,0:53:50.10,ch,,0,0,0,,\N{\ren}that mean the only thing that I would\Nrecommend in a basic implementation you
Dialogue: 0,0:53:50.10,0:53:50.60,ch,,0,0,0,,\N{\ren}track
Dialogue: 0,0:53:50.60,0:53:53.80,ch,,0,0,0,,\N{\ren}is any target positions your you're\Nmoving towards
Dialogue: 0,0:53:53.80,0:53:57.52,ch,,0,0,0,,\N{\ren}so if you're doing a linear scroll or if\Nyou doing scroll to position and you're
Dialogue: 0,0:53:57.52,0:54:00.67,ch,,0,0,0,,\N{\ren}going to get a new layout past you kinda\Nhave to track
Dialogue: 0,0:54:00.67,0:54:03.70,ch,,0,0,0,,\N{\ren}where you wanna go cuz that's not passed\Naround for you
Dialogue: 0,0:54:03.70,0:54:06.96,ch,,0,0,0,,\N{\ren}but in general anything about the\Ncurrent state of the layout
Dialogue: 0,0:54:06.96,0:54:10.06,ch,,0,0,0,,\N{\ren}if you can get away with it and in most\Ncases I think you should be able to
Dialogue: 0,0:54:10.06,0:54:13.46,ch,,0,0,0,,\N{\ren}you shouldn't have to track anything and\Nif you do and as per item
Dialogue: 0,0:54:13.46,0:54:17.52,ch,,0,0,0,,\N{\ren}stick in the roller a
Dialogue: 0,0:54:17.52,0:54:23.38,ch,,0,0,0,,\N{\ren}Missy former question I think we have\Ntime for yes customs
Dialogue: 0,0:54:23.38,0:54:26.72,ch,,0,0,0,,\N{\ren}whose yes crews you
Dialogue: 0,0:54:26.72,0:54:31.52,ch,,0,0,0,,\N{\ren}runs him
Dialogue: 0,0:54:31.52,0:54:36.79,ch,,0,0,0,,\N{\ren}oh you mean like for fling behavior
Dialogue: 0,0:54:36.79,0:54:41.46,ch,,0,0,0,,\N{\ren}it's not really exposed so if you were\Nto do it you would have to override the
Dialogue: 0,0:54:41.46,0:54:43.71,ch,,0,0,0,,\N{\ren}recycler view itself as well
Dialogue: 0,0:54:43.71,0:54:47.96,ch,,0,0,0,,\N{\ren}and kinda modify the API a little bit so\NI am really look at doing it
Dialogue: 0,0:54:47.96,0:54:52.09,ch,,0,0,0,,\N{\ren}it would be possible but its it's not\Ngiven to you that behavior is really
Dialogue: 0,0:54:52.09,0:54:54.51,ch,,0,0,0,,\N{\ren}define internally the only when you're\Ngiving is the
Dialogue: 0,0:54:54.51,0:54:57.53,ch,,0,0,0,,\N{\ren}is the animation part of that that's not\Nuser directed
Dialogue: 0,0:54:57.53,0:55:02.01,ch,,0,0,0,,\N{\ren}core alright well thanks for your time\Nguys if you have any other questions all
Dialogue: 0,0:55:02.01,0:55:03.71,ch,,0,0,0,,\N{\ren}step after the site here we can address\Non that
